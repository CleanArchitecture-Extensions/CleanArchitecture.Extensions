{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CleanArchitecture.Extensions","text":"<p>CleanArchitecture.Extensions is a set of opt-in NuGet packages that plug into Jason Taylor's Clean Architecture template without forking it. Each package is designed to be composable, template-aligned, and easy to remove.</p>"},{"location":"#what-you-get","title":"What you get","text":"<ul> <li>Caching abstractions and MediatR query caching behavior.</li> <li>Multitenancy core plus ASP.NET Core and EF Core adapters.</li> <li>Extension methods and options that keep integration minimal and explicit.</li> </ul>"},{"location":"#how-it-fits-the-template","title":"How it fits the template","text":"<ul> <li>Application layer: pipeline behaviors and abstractions (<code>ICache</code>, <code>ICurrentTenant</code>).</li> <li>Infrastructure layer: adapters and data-enforcement helpers (EF Core, cache providers).</li> <li>Host layer: middleware and endpoint filters for HTTP workloads.</li> </ul>"},{"location":"#packages-current","title":"Packages (current)","text":"<ul> <li>CleanArchitecture.Extensions.Caching</li> <li>CleanArchitecture.Extensions.Multitenancy (core)</li> <li>CleanArchitecture.Extensions.Multitenancy.AspNetCore</li> <li>CleanArchitecture.Extensions.Multitenancy.EFCore</li> </ul>"},{"location":"#quickstart-caching","title":"Quickstart: caching","text":"<pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Caching\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Caching\n</code></pre> <pre><code>using CleanArchitecture.Extensions.Caching;\n\nbuilder.Services.AddCleanArchitectureCaching();\n\nbuilder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCachingPipeline();\n});\n</code></pre>"},{"location":"#quickstart-multitenancy-core-aspnet-core","title":"Quickstart: multitenancy (core + ASP.NET Core)","text":"<pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Multitenancy\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy\ndotnet add src/Web/Web.csproj package CleanArchitecture.Extensions.Multitenancy.AspNetCore\n</code></pre> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.AspNetCore;\nusing CleanArchitecture.Extensions.Multitenancy.AspNetCore.Middleware;\n\nbuilder.Services.AddCleanArchitectureMultitenancyAspNetCore();\n\nbuilder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureMultitenancyPipeline();\n});\n\nvar app = builder.Build();\napp.UseCleanArchitectureMultitenancy();\n</code></pre>"},{"location":"#documentation-map","title":"Documentation map","text":"<ul> <li>Getting started</li> <li>Concepts</li> <li>Extensions catalog</li> <li>Recipes</li> <li>Reference</li> <li>Troubleshooting</li> <li>Roadmap</li> </ul>"},{"location":"#compatibility","title":"Compatibility","text":"<ul> <li>Target frameworks: <code>net10.0</code>.</li> <li>Designed to integrate with the Jason Taylor Clean Architecture template without modifying the template repository.</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p>This roadmap reflects the current focus and order of delivery. Items may shift as new requirements appear.</p>"},{"location":"roadmap/#shipped-preview","title":"Shipped (preview)","text":"<ul> <li>CleanArchitecture.Extensions.Caching: cache abstractions, adapters, and query caching behavior.</li> <li>Multitenancy Core: tenant model, resolution providers, enforcement behavior.</li> <li>Multitenancy.AspNetCore: middleware and endpoint enforcement for HTTP.</li> <li>Multitenancy.EFCore: tenant-aware DbContext helpers, filters, and SaveChanges enforcement.</li> </ul>"},{"location":"roadmap/#next-up","title":"Next up","text":"<ul> <li>Multitenancy.Identity adapter (tenant-aware Identity stores).</li> <li>Multitenancy.Provisioning adapter (tenant onboarding workflows).</li> <li>Caching adapters for Redis and other distributed stores.</li> </ul>"},{"location":"roadmap/#later","title":"Later","text":"<ul> <li>Sharding, storage, and observability adapters.</li> <li>Expanded samples and recipe library.</li> <li>API/reference extraction and versioned docs.</li> </ul>"},{"location":"concepts/architecture-fit/","title":"Architecture fit","text":"<p>CleanArchitecture.Extensions packages are designed to fit the Jason Taylor Clean Architecture template without changing its structure. The goal is to keep boundaries intact while adding cross-cutting behavior through composition.</p>"},{"location":"concepts/architecture-fit/#design-principles","title":"Design principles","text":"<ul> <li>No template fork: packages integrate through DI, middleware, and MediatR behaviors.</li> <li>Layered boundaries: Application depends on abstractions, Infrastructure provides adapters, and the host wires everything up.</li> <li>Opt-in by default: each extension is optional and can be removed without structural changes.</li> <li>Convention-aligned: naming, registration patterns, and pipeline order match the template.</li> </ul>"},{"location":"concepts/architecture-fit/#placement-guidance","title":"Placement guidance","text":"Layer Typical responsibilities Extension examples Application Behaviors and abstractions <code>QueryCachingBehavior</code>, <code>TenantEnforcementBehavior</code>, <code>ICurrentTenant</code> Infrastructure Adapters and enforcement <code>MemoryCacheAdapter</code>, <code>TenantSaveChangesInterceptor</code> Host (Web/API) Middleware and endpoint filters <code>TenantResolutionMiddleware</code>, <code>TenantEnforcementEndpointFilter</code>"},{"location":"concepts/architecture-fit/#template-integration-points","title":"Template integration points","text":"<ul> <li><code>src/Application/DependencyInjection.cs</code>: register MediatR behaviors.</li> <li><code>src/Infrastructure/DependencyInjection.cs</code>: register adapter services (caching, EF Core, etc.).</li> <li><code>src/Web/Program.cs</code>: add middleware and endpoint filters.</li> </ul>"},{"location":"concepts/architecture-fit/#removal-strategy","title":"Removal strategy","text":"<ul> <li>Remove the NuGet package reference.</li> <li>Remove <code>AddCleanArchitecture...</code> registrations and pipeline behaviors.</li> <li>Delete any configuration sections and validation stores that were introduced.</li> </ul>"},{"location":"concepts/composition/","title":"Composition and invariants","text":"<p>Use the extensions together without losing clarity or breaking the template's ordering.</p>"},{"location":"concepts/composition/#invariants","title":"Invariants","text":"<ul> <li>Explicit wiring: every behavior or middleware is registered intentionally.</li> <li>No hidden dependencies: cross-extension integration uses explicit opt-in hooks.</li> <li>Fail fast: invalid configuration should be detected early (startup or first request).</li> <li>Keep handlers clean: cross-cutting concerns live in pipeline behaviors, filters, or adapters.</li> </ul>"},{"location":"concepts/composition/#recommended-composition-order","title":"Recommended composition order","text":""},{"location":"concepts/composition/#mediatr-pipeline-application","title":"MediatR pipeline (Application)","text":"<p>A common order that aligns with the template is:</p> <ol> <li>Logging pre-processors</li> <li>Exception handling</li> <li>Authorization</li> <li>Validation</li> <li>Multitenancy validation/enforcement</li> <li>Caching behavior</li> <li>Performance logging</li> </ol> <p>Adjust for your template, but keep validation/enforcement before caching to avoid caching invalid requests.</p>"},{"location":"concepts/composition/#http-middleware-webapi","title":"HTTP middleware (Web/API)","text":"<ul> <li>Correlation and localization (if used)</li> <li>Tenant resolution</li> <li>Authentication/authorization</li> <li>MVC/minimal API endpoints</li> </ul> <p>If you rely on claim-based tenant resolution, place authentication before the tenant resolution middleware.</p>"},{"location":"concepts/composition/#cross-extension-integration","title":"Cross-extension integration","text":"<ul> <li>Multitenancy + caching: call <code>AddCleanArchitectureMultitenancyCaching</code> to include tenant IDs in cache keys.</li> <li>Multitenancy + EF Core: ensure <code>TenantSaveChangesInterceptor</code> is registered and your DbContext uses tenant-aware model customization.</li> </ul>"},{"location":"concepts/composition/#compatibility-notes","title":"Compatibility notes","text":"<ul> <li>Keep <code>MultitenancyOptions</code> and EF Core options aligned (tenant ID property name, global entities, isolation mode).</li> <li>Use consistent tenant identifiers across resolution sources (header, route, host) to avoid ambiguity.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We keep the upstream template pristine and ship everything as opt-in packages. Contributions must follow that contract and stay in sync with docs and tests.</p>"},{"location":"contributing/#principles","title":"Principles","text":"<ul> <li>Template-first: mirror Jason Taylor's conventions. Do not modify the upstream template.</li> <li>Opt-in by default: minimal required configuration, clear defaults, easy removal.</li> <li>Docs and tests: every behavior change updates docs under <code>docs/</code> and tests under <code>tests/</code>.</li> <li>Separation of concerns: Application stays clean; Infrastructure and host adapt via composition.</li> </ul>"},{"location":"contributing/#workflow","title":"Workflow","text":"<p>1) Read the relevant design doc in <code>HighLevelDocs/Domain*/CleanArchitecture.Extensions.*.md</code>. 2) Make changes inside <code>CleanArchitecture.Extensions/</code> (src/tests/samples/docs/build). 3) Update docs and ensure navigation links remain valid. 4) Add or update tests for the package you touched.</p>"},{"location":"contributing/#documentation-style","title":"Documentation style","text":"<ul> <li>Follow the extension template: overview, when to use, compat, install, usage, troubleshooting.</li> <li>Use fenced code blocks with language tags (<code>csharp</code>, <code>powershell</code>, <code>json</code>).</li> <li>Prefer short, runnable snippets and keep them under ~30 lines.</li> <li>Use Markdown links for external URLs (e.g., <code>[Quickstart](https://...)</code>).</li> </ul>"},{"location":"contributing/#testing-expectations","title":"Testing expectations","text":"<ul> <li>Add unit tests for behaviors and configuration logic.</li> <li>Add integration tests for EF Core and ASP.NET Core adapters when behavior changes.</li> <li>Keep test names aligned with existing naming conventions.</li> </ul>"},{"location":"contributing/#local-docs-preview","title":"Local docs preview","text":"<pre><code>python -m venv .venv\n. .venv/Scripts/Activate.ps1\npip install -r docs/requirements.txt\nmkdocs serve\n</code></pre>"},{"location":"extensions/","title":"Extensions catalog","text":"<p>This catalog lists the extensions that ship today and how they fit into the template.</p>"},{"location":"extensions/#shipped-packages","title":"Shipped packages","text":"Package Purpose Docs <code>CleanArchitecture.Extensions.Caching</code> Cache abstractions, adapters, and query caching behavior. Caching <code>CleanArchitecture.Extensions.Multitenancy</code> Core tenant model, resolution pipeline, and MediatR behaviors. Multitenancy Core <code>CleanArchitecture.Extensions.Multitenancy.AspNetCore</code> HTTP middleware and endpoint enforcement. Multitenancy.AspNetCore <code>CleanArchitecture.Extensions.Multitenancy.EFCore</code> EF Core filters, interceptors, and tenant-aware factories. Multitenancy.EFCore"},{"location":"extensions/#planned","title":"Planned","text":"<ul> <li>Multitenancy.Identity</li> <li>Multitenancy.Provisioning</li> <li>Multitenancy.Redis</li> <li>Multitenancy.Sharding</li> <li>Storage/Search adapters</li> </ul> <p>See the Roadmap for the current plan.</p>"},{"location":"extensions/caching/","title":"Extension: Caching","text":""},{"location":"extensions/caching/#overview","title":"Overview","text":"<p>CleanArchitecture.Extensions.Caching provides cache abstractions, deterministic key generation, and a MediatR query caching behavior. It is provider-agnostic and can target in-memory or distributed caches without leaking infrastructure concerns into handlers.</p>"},{"location":"extensions/caching/#when-to-use","title":"When to use","text":"<ul> <li>You want transparent query caching without embedding cache calls in handlers.</li> <li>You need deterministic, namespace-aware cache keys.</li> <li>You want to start with memory caching in development and switch to distributed cache in production.</li> </ul>"},{"location":"extensions/caching/#prereqs-and-compatibility","title":"Prereqs and compatibility","text":"<ul> <li>Target framework: <code>net10.0</code>.</li> <li>Dependencies: MediatR <code>13.1.0</code>, <code>Microsoft.Extensions.Caching.*</code> <code>10.0.0</code>.</li> </ul>"},{"location":"extensions/caching/#install","title":"Install","text":"<pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Caching\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"extensions/caching/#register-services","title":"Register services","text":"<pre><code>using CleanArchitecture.Extensions.Caching;\nusing CleanArchitecture.Extensions.Caching.Options;\n\nbuilder.Services.AddCleanArchitectureCaching(options =&gt;\n{\n    options.DefaultNamespace = \"MyApp\";\n    options.MaxEntrySizeBytes = 256 * 1024;\n}, behaviorOptions =&gt;\n{\n    behaviorOptions.DefaultTtl = TimeSpan.FromMinutes(5);\n});\n</code></pre>"},{"location":"extensions/caching/#add-the-mediatr-behavior","title":"Add the MediatR behavior","text":"<pre><code>builder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCachingPipeline();\n});\n</code></pre>"},{"location":"extensions/caching/#how-query-caching-works","title":"How query caching works","text":"<p><code>QueryCachingBehavior&lt;TRequest, TResponse&gt;</code> applies cache-aside semantics:</p> <ul> <li>The default predicate caches requests that opt in via <code>ICacheableQuery</code> or <code>[CacheableQuery]</code>.</li> <li>The cache key uses the request type name as the resource and a SHA256 hash of the request payload.</li> <li>Cache hits short-circuit the handler; cache misses store the handler result.</li> </ul> <p>Opt-in a query by marker interface or attribute:</p> <pre><code>using CleanArchitecture.Extensions.Caching;\nusing CleanArchitecture.Extensions.Caching.Abstractions;\n\n[CacheableQuery]\npublic record GetTodosQuery : IRequest&lt;TodosVm&gt;;\n\n// or\npublic record GetUserQuery(int Id) : IRequest&lt;UserDto&gt;, ICacheableQuery;\n</code></pre> <p>Configure request selection and TTLs via <code>QueryCachingBehaviorOptions</code>:</p> <pre><code>builder.Services.AddCleanArchitectureCaching(\n    configureQueryCaching: options =&gt;\n    {\n        options.CachePredicate = request =&gt; request is ICacheableQuery;\n        options.DefaultTtl = TimeSpan.FromMinutes(2);\n        options.TtlByRequestType[typeof(GetUserQuery)] = TimeSpan.FromSeconds(30);\n        options.CacheNullValues = false;\n    });\n</code></pre>"},{"location":"extensions/caching/#cache-keys-and-scopes","title":"Cache keys and scopes","text":"<ul> <li>Key format: <code>{namespace}:{tenant?}:{resource}:{hash}</code>.</li> <li><code>DefaultCacheKeyFactory</code> hashes the request payload as JSON (deterministic SHA256).</li> <li><code>ICacheScope</code> supplies the namespace and optional tenant segment.</li> </ul> <p>If you customize keys, keep them deterministic and stable across versions. For user-scoped data, include user context in the hash or namespace.</p>"},{"location":"extensions/caching/#choose-a-cache-adapter","title":"Choose a cache adapter","text":"<p>The default <code>ICache</code> implementation is <code>MemoryCacheAdapter</code>.</p> <p>Note</p> <p>The memory adapter is process-local. In a multi-instance deployment, use a distributed cache.</p> <p>To use a distributed cache, register <code>IDistributedCache</code> and swap the adapter:</p> <pre><code>using CleanArchitecture.Extensions.Caching.Adapters;\nusing Microsoft.Extensions.Caching.StackExchangeRedis;\n\nbuilder.Services.AddCleanArchitectureCaching();\nbuilder.Services.AddStackExchangeRedisCache(options =&gt;\n{\n    options.Configuration = \"&lt;redis-connection-string&gt;\";\n});\n\nbuilder.Services.AddSingleton&lt;ICache, DistributedCacheAdapter&gt;();\n</code></pre>"},{"location":"extensions/caching/#serialization","title":"Serialization","text":"<p>The default serializer is <code>SystemTextJsonCacheSerializer</code>. Replace it when needed:</p> <pre><code>using CleanArchitecture.Extensions.Caching.Serialization;\n\nbuilder.Services.AddSingleton&lt;ICacheSerializer&gt;(sp =&gt;\n    new SystemTextJsonCacheSerializer(new JsonSerializerOptions(JsonSerializerDefaults.Web)));\n</code></pre> <p>When multiple serializers are registered, set <code>CachingOptions.PreferredSerializer</code> to a content type or serializer type name.</p>"},{"location":"extensions/caching/#stampede-protection-and-entry-options","title":"Stampede protection and entry options","text":"<ul> <li><code>CachingOptions.StampedePolicy</code> controls locking, timeouts, and jitter.</li> <li><code>CachingOptions.DefaultEntryOptions</code> defines expiration, priority, and size hints.</li> </ul> <pre><code>builder.Services.AddCleanArchitectureCaching(options =&gt;\n{\n    options.StampedePolicy = new CacheStampedePolicy\n    {\n        EnableLocking = true,\n        LockTimeout = TimeSpan.FromSeconds(3),\n        Jitter = TimeSpan.FromMilliseconds(50)\n    };\n});\n</code></pre>"},{"location":"extensions/caching/#invalidation-guidance","title":"Invalidation guidance","text":"<p>Caching is read-through; invalidation is explicit. On command success or domain events, remove keys:</p> <pre><code>await cache.RemoveAsync(cacheScope.Create(\"GetUserQuery\", hash));\n</code></pre> <p>Keep key conventions stable and consider bumping the namespace for breaking DTO changes.</p>"},{"location":"extensions/caching/#multitenancy-integration","title":"Multitenancy integration","text":"<p>If you use multitenancy, call <code>AddCleanArchitectureMultitenancyCaching</code> to include tenant IDs in cache keys:</p> <pre><code>builder.Services.AddCleanArchitectureCaching();\nbuilder.Services.AddCleanArchitectureMultitenancyCaching();\n</code></pre>"},{"location":"extensions/caching/#observability","title":"Observability","text":"<ul> <li><code>QueryCachingBehavior</code> logs cache hits and misses at <code>Debug</code> level.</li> <li>Adapters log warnings on oversized payloads or deserialization failures.</li> </ul>"},{"location":"extensions/caching/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Cache is never hit: ensure the request type matches the cache predicate and the behavior is registered.</li> <li>Missing tenant in keys: call <code>AddCleanArchitectureMultitenancyCaching</code> after caching registration.</li> <li>Large payloads: raise <code>MaxEntrySizeBytes</code> or skip caching via <code>ResponseCachePredicate</code>.</li> </ul>"},{"location":"extensions/caching/#samples-and-tests","title":"Samples and tests","text":"<p>See the caching tests under <code>tests/</code> for behavior coverage and usage patterns.</p>"},{"location":"extensions/caching/#reference","title":"Reference","text":"<ul> <li>Caching options</li> </ul>"},{"location":"extensions/multitenancy-aspnetcore/","title":"Extension: Multitenancy.AspNetCore","text":""},{"location":"extensions/multitenancy-aspnetcore/#overview","title":"Overview","text":"<p>CleanArchitecture.Extensions.Multitenancy.AspNetCore provides HTTP-specific adapters for the multitenancy core. It includes middleware to resolve tenants from <code>HttpContext</code>, endpoint filters for enforcement, and helpers for minimal APIs and MVC.</p>"},{"location":"extensions/multitenancy-aspnetcore/#when-to-use","title":"When to use","text":"<ul> <li>You need tenant resolution for HTTP requests.</li> <li>You want tenant enforcement in minimal APIs or MVC without custom filters.</li> <li>You want consistent ProblemDetails responses for multitenancy errors.</li> </ul>"},{"location":"extensions/multitenancy-aspnetcore/#prereqs-and-compatibility","title":"Prereqs and compatibility","text":"<ul> <li>Target framework: <code>net10.0</code>.</li> <li>Dependencies: <code>Microsoft.AspNetCore.App</code> and the multitenancy core package.</li> </ul>"},{"location":"extensions/multitenancy-aspnetcore/#install","title":"Install","text":"<pre><code>dotnet add src/Web/Web.csproj package CleanArchitecture.Extensions.Multitenancy.AspNetCore\n</code></pre>"},{"location":"extensions/multitenancy-aspnetcore/#register-services-and-middleware","title":"Register services and middleware","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore;\nusing CleanArchitecture.Extensions.Multitenancy.AspNetCore.Middleware;\n\nbuilder.Services.AddCleanArchitectureMultitenancyAspNetCore();\n\nvar app = builder.Build();\napp.UseCleanArchitectureMultitenancy();\n</code></pre>"},{"location":"extensions/multitenancy-aspnetcore/#minimal-api-enforcement","title":"Minimal API enforcement","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore.Routing;\n\napp.MapGroup(\"/tenants/{tenantId}\")\n    .AddTenantEnforcement()\n    .RequireTenant()\n    .MapGet(\"/profile\", () =&gt; Results.Ok());\n</code></pre>"},{"location":"extensions/multitenancy-aspnetcore/#tenant-requirements-for-endpoints","title":"Tenant requirements for endpoints","text":"<ul> <li>Minimal APIs: use <code>.RequireTenant()</code> or <code>.AllowAnonymousTenant()</code> on route groups or handlers.</li> <li>MVC: apply <code>[RequiresTenant]</code> or <code>[AllowAnonymousTenant]</code> to controllers/actions.</li> </ul>"},{"location":"extensions/multitenancy-aspnetcore/#mvc-enforcement","title":"MVC enforcement","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore;\n\nbuilder.Services\n    .AddControllers()\n    .AddMultitenancyEnforcement();\n</code></pre>"},{"location":"extensions/multitenancy-aspnetcore/#options","title":"Options","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore;\nusing CleanArchitecture.Extensions.Multitenancy.AspNetCore.Options;\nusing CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nbuilder.Services.AddCleanArchitectureMultitenancyAspNetCore(\n    coreOptions =&gt;\n    {\n        coreOptions.HeaderNames = new[] { \"X-Tenant-ID\" };\n        coreOptions.RouteParameterName = \"tenantId\";\n    },\n    aspNetOptions =&gt;\n    {\n        aspNetOptions.CorrelationIdHeaderName = \"X-Correlation-ID\";\n        aspNetOptions.StoreTenantInHttpContextItems = true;\n    });\n</code></pre>"},{"location":"extensions/multitenancy-aspnetcore/#access-the-resolved-tenant","title":"Access the resolved tenant","text":"<p>If <code>StoreTenantInHttpContextItems</code> is enabled (default), you can read the resolved context:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore.Context;\n\nvar tenantContext = httpContext.GetTenantContext();\n</code></pre>"},{"location":"extensions/multitenancy-aspnetcore/#problemdetails-mapping","title":"ProblemDetails mapping","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore.ProblemDetails;\n\nif (TenantProblemDetailsMapper.TryCreate(exception, httpContext, out var details))\n{\n    return Results.Problem(details);\n}\n</code></pre>"},{"location":"extensions/multitenancy-aspnetcore/#middleware-ordering","title":"Middleware ordering","text":"<ul> <li>Place tenant resolution before authorization and handler execution.</li> <li>If you use claim-based tenant resolution, run authentication before <code>UseCleanArchitectureMultitenancy</code> so claims are available.</li> </ul>"},{"location":"extensions/multitenancy-aspnetcore/#key-components","title":"Key components","text":"<ul> <li><code>TenantResolutionMiddleware</code></li> <li><code>TenantEnforcementEndpointFilter</code> / <code>TenantEnforcementActionFilter</code></li> <li><code>EndpointConventionBuilderExtensions</code></li> <li><code>HttpContextTenantExtensions</code></li> <li><code>AspNetCoreMultitenancyOptions</code></li> </ul>"},{"location":"extensions/multitenancy-aspnetcore/#related-docs","title":"Related docs","text":"<ul> <li>Multitenancy core</li> <li>Multitenancy options</li> <li>AspNetCore options</li> <li>Troubleshooting</li> </ul>"},{"location":"extensions/multitenancy-core/","title":"Extension: Multitenancy Core","text":""},{"location":"extensions/multitenancy-core/#overview","title":"Overview","text":"<p>CleanArchitecture.Extensions.Multitenancy provides the core tenant model, resolution pipeline, validation hooks, and MediatR behaviors without any ASP.NET Core or EF Core dependencies. It is host-agnostic: you supply a host adapter that builds a <code>TenantResolutionContext</code> and sets the current tenant.</p>"},{"location":"extensions/multitenancy-core/#when-to-use","title":"When to use","text":"<ul> <li>You need consistent tenant resolution across APIs, background jobs, or message handlers.</li> <li>You want tenant enforcement at the pipeline level instead of scattering checks in handlers.</li> <li>You need tenant-aware logging and cache scoping.</li> </ul>"},{"location":"extensions/multitenancy-core/#prereqs-and-compatibility","title":"Prereqs and compatibility","text":"<ul> <li>Target framework: <code>net10.0</code>.</li> <li>Dependencies: MediatR <code>13.1.0</code>, <code>Microsoft.Extensions.*</code> <code>10.0.0</code>.</li> <li>Host adapter required (use the ASP.NET Core adapter for web APIs).</li> </ul>"},{"location":"extensions/multitenancy-core/#install","title":"Install","text":"<pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Multitenancy\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy\n</code></pre>"},{"location":"extensions/multitenancy-core/#register-services","title":"Register services","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nbuilder.Services.AddCleanArchitectureMultitenancy(options =&gt;\n{\n    options.HeaderNames = new[] { \"X-Tenant-ID\" };\n    options.RouteParameterName = \"tenantId\";\n    options.QueryParameterName = \"tenantId\";\n    options.ClaimType = \"tenant_id\";\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/#resolve-and-set-tenant-context-host-adapter","title":"Resolve and set tenant context (host adapter)","text":"<p>The core package does not read HTTP requests directly. A host adapter builds a <code>TenantResolutionContext</code> and calls <code>ITenantResolver</code>.</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantResolutionMiddleware\n{\n    private readonly RequestDelegate _next;\n\n    public TenantResolutionMiddleware(RequestDelegate next) =&gt; _next = next;\n\n    public async Task InvokeAsync(HttpContext httpContext, ITenantResolver resolver, ITenantAccessor accessor)\n    {\n        var context = new TenantResolutionContext\n        {\n            Host = httpContext.Request.Host.Host,\n            CorrelationId = httpContext.TraceIdentifier\n        };\n\n        foreach (var header in httpContext.Request.Headers)\n        {\n            context.Headers[header.Key] = header.Value.ToString();\n        }\n\n        foreach (var route in httpContext.Request.RouteValues)\n        {\n            if (route.Value is not null)\n            {\n                context.RouteValues[route.Key] = route.Value.ToString()!;\n            }\n        }\n\n        foreach (var query in httpContext.Request.Query)\n        {\n            context.Query[query.Key] = query.Value.ToString();\n        }\n\n        if (httpContext.User?.Identity?.IsAuthenticated == true)\n        {\n            foreach (var claim in httpContext.User.Claims)\n            {\n                context.Claims[claim.Type] = claim.Value;\n            }\n        }\n\n        var tenantContext = await resolver.ResolveAsync(context, httpContext.RequestAborted);\n        using (accessor.BeginScope(tenantContext))\n        {\n            await _next(httpContext);\n        }\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/#add-mediatr-behaviors","title":"Add MediatR behaviors","text":"<pre><code>builder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureMultitenancyPipeline();\n});\n</code></pre> <p>The pipeline includes:</p> <ul> <li><code>TenantValidationBehavior</code> (optional validation against cache or store)</li> <li><code>TenantEnforcementBehavior</code> (enforces resolution and lifecycle)</li> <li><code>TenantCorrelationBehavior</code> (adds tenant ID to logs and activity baggage)</li> </ul>"},{"location":"extensions/multitenancy-core/#tenant-requirements","title":"Tenant requirements","text":"<p>Use <code>ITenantRequirement</code>, <code>RequiresTenantAttribute</code>, or <code>AllowHostRequestsAttribute</code> to control enforcement per request.</p> <pre><code>public sealed record GetTenantSummaryQuery() : IRequest&lt;string&gt;, ITenantRequirement\n{\n    public TenantRequirementMode Requirement =&gt; TenantRequirementMode.Required;\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/#validation-and-stores","title":"Validation and stores","text":"<p>Enable validation to prevent spoofed tenant IDs:</p> <pre><code>builder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.ValidationMode = TenantValidationMode.Repository;\n    options.ResolutionCacheTtl = TimeSpan.FromMinutes(10);\n});\n</code></pre> <p>Implement <code>ITenantInfoStore</code> and (optional) <code>ITenantInfoCache</code> to back validation. When validation is enabled and no store/cache is registered, the system logs warnings and the tenant remains unvalidated.</p>"},{"location":"extensions/multitenancy-core/#caching-integration","title":"Caching integration","text":"<p>If you use the caching package, replace the cache scope so keys include <code>tenantId</code>:</p> <pre><code>builder.Services.AddCleanArchitectureCaching();\nbuilder.Services.AddCleanArchitectureMultitenancyCaching();\n</code></pre>"},{"location":"extensions/multitenancy-core/#context-propagation","title":"Context propagation","text":"<p><code>CurrentTenantAccessor</code> uses <code>AsyncLocal</code>. Use <code>ITenantAccessor.BeginScope</code> for background jobs or message handlers, and <code>ITenantContextSerializer</code> when you need to serialize context into job payloads.</p>"},{"location":"extensions/multitenancy-core/#reference-and-deep-dives","title":"Reference and deep dives","text":"<ul> <li>Resolution pipeline</li> <li>Requirements and behaviors</li> <li>Validation and stores</li> <li>Context propagation</li> <li>Caching integration</li> <li>Options reference</li> <li>Troubleshooting</li> </ul>"},{"location":"extensions/multitenancy-core/#related-modules","title":"Related modules","text":"<ul> <li>Multitenancy.AspNetCore</li> <li>Multitenancy.EFCore</li> <li>Multitenancy.Identity (planned)</li> <li>Multitenancy.Provisioning (planned)</li> </ul>"},{"location":"extensions/multitenancy-efcore/","title":"Extension: Multitenancy.EFCore","text":""},{"location":"extensions/multitenancy-efcore/#overview","title":"Overview","text":"<p>CleanArchitecture.Extensions.Multitenancy.EFCore adds EF Core helpers for tenant isolation: query filters, SaveChanges enforcement, schema handling, and tenant-aware DbContext factories.</p>"},{"location":"extensions/multitenancy-efcore/#when-to-use","title":"When to use","text":"<ul> <li>You want row-level isolation in a shared database.</li> <li>You need schema-per-tenant isolation with separate EF Core model caches.</li> <li>You want SaveChanges to enforce tenant ownership automatically.</li> </ul>"},{"location":"extensions/multitenancy-efcore/#prereqs-and-compatibility","title":"Prereqs and compatibility","text":"<ul> <li>Target framework: <code>net10.0</code>.</li> <li>Dependencies: EF Core <code>10.0.0</code>.</li> <li>Requires multitenancy core and a tenant resolver in your host.</li> </ul>"},{"location":"extensions/multitenancy-efcore/#install","title":"Install","text":"<pre><code>dotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy.EFCore\n</code></pre>"},{"location":"extensions/multitenancy-efcore/#register-services","title":"Register services","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.EFCore;\nusing CleanArchitecture.Extensions.Multitenancy.EFCore.Options;\n\nbuilder.Services.AddCleanArchitectureMultitenancyEfCore(options =&gt;\n{\n    options.Mode = TenantIsolationMode.SharedDatabase;\n    options.TenantIdPropertyName = \"TenantId\";\n    options.UseShadowTenantId = true;\n});\n</code></pre>"},{"location":"extensions/multitenancy-efcore/#configure-dbcontext","title":"Configure DbContext","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.EFCore.Interceptors;\n\nbuilder.Services.AddDbContext&lt;ApplicationDbContext&gt;((sp, options) =&gt;\n{\n    options.UseSqlServer(builder.Configuration.GetConnectionString(\"DefaultConnection\"));\n    options.AddInterceptors(sp.GetRequiredService&lt;TenantSaveChangesInterceptor&gt;());\n});\n</code></pre> <p>If your host already registers <code>ISaveChangesInterceptor</code> instances, you can omit the explicit interceptor registration.</p>"},{"location":"extensions/multitenancy-efcore/#choose-an-integration-style","title":"Choose an integration style","text":""},{"location":"extensions/multitenancy-efcore/#option-a-derive-from-tenantdbcontext-non-identity-dbcontext","title":"Option A: derive from TenantDbContext (non-Identity DbContext)","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\nusing CleanArchitecture.Extensions.Multitenancy.EFCore.Abstractions;\nusing CleanArchitecture.Extensions.Multitenancy.EFCore;\nusing CleanArchitecture.Extensions.Multitenancy.EFCore.Options;\n\npublic sealed class ApplicationDbContext : TenantDbContext\n{\n    public ApplicationDbContext(\n        DbContextOptions&lt;ApplicationDbContext&gt; options,\n        ICurrentTenant currentTenant,\n        IOptions&lt;EfCoreMultitenancyOptions&gt; optionsAccessor,\n        ITenantModelCustomizer modelCustomizer)\n        : base(options, currentTenant, optionsAccessor, modelCustomizer)\n    {\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-efcore/#option-b-keep-identitydbcontext-template-default","title":"Option B: keep IdentityDbContext (template default)","text":"<pre><code>using System.Reflection;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\nusing CleanArchitecture.Extensions.Multitenancy.EFCore.Abstractions;\nusing CleanArchitecture.Extensions.Multitenancy.EFCore.Options;\nusing Microsoft.AspNetCore.Identity.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Options;\n\npublic class ApplicationDbContext : IdentityDbContext&lt;ApplicationUser&gt;, ITenantDbContext\n{\n    private readonly ICurrentTenant _currentTenant;\n    private readonly EfCoreMultitenancyOptions _multitenancyOptions;\n    private readonly ITenantModelCustomizer _tenantModelCustomizer;\n\n    public ApplicationDbContext(\n        DbContextOptions&lt;ApplicationDbContext&gt; options,\n        ICurrentTenant currentTenant,\n        IOptions&lt;EfCoreMultitenancyOptions&gt; optionsAccessor,\n        ITenantModelCustomizer tenantModelCustomizer)\n        : base(options)\n    {\n        _currentTenant = currentTenant;\n        _multitenancyOptions = optionsAccessor.Value;\n        _tenantModelCustomizer = tenantModelCustomizer;\n    }\n\n    public string? CurrentTenantId =&gt; _currentTenant.TenantId;\n\n    public ITenantInfo? CurrentTenantInfo =&gt; _currentTenant.TenantInfo;\n\n    protected override void OnModelCreating(ModelBuilder builder)\n    {\n        base.OnModelCreating(builder);\n        builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());\n        _tenantModelCustomizer.Customize(builder, this, _multitenancyOptions);\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-efcore/#tenant-entities-and-global-entities","title":"Tenant entities and global entities","text":"<p>Tenant-scoped entity:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.EFCore.Abstractions;\n\npublic sealed class Customer : ITenantEntity\n{\n    public int Id { get; set; }\n    public string TenantId { get; set; } = string.Empty;\n}\n</code></pre> <p>Exclude global entities from filtering:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.EFCore.Abstractions;\n\n[GlobalEntity]\npublic sealed class FeatureFlag\n{\n    public int Id { get; set; }\n}\n</code></pre> <p>You can also mark global entities via <code>IGlobalEntity</code> or with <code>EfCoreMultitenancyOptions.GlobalEntityTypes</code>.</p>"},{"location":"extensions/multitenancy-efcore/#schema-per-tenant-setup","title":"Schema-per-tenant setup","text":"<pre><code>builder.Services.AddCleanArchitectureMultitenancyEfCore(options =&gt;\n{\n    options.Mode = TenantIsolationMode.SchemaPerTenant;\n    options.SchemaNameFormat = \"tenant_{0}\";\n});\n</code></pre> <p>In schema-per-tenant mode, the model cache key includes the schema to prevent cross-tenant model reuse.</p>"},{"location":"extensions/multitenancy-efcore/#database-per-tenant-setup","title":"Database-per-tenant setup","text":"<pre><code>builder.Services.AddCleanArchitectureMultitenancyEfCore(options =&gt;\n{\n    options.Mode = TenantIsolationMode.DatabasePerTenant;\n    options.ConnectionStringFormat = \"Server=.;Database=Tenant_{0};Trusted_Connection=True;TrustServerCertificate=True;\";\n});\n\nbuilder.Services.AddDbContextFactory&lt;ApplicationDbContext&gt;((sp, options) =&gt;\n{\n    options.UseSqlServer(builder.Configuration.GetConnectionString(\"DefaultConnection\"));\n});\n\nbuilder.Services.AddTenantDbContextFactory&lt;ApplicationDbContext&gt;();\n</code></pre> <p>For request-scoped DbContext registration, resolve the tenant connection inside <code>AddDbContext</code>:</p> <pre><code>builder.Services.AddDbContext&lt;ApplicationDbContext&gt;((sp, options) =&gt;\n{\n    var currentTenant = sp.GetRequiredService&lt;ICurrentTenant&gt;();\n    var resolver = sp.GetRequiredService&lt;ITenantConnectionResolver&gt;();\n    var connectionString = resolver.ResolveConnectionString(currentTenant.TenantInfo);\n\n    if (string.IsNullOrWhiteSpace(connectionString))\n    {\n        throw new InvalidOperationException(\"Tenant connection string was not resolved.\");\n    }\n\n    options.UseSqlServer(connectionString);\n});\n</code></pre>"},{"location":"extensions/multitenancy-efcore/#migrations-per-tenant","title":"Migrations per tenant","text":"<p>Use <code>TenantMigrationRunner&lt;TContext&gt;</code> to migrate tenants in sequence:</p> <pre><code>await migrationRunner.RunAsync(tenants, cancellationToken);\n</code></pre>"},{"location":"extensions/multitenancy-efcore/#key-components","title":"Key components","text":"<ul> <li><code>TenantDbContext</code>, <code>ITenantDbContext</code>, <code>TenantModelCustomizer</code></li> <li><code>TenantSaveChangesInterceptor</code></li> <li><code>TenantModelCacheKeyFactory</code></li> <li><code>ITenantDbContextFactory&lt;TContext&gt;</code> and <code>TenantMigrationRunner&lt;TContext&gt;</code></li> </ul>"},{"location":"extensions/multitenancy-efcore/#related-docs","title":"Related docs","text":"<ul> <li>Multitenancy core</li> <li>EF Core options</li> <li>Troubleshooting</li> </ul>"},{"location":"extensions/multitenancy-core/caching-integration/","title":"Multitenancy core: caching integration","text":"<p>Use the caching integration to ensure cache keys include the current tenant ID.</p>"},{"location":"extensions/multitenancy-core/caching-integration/#setup","title":"Setup","text":"<p>1) Register caching services. 2) Replace the cache scope with <code>TenantCacheScope</code>. 3) (Optional) add <code>TenantScopedCacheBehavior</code> to warn about mismatches.</p> <pre><code>using CleanArchitecture.Extensions.Caching;\nusing CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Behaviors;\n\nbuilder.Services.AddCleanArchitectureCaching();\nbuilder.Services.AddCleanArchitectureMultitenancyCaching();\n\nbuilder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddOpenBehavior(typeof(TenantScopedCacheBehavior&lt;,&gt;));\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/caching-integration/#what-changes","title":"What changes","text":"<ul> <li><code>TenantCacheScope</code> replaces <code>ICacheScope</code> and includes <code>TenantId</code> in generated keys.</li> <li>Cache key shape remains <code>{namespace}:{tenant}:{resource}:{hash}</code>.</li> <li><code>TenantScopedCacheBehavior</code> logs a warning when the cache scope tenant does not match the current tenant.</li> </ul>"},{"location":"extensions/multitenancy-core/caching-integration/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you see cache scope mismatch warnings, ensure tenant resolution runs before caching behaviors.</li> <li><code>AddCleanArchitectureMultitenancyCaching</code> throws if caching services are not registered first.</li> </ul>"},{"location":"extensions/multitenancy-core/context-propagation/","title":"Multitenancy core: context propagation","text":"<p>Tenant context is stored in <code>AsyncLocal</code> via <code>CurrentTenantAccessor</code>. This page shows how to set and propagate tenant context safely across async boundaries.</p>"},{"location":"extensions/multitenancy-core/context-propagation/#beginscope-for-background-work","title":"BeginScope for background work","text":"<p>Use <code>ITenantAccessor.BeginScope</code> to ensure the previous context is restored:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantJob\n{\n    private readonly ITenantAccessor _accessor;\n\n    public TenantJob(ITenantAccessor accessor)\n    {\n        _accessor = accessor;\n    }\n\n    public Task ExecuteAsync(string tenantId, CancellationToken cancellationToken)\n    {\n        var tenant = new TenantInfo(tenantId);\n        var resolution = TenantResolutionResult.Resolved(tenantId, TenantResolutionSource.Custom);\n        using var scope = _accessor.BeginScope(new TenantContext(tenant, resolution));\n\n        // perform tenant-bound work\n        return Task.CompletedTask;\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/context-propagation/#serialize-context-for-jobs-and-messages","title":"Serialize context for jobs and messages","text":"<p><code>ITenantContextSerializer</code> lets you store the full context in job metadata or message headers:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantMessagePublisher\n{\n    private readonly ITenantContextSerializer _serializer;\n    private readonly ICurrentTenant _currentTenant;\n\n    public TenantMessagePublisher(ITenantContextSerializer serializer, ICurrentTenant currentTenant)\n    {\n        _serializer = serializer;\n        _currentTenant = currentTenant;\n    }\n\n    public string CreateHeader()\n    {\n        var context = _currentTenant.Context;\n        return context is null ? string.Empty : _serializer.Serialize(context);\n    }\n}\n</code></pre> <p>Consumer side:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantMessageHandler\n{\n    private readonly ITenantAccessor _accessor;\n    private readonly ITenantContextSerializer _serializer;\n\n    public TenantMessageHandler(ITenantAccessor accessor, ITenantContextSerializer serializer)\n    {\n        _accessor = accessor;\n        _serializer = serializer;\n    }\n\n    public Task HandleAsync(string header)\n    {\n        var context = string.IsNullOrWhiteSpace(header) ? null : _serializer.Deserialize(header);\n        using var scope = _accessor.BeginScope(context);\n\n        // handle message\n        return Task.CompletedTask;\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/context-propagation/#asynclocal-guidance","title":"AsyncLocal guidance","text":"<ul> <li>Always wrap work in <code>BeginScope</code> so contexts are restored.</li> <li>Avoid storing <code>TenantContext</code> in static fields.</li> <li>Restore context explicitly in background workers and message handlers.</li> </ul>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/","title":"Multitenancy core: requirements and behaviors","text":"<p>This page explains how tenant requirements are expressed and how the MediatR behaviors enforce them.</p>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#tenant-requirements","title":"Tenant requirements","text":"<p>A request or endpoint can declare a requirement in two ways:</p> <p>1) Implement <code>ITenantRequirement</code> on the request type. 2) Apply <code>RequiresTenantAttribute</code> or <code>AllowHostRequestsAttribute</code> to the request or endpoint.</p> <p>Example request-level requirement:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\nusing MediatR;\n\npublic sealed record GetBillingSummaryQuery() : IRequest&lt;string&gt;, ITenantRequirement\n{\n    public TenantRequirementMode Requirement =&gt; TenantRequirementMode.Required;\n}\n</code></pre> <p>Optional host-level request:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing MediatR;\n\n[AllowHostRequests]\npublic sealed record GetHealthQuery() : IRequest&lt;string&gt;;\n</code></pre> <p>If no requirement is specified, the default is determined by:</p> <ul> <li><code>MultitenancyOptions.RequireTenantByDefault</code> (default <code>true</code>)</li> <li><code>MultitenancyOptions.AllowAnonymous</code> (default <code>false</code>)</li> </ul>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#pipeline-behaviors","title":"Pipeline behaviors","text":"<p>Register the core behaviors with:</p> <pre><code>builder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureMultitenancyPipeline();\n});\n</code></pre> <p>The pipeline includes:</p> <ul> <li><code>TenantValidationBehavior</code> - validates tenant metadata against cache/store when enabled.</li> <li><code>TenantEnforcementBehavior</code> - enforces resolution and lifecycle checks.</li> <li><code>TenantCorrelationBehavior</code> - enriches logs and activity with tenant ID.</li> </ul> <p><code>TenantScopedCacheBehavior</code> is optional and warns when cache scope does not align with the current tenant.</p>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#enforcement-rules","title":"Enforcement rules","text":"<p><code>TenantEnforcementBehavior</code> throws when:</p> <ul> <li>No tenant is resolved (<code>TenantNotResolvedException</code>).</li> <li>Tenant is not validated (<code>TenantNotFoundException</code>).</li> <li>Tenant is suspended (<code>TenantSuspendedException</code>).</li> <li>Tenant is inactive, soft-deleted, pending provisioning, deleted, or expired (<code>TenantInactiveException</code>).</li> </ul> <p>These rules are evaluated against <code>TenantInfo</code> fields: <code>IsActive</code>, <code>IsSoftDeleted</code>, <code>State</code>, and <code>ExpiresAt</code>.</p>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#log-and-trace-correlation","title":"Log and trace correlation","text":"<p><code>TenantCorrelationBehavior</code> adds the tenant ID to:</p> <ul> <li>Log scopes (key is <code>MultitenancyOptions.LogScopeKey</code>)</li> <li>Activity tags and baggage when <code>AddTenantToActivity</code> is enabled</li> </ul>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#http-enforcement","title":"HTTP enforcement","text":"<p>For HTTP endpoints, use the ASP.NET Core adapter's filters (<code>TenantEnforcementEndpointFilter</code> or <code>TenantEnforcementActionFilter</code>). They apply the same enforcement rules and can map exceptions to ProblemDetails responses.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/","title":"Multitenancy core: resolution pipeline","text":"<p>This page explains how <code>ITenantResolver</code> evaluates providers and how to customize ordering and consensus rules.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#resolution-inputs","title":"Resolution inputs","text":"<p>Tenant resolution is driven by <code>TenantResolutionContext</code>, which you populate in your host adapter:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\n\nvar context = new TenantResolutionContext\n{\n    Host = httpContext.Request.Host.Host,\n    CorrelationId = httpContext.TraceIdentifier\n};\n\nforeach (var header in httpContext.Request.Headers)\n{\n    context.Headers[header.Key] = header.Value.ToString();\n}\n\nforeach (var route in httpContext.Request.RouteValues)\n{\n    if (route.Value is not null)\n    {\n        context.RouteValues[route.Key] = route.Value.ToString()!;\n    }\n}\n\nforeach (var query in httpContext.Request.Query)\n{\n    context.Query[query.Key] = query.Value.ToString();\n}\n\nforeach (var claim in httpContext.User.Claims)\n{\n    context.Claims[claim.Type] = claim.Value;\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#built-in-providers","title":"Built-in providers","text":"<p>The core package registers these providers by default:</p> <ul> <li><code>RouteTenantProvider</code> (uses <code>RouteParameterName</code>, high confidence)</li> <li><code>HostTenantProvider</code> (uses <code>HostTenantSelector</code>, medium confidence)</li> <li><code>HeaderTenantProvider</code> (uses <code>HeaderNames</code>, medium confidence)</li> <li><code>QueryTenantProvider</code> (uses <code>QueryParameterName</code>, medium confidence)</li> <li><code>ClaimTenantProvider</code> (uses <code>ClaimType</code>, medium confidence)</li> <li><code>DefaultTenantProvider</code> (uses <code>FallbackTenant</code>/<code>FallbackTenantId</code>, low confidence)</li> </ul> <p>Header, query, and claim providers accept multiple candidates separated by <code>,</code> or <code>;</code>. Multiple candidates are treated as ambiguous and do not resolve a tenant.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#ordering-behavior","title":"Ordering behavior","text":"<p><code>CompositeTenantResolutionStrategy</code> orders providers using <code>MultitenancyOptions.ResolutionOrder</code>:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nbuilder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.ResolutionOrder = new List&lt;TenantResolutionSource&gt;\n    {\n        TenantResolutionSource.Route,\n        TenantResolutionSource.Host,\n        TenantResolutionSource.Header,\n        TenantResolutionSource.QueryString,\n        TenantResolutionSource.Claim,\n        TenantResolutionSource.Default\n    };\n});\n</code></pre> <p>Providers not listed in <code>ResolutionOrder</code> are still evaluated when <code>IncludeUnorderedProviders</code> is <code>true</code> (default).</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#consensus-mode","title":"Consensus mode","text":"<p>When <code>RequireMatchAcrossSources</code> is enabled, the strategy collects candidates from all providers and resolves only if a single unique tenant ID exists:</p> <pre><code>builder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.RequireMatchAcrossSources = true;\n});\n</code></pre> <p>This mode is useful when multiple sources can be present (for example, route + header) and you want strict consistency.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#host-parsing-rules","title":"Host parsing rules","text":"<p>The default host selector resolves the first subdomain:</p> <ul> <li><code>tenant.app.com</code> -&gt; <code>tenant</code></li> <li><code>localhost</code> -&gt; not resolved</li> <li>IP addresses -&gt; not resolved</li> </ul> <p>Override with a custom selector when needed:</p> <pre><code>builder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.HostTenantSelector = host =&gt;\n    {\n        if (host.EndsWith(\".internal\", StringComparison.OrdinalIgnoreCase))\n        {\n            return \"internal\";\n        }\n\n        return host.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n            .FirstOrDefault();\n    };\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#custom-providers","title":"Custom providers","text":"<p>Add custom providers for environment-specific resolution:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\nusing CleanArchitecture.Extensions.Multitenancy.Providers;\n\nbuilder.Services.AddSingleton&lt;ITenantProvider&gt;(\n    new DelegateTenantProvider(context =&gt;\n    {\n        if (context.Items.TryGetValue(\"tenant_override\", out var value))\n        {\n            return value?.ToString();\n        }\n\n        return null;\n    }, source: TenantResolutionSource.Custom, confidence: TenantResolutionConfidence.High));\n</code></pre>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#timeouts-and-cancellation","title":"Timeouts and cancellation","text":"<p>Set <code>ResolutionTimeout</code> to guard against slow providers:</p> <pre><code>builder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.ResolutionTimeout = TimeSpan.FromMilliseconds(50);\n});\n</code></pre> <p>The timeout is linked with the request cancellation token.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#diagnostics-tips","title":"Diagnostics tips","text":"<ul> <li>Inspect <code>TenantResolutionResult.Source</code>, <code>Confidence</code>, and <code>Candidates</code> in logs.</li> <li>Ambiguous candidates return <code>IsAmbiguous == true</code> and do not resolve a tenant.</li> <li>In consensus mode, a single unique candidate is required.</li> </ul>"},{"location":"extensions/multitenancy-core/validation-and-stores/","title":"Multitenancy core: validation and stores","text":"<p>This page explains validation modes and how to plug in tenant metadata stores and caches.</p>"},{"location":"extensions/multitenancy-core/validation-and-stores/#validation-modes","title":"Validation modes","text":"<p><code>MultitenancyOptions.ValidationMode</code> controls how tenant IDs are validated:</p> <ul> <li><code>None</code> (default): no lookup; the resolver creates a minimal active <code>TenantInfo</code> and marks it validated.</li> <li><code>Cache</code>: validate only via <code>ITenantInfoCache</code>.</li> <li><code>Repository</code>: validate via <code>ITenantInfoStore</code> and optionally cache results.</li> </ul> <p>If a required cache/store is not registered, the system logs a warning and leaves the tenant unvalidated. <code>TenantEnforcementBehavior</code> then throws <code>TenantNotFoundException</code> when a tenant is required.</p>"},{"location":"extensions/multitenancy-core/validation-and-stores/#implementing-a-store","title":"Implementing a store","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class InMemoryTenantStore : ITenantInfoStore\n{\n    private readonly Dictionary&lt;string, ITenantInfo&gt; _tenants =\n        new(StringComparer.OrdinalIgnoreCase)\n        {\n            [\"alpha\"] = new TenantInfo(\"alpha\") { Name = \"Alpha\", IsActive = true },\n            [\"beta\"] = new TenantInfo(\"beta\") { Name = \"Beta\", IsActive = true }\n        };\n\n    public Task&lt;ITenantInfo?&gt; FindByIdAsync(string tenantId, CancellationToken cancellationToken = default)\n        =&gt; Task.FromResult(_tenants.TryGetValue(tenantId, out var tenant) ? tenant : null);\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/validation-and-stores/#implementing-a-cache","title":"Implementing a cache","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class InMemoryTenantCache : ITenantInfoCache\n{\n    private readonly Dictionary&lt;string, ITenantInfo&gt; _cache = new(StringComparer.OrdinalIgnoreCase);\n\n    public Task&lt;ITenantInfo?&gt; GetAsync(string tenantId, CancellationToken cancellationToken = default)\n        =&gt; Task.FromResult(_cache.TryGetValue(tenantId, out var tenant) ? tenant : null);\n\n    public Task SetAsync(ITenantInfo tenant, TimeSpan? ttl, CancellationToken cancellationToken = default)\n    {\n        _cache[tenant.TenantId] = tenant;\n        return Task.CompletedTask;\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/validation-and-stores/#register-and-enable-validation","title":"Register and enable validation","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nbuilder.Services.AddSingleton&lt;ITenantInfoStore, InMemoryTenantStore&gt;();\nbuilder.Services.AddSingleton&lt;ITenantInfoCache, InMemoryTenantCache&gt;();\n\nbuilder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.ValidationMode = TenantValidationMode.Repository;\n    options.ResolutionCacheTtl = TimeSpan.FromMinutes(10);\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/validation-and-stores/#fallback-tenant","title":"Fallback tenant","text":"<p>The default provider can return a fallback tenant if configured:</p> <pre><code>builder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.FallbackTenantId = \"local\";\n});\n</code></pre> <p>Fallbacks are only used when the <code>DefaultTenantProvider</code> runs (source <code>Default</code>).</p>"},{"location":"extensions/multitenancy-core/validation-and-stores/#lifecycle-checks","title":"Lifecycle checks","text":"<p><code>TenantEnforcementBehavior</code> treats a tenant as invalid when:</p> <ul> <li><code>IsActive</code> is <code>false</code></li> <li><code>IsSoftDeleted</code> is <code>true</code></li> <li><code>State</code> is <code>Suspended</code>, <code>PendingProvision</code>, or <code>Deleted</code></li> <li><code>ExpiresAt</code> is in the past</li> </ul> <p>Populate these fields in your <code>ITenantInfoStore</code> so enforcement works as expected.</p>"},{"location":"getting-started/adoption-playbooks/","title":"Adoption playbooks","text":"<p>These playbooks describe pragmatic, low-risk ways to adopt extensions in production without refactoring the template.</p>"},{"location":"getting-started/adoption-playbooks/#playbook-caching-for-read-heavy-queries","title":"Playbook: caching for read-heavy queries","text":"<p>Goal: reduce latency and database load for expensive reads while keeping handlers clean.</p> <p>Steps</p> <ol> <li>Identify queries with high read frequency or expensive IO.</li> <li>Install caching and add the query caching behavior.</li> <li>Configure TTLs and a cache predicate (start conservative).</li> <li>Pick a cache adapter (memory first; distributed later).</li> <li>Add explicit invalidation on command success or domain events.</li> </ol> <p>Success signals</p> <ul> <li>Cache hit ratio increases without stale data incidents.</li> <li>P95 latency improves for the cached queries.</li> <li>Cache keys are predictable and easily traced in logs.</li> </ul> <p>Risks and mitigations</p> <ul> <li>Stale data: use short TTLs and explicit invalidation.</li> <li>Cache stampede: enable locking and jitter (default).</li> <li>Oversized payloads: set <code>MaxEntrySizeBytes</code> and size hints.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#playbook-saas-multitenancy-for-http-apis","title":"Playbook: SaaS multitenancy for HTTP APIs","text":"<p>Goal: resolve tenant context for every request, enforce it in handlers, and isolate data.</p> <p>Steps</p> <ol> <li>Decide resolution sources (route, header, host, or claim).</li> <li>Add multitenancy core and the ASP.NET Core adapter.</li> <li>Configure <code>MultitenancyOptions</code> (resolution order, headers, route name).</li> <li>Add <code>AddCleanArchitectureMultitenancyPipeline</code> and mark endpoints as required.</li> <li>Implement <code>ITenantInfoStore</code> and enable validation to prevent spoofing.</li> <li>(Optional) Add EF Core isolation and enable SaveChanges enforcement.</li> </ol> <p>Success signals</p> <ul> <li>Requests without tenant identifiers fail fast with clear errors.</li> <li>Tenant ID shows up in logs and traces.</li> <li>Data reads and writes are isolated by tenant.</li> </ul> <p>Risks and mitigations</p> <ul> <li>Claim-based resolution requires authentication to run first; place middleware accordingly.</li> <li>Missing tenant store when validation is enabled will cause enforcement failures; register it early.</li> <li>In database-per-tenant mode, ensure connection strings are resolvable for all tenants.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#playbook-event-driven-invalidation-advanced","title":"Playbook: event-driven invalidation (advanced)","text":"<p>Goal: keep caches in sync when data changes across services.</p> <p>Steps</p> <ol> <li>Define events for data mutations (commands and integration events).</li> <li>Invalidate cache keys from event handlers (or a small adapter service).</li> <li>Keep cache key conventions consistent to avoid global invalidation.</li> </ol> <p>Success signals</p> <ul> <li>Cache invalidations are targeted and low-latency.</li> <li>Cache and database values stay aligned under load tests.</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide shows how to reference the extensions from the default Jason Taylor Clean Architecture template layout.</p>"},{"location":"getting-started/installation/#choose-packages","title":"Choose packages","text":"Package Typical projects Purpose <code>CleanArchitecture.Extensions.Caching</code> Application + Infrastructure Cache abstractions, adapters, and query caching behavior. <code>CleanArchitecture.Extensions.Multitenancy</code> Application + Infrastructure Core multitenancy abstractions, resolution, and pipeline behaviors. <code>CleanArchitecture.Extensions.Multitenancy.AspNetCore</code> Web/API Middleware and endpoint enforcement for HTTP. <code>CleanArchitecture.Extensions.Multitenancy.EFCore</code> Infrastructure EF Core filters, interceptors, and DbContext helpers."},{"location":"getting-started/installation/#install-packages","title":"Install packages","text":"<p>Caching:</p> <pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Caching\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Caching\n</code></pre> <p>Multitenancy core:</p> <pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Multitenancy\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy\n</code></pre> <p>ASP.NET Core adapter:</p> <pre><code>dotnet add src/Web/Web.csproj package CleanArchitecture.Extensions.Multitenancy.AspNetCore\n</code></pre> <p>EF Core adapter:</p> <pre><code>dotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy.EFCore\n</code></pre>"},{"location":"getting-started/installation/#register-services","title":"Register services","text":"<p>Each package provides an <code>AddCleanArchitecture...</code> extension method. For example:</p> <pre><code>builder.Services.AddCleanArchitectureCaching();\nbuilder.Services.AddCleanArchitectureMultitenancy();\nbuilder.Services.AddCleanArchitectureMultitenancyAspNetCore();\nbuilder.Services.AddCleanArchitectureMultitenancyEfCore();\n</code></pre> <p>Add pipeline behaviors in Application:</p> <pre><code>builder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCachingPipeline();\n    cfg.AddCleanArchitectureMultitenancyPipeline();\n});\n</code></pre>"},{"location":"getting-started/installation/#uninstall","title":"Uninstall","text":"<pre><code>dotnet remove src/Application/Application.csproj package CleanArchitecture.Extensions.Caching\ndotnet remove src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Caching\n</code></pre> <p>Adjust for the package(s) you installed.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Choose the path that matches your first use case. Each path is designed to be copy-paste friendly with minimal changes to the template.</p>"},{"location":"getting-started/quickstart/#option-1-add-caching-5-minutes","title":"Option 1: add caching (5 minutes)","text":""},{"location":"getting-started/quickstart/#1-install-packages","title":"1) Install packages","text":"<pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Caching\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"getting-started/quickstart/#2-register-caching-services-infrastructure","title":"2) Register caching services (Infrastructure)","text":"<pre><code>using CleanArchitecture.Extensions.Caching;\n\nbuilder.Services.AddCleanArchitectureCaching();\n</code></pre>"},{"location":"getting-started/quickstart/#3-add-the-mediatr-caching-behavior-application","title":"3) Add the MediatR caching behavior (Application)","text":"<pre><code>builder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCachingPipeline();\n});\n</code></pre>"},{"location":"getting-started/quickstart/#4-verify","title":"4) Verify","text":"<p>Run the same query twice and confirm the second request is served from cache (debug logs show cache hit/miss).</p>"},{"location":"getting-started/quickstart/#option-2-add-multitenancy-to-an-http-api-10-minutes","title":"Option 2: add multitenancy to an HTTP API (10 minutes)","text":""},{"location":"getting-started/quickstart/#1-install-packages_1","title":"1) Install packages","text":"<pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Multitenancy\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy\ndotnet add src/Web/Web.csproj package CleanArchitecture.Extensions.Multitenancy.AspNetCore\n</code></pre>"},{"location":"getting-started/quickstart/#2-register-services-and-middleware","title":"2) Register services and middleware","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore;\nusing CleanArchitecture.Extensions.Multitenancy.AspNetCore.Middleware;\n\nbuilder.Services.AddCleanArchitectureMultitenancyAspNetCore();\n\nvar app = builder.Build();\napp.UseCleanArchitectureMultitenancy();\n</code></pre>"},{"location":"getting-started/quickstart/#3-add-the-multitenancy-pipeline-behaviors","title":"3) Add the multitenancy pipeline behaviors","text":"<pre><code>builder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureMultitenancyPipeline();\n});\n</code></pre>"},{"location":"getting-started/quickstart/#4-mark-tenant-required-endpoints","title":"4) Mark tenant-required endpoints","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.AspNetCore.Routing;\n\napp.MapGroup(\"/tenants/{tenantId}\")\n    .AddTenantEnforcement()\n    .RequireTenant();\n</code></pre>"},{"location":"getting-started/quickstart/#optional-add-ef-core-isolation","title":"Optional: add EF Core isolation","text":"<pre><code>dotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy.EFCore\n</code></pre> <pre><code>using CleanArchitecture.Extensions.Multitenancy.EFCore;\nusing CleanArchitecture.Extensions.Multitenancy.EFCore.Options;\n\nbuilder.Services.AddCleanArchitectureMultitenancyEfCore(options =&gt;\n{\n    options.Mode = TenantIsolationMode.SharedDatabase;\n    options.TenantIdPropertyName = \"TenantId\";\n    options.UseShadowTenantId = true;\n});\n</code></pre> <p>Next steps: - Installation guide - Caching extension - Multitenancy core - Multitenancy.AspNetCore - Multitenancy.EFCore</p>"},{"location":"recipes/authentication/","title":"Recipe: Authentication","text":""},{"location":"recipes/authentication/#goal","title":"Goal","text":"<p>Wire authentication in a template-based solution while keeping extension integration clean.</p>"},{"location":"recipes/authentication/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Authentication strategy chosen (JWT, cookies, or Identity).</li> </ul>"},{"location":"recipes/authentication/#steps","title":"Steps","text":"<ol> <li>Configure authentication schemes in <code>Program.cs</code> (or equivalent).</li> <li>Add authorization policies for tenant-aware endpoints if needed.</li> <li>If multitenancy is enabled, ensure tenant resolution and authentication are ordered correctly:</li> <li>Use tenant resolution before authorization.</li> <li>If tenant resolution depends on claims, run authentication before tenant resolution.</li> </ol>"},{"location":"recipes/authentication/#verify","title":"Verify","text":"<ul> <li>Hitting a protected endpoint returns <code>200</code> with a valid token and <code>401</code> without one.</li> <li>Tenant-required endpoints return a tenant error when the tenant is missing.</li> </ul>"},{"location":"recipes/authentication/#pitfalls","title":"Pitfalls","text":"<ul> <li>Authentication runs after tenant resolution when claim-based resolution is enabled (claims will be empty).</li> <li>Mismatched schemes between API and client.</li> <li>Missing authorization policies on tenant-required endpoints.</li> </ul>"},{"location":"recipes/caching/","title":"Recipe: Caching","text":""},{"location":"recipes/caching/#goal","title":"Goal","text":"<p>Add query caching with clear key conventions and safe invalidation.</p>"},{"location":"recipes/caching/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Decide on cache store (memory for development or <code>IDistributedCache</code> in production).</li> </ul>"},{"location":"recipes/caching/#steps","title":"Steps","text":"<ol> <li>Add the caching package.</li> </ol> <pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Caching\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Caching\n</code></pre> <ol> <li>Register caching services and configure TTLs.</li> </ol> <pre><code>builder.Services.AddCleanArchitectureCaching(\n    options =&gt; { options.DefaultNamespace = \"MyApp\"; },\n    behaviorOptions =&gt;\n    {\n        behaviorOptions.DefaultTtl = TimeSpan.FromMinutes(5);\n        behaviorOptions.CacheNullValues = false;\n    });\n</code></pre> <ol> <li>Add the query caching pipeline behavior.</li> </ol> <pre><code>builder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCachingPipeline();\n});\n</code></pre> <ol> <li>Opt in queries to caching.</li> </ol> <pre><code>using CleanArchitecture.Extensions.Caching;\nusing CleanArchitecture.Extensions.Caching.Abstractions;\n\n[CacheableQuery]\npublic record GetOrdersQuery : IRequest&lt;OrdersVm&gt;;\n\n// or\npublic record GetUserQuery(int Id) : IRequest&lt;UserDto&gt;, ICacheableQuery;\n</code></pre> <ol> <li>Add invalidation for write operations (commands or domain events).</li> </ol> <pre><code>await cache.RemoveAsync(cacheScope.Create(\"GetOrdersQuery\", hash));\n</code></pre>"},{"location":"recipes/caching/#verify","title":"Verify","text":"<ul> <li>First call hits the data source; the second call hits cache.</li> <li>Different request parameters produce different cache keys.</li> </ul>"},{"location":"recipes/caching/#pitfalls","title":"Pitfalls","text":"<ul> <li>Cache stampede: keep locking enabled and set jitter.</li> <li>Tenant-aware caching: call <code>AddCleanArchitectureMultitenancyCaching</code> when multitenancy is enabled.</li> <li>Caching error responses: use <code>ResponseCachePredicate</code> to skip them.</li> </ul>"},{"location":"reference/aspnetcore-multitenancy-options/","title":"Reference: AspNetCore multitenancy options","text":"<p><code>AspNetCoreMultitenancyOptions</code> configures the HTTP adapter for multitenancy.</p>"},{"location":"reference/aspnetcore-multitenancy-options/#options","title":"Options","text":"Option Type Default Description <code>StoreTenantInHttpContextItems</code> <code>bool</code> <code>true</code> Stores the resolved tenant in <code>HttpContext.Items</code>. <code>HttpContextItemKey</code> <code>string</code> <code>CleanArchitecture.Extensions.Multitenancy.TenantContext</code> Key used to store tenant context in <code>HttpContext.Items</code>. <code>CorrelationIdHeaderName</code> <code>string?</code> <code>null</code> Header name used to override the correlation ID. <code>UseTraceIdentifierAsCorrelationId</code> <code>bool</code> <code>true</code> Uses <code>HttpContext.TraceIdentifier</code> when no header is supplied."},{"location":"reference/aspnetcore-multitenancy-options/#notes","title":"Notes","text":"<ul> <li>Correlation ID is resolved from <code>CorrelationIdHeaderName</code> when present; otherwise <code>TraceIdentifier</code> is used (if enabled).</li> <li>The resolved tenant context can be accessed via <code>HttpContextTenantExtensions.GetTenantContext()</code> when stored in items.</li> </ul>"},{"location":"reference/caching-options/","title":"Reference: Caching options","text":""},{"location":"reference/caching-options/#cachingoptions","title":"CachingOptions","text":"Option Type Default Description <code>Enabled</code> <code>bool</code> <code>true</code> Enables or disables caching globally. <code>DefaultNamespace</code> <code>string</code> <code>\"CleanArchitectureExtensions\"</code> Namespace applied to cache keys. <code>DefaultEntryOptions</code> <code>CacheEntryOptions</code> <code>CacheEntryOptions.Default</code> Default entry options when no overrides are provided. <code>StampedePolicy</code> <code>CacheStampedePolicy</code> <code>CacheStampedePolicy.Default</code> Locking and jitter defaults. <code>MaxEntrySizeBytes</code> <code>long?</code> <code>null</code> Maximum payload size in bytes. <code>PreferredSerializer</code> <code>string?</code> <code>null</code> Preferred serializer type name or content type when multiple serializers are registered."},{"location":"reference/caching-options/#querycachingbehavioroptions","title":"QueryCachingBehaviorOptions","text":"Option Type Default Description <code>CachePredicate</code> <code>Func&lt;object,bool&gt;</code> <code>ICacheableQuery</code> or <code>[CacheableQuery]</code> Determines cacheable requests. <code>ResourceNameSelector</code> <code>Func&lt;object,string&gt;?</code> <code>null</code> Custom resource name for cache keys. <code>HashFactory</code> <code>Func&lt;object,string&gt;?</code> <code>null</code> Custom hash for cache keys. <code>DefaultTtl</code> <code>TimeSpan?</code> <code>00:05:00</code> Default TTL for cached queries. <code>TtlByRequestType</code> <code>Dictionary&lt;Type,TimeSpan&gt;</code> empty Per-request TTL overrides. <code>CacheNullValues</code> <code>bool</code> <code>true</code> Cache null responses. <code>ResponseCachePredicate</code> <code>Func&lt;object,object?,bool&gt;?</code> <code>null</code> Decide whether a response should be cached."},{"location":"reference/caching-options/#cacheentryoptions","title":"CacheEntryOptions","text":"Option Type Default Description <code>AbsoluteExpirationRelativeToNow</code> <code>TimeSpan?</code> <code>null</code> Absolute expiration relative to now. <code>AbsoluteExpiration</code> <code>DateTimeOffset?</code> <code>null</code> Absolute expiration timestamp. <code>SlidingExpiration</code> <code>TimeSpan?</code> <code>null</code> Sliding expiration interval. <code>Priority</code> <code>CachePriority</code> <code>Normal</code> Eviction priority (when supported). <code>Size</code> <code>long?</code> <code>null</code> Size hint for providers that enforce size limits."},{"location":"reference/caching-options/#cachestampedepolicy","title":"CacheStampedePolicy","text":"Option Type Default Description <code>EnableLocking</code> <code>bool</code> <code>true</code> Enable per-key locking. <code>LockTimeout</code> <code>TimeSpan</code> <code>00:00:05</code> Max wait for a lock. <code>Jitter</code> <code>TimeSpan?</code> <code>00:00:00.050</code> Random jitter applied to expirations."},{"location":"reference/configuration/","title":"Configuration reference","text":"<p>This page explains how to configure extensions using the Options pattern.</p>"},{"location":"reference/configuration/#recommended-configuration-sections","title":"Recommended configuration sections","text":"Section Options type Notes <code>Extensions:Caching</code> <code>CachingOptions</code> Core caching defaults. <code>Extensions:Caching:QueryBehavior</code> <code>QueryCachingBehaviorOptions</code> Query caching behavior settings. <code>Extensions:Multitenancy</code> <code>MultitenancyOptions</code> Core multitenancy settings. <code>Extensions:Multitenancy:AspNetCore</code> <code>AspNetCoreMultitenancyOptions</code> ASP.NET Core adapter settings. <code>Extensions:Multitenancy:EFCore</code> <code>EfCoreMultitenancyOptions</code> EF Core adapter settings."},{"location":"reference/configuration/#example-configuration","title":"Example configuration","text":"<pre><code>{\n  \"Extensions\": {\n    \"Caching\": {\n      \"Enabled\": true,\n      \"DefaultNamespace\": \"MyApp\",\n      \"MaxEntrySizeBytes\": 262144,\n      \"QueryBehavior\": {\n        \"DefaultTtl\": \"00:05:00\",\n        \"CacheNullValues\": false\n      }\n    },\n    \"Multitenancy\": {\n      \"RequireTenantByDefault\": true,\n      \"HeaderNames\": [\"X-Tenant-ID\"],\n      \"RouteParameterName\": \"tenantId\",\n      \"ValidationMode\": \"Repository\",\n      \"AspNetCore\": {\n        \"CorrelationIdHeaderName\": \"X-Correlation-ID\",\n        \"StoreTenantInHttpContextItems\": true\n      },\n      \"EFCore\": {\n        \"Mode\": \"SharedDatabase\",\n        \"TenantIdPropertyName\": \"TenantId\",\n        \"UseShadowTenantId\": true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#bind-configuration-in-code","title":"Bind configuration in code","text":"<pre><code>builder.Services.Configure&lt;CachingOptions&gt;(\n    builder.Configuration.GetSection(\"Extensions:Caching\"));\n\nbuilder.Services.Configure&lt;QueryCachingBehaviorOptions&gt;(\n    builder.Configuration.GetSection(\"Extensions:Caching:QueryBehavior\"));\n\nbuilder.Services.Configure&lt;MultitenancyOptions&gt;(\n    builder.Configuration.GetSection(\"Extensions:Multitenancy\"));\n\nbuilder.Services.Configure&lt;AspNetCoreMultitenancyOptions&gt;(\n    builder.Configuration.GetSection(\"Extensions:Multitenancy:AspNetCore\"));\n\nbuilder.Services.Configure&lt;EfCoreMultitenancyOptions&gt;(\n    builder.Configuration.GetSection(\"Extensions:Multitenancy:EFCore\"));\n</code></pre>"},{"location":"reference/configuration/#options-that-must-be-set-in-code","title":"Options that must be set in code","text":"<p>Some options are delegates (for example, <code>HostTenantSelector</code>, <code>SchemaNameProvider</code>, <code>ConnectionStringProvider</code>). These cannot be bound from JSON and must be configured in code.</p>"},{"location":"reference/configuration/#see-also","title":"See also","text":"<ul> <li>Caching options</li> <li>Multitenancy options</li> <li>AspNetCore multitenancy options</li> <li>EF Core multitenancy options</li> </ul>"},{"location":"reference/efcore-multitenancy-options/","title":"Reference: EF Core multitenancy options","text":"<p><code>EfCoreMultitenancyOptions</code> configures tenant isolation for EF Core.</p>"},{"location":"reference/efcore-multitenancy-options/#options","title":"Options","text":"Option Type Default Description <code>Mode</code> <code>TenantIsolationMode</code> <code>SharedDatabase</code> Shared database, schema-per-tenant, or database-per-tenant. <code>TenantIdPropertyName</code> <code>string</code> <code>\"TenantId\"</code> Name of the tenant ID property. <code>UseShadowTenantId</code> <code>bool</code> <code>true</code> Adds a shadow tenant ID when missing. <code>EnableQueryFilters</code> <code>bool</code> <code>true</code> Enables tenant query filters. <code>EnableSaveChangesEnforcement</code> <code>bool</code> <code>true</code> Enables SaveChanges enforcement. <code>RequireTenantForWrites</code> <code>bool</code> <code>true</code> Requires tenant context for writes. <code>IncludeSchemaInModelCacheKey</code> <code>bool</code> <code>true</code> Includes schema in model cache key for schema-per-tenant mode. <code>DefaultSchema</code> <code>string?</code> <code>null</code> Default schema when no tenant is resolved. <code>SchemaNameFormat</code> <code>string</code> <code>\"tenant_{0}\"</code> Schema format string for schema-per-tenant. <code>SchemaNameProvider</code> <code>Func&lt;ITenantInfo?,string?&gt;?</code> <code>null</code> Custom schema resolver (set in code). <code>ConnectionStringFormat</code> <code>string?</code> <code>null</code> Connection string format for database-per-tenant. <code>ConnectionStringProvider</code> <code>Func&lt;ITenantInfo?,string?&gt;?</code> <code>null</code> Custom connection resolver (set in code). <code>GlobalEntityTypes</code> <code>ISet&lt;Type&gt;</code> empty Entity types excluded from tenant filtering. <code>GlobalEntityTypeNames</code> <code>ISet&lt;string&gt;</code> empty Entity type names excluded from tenant filtering."},{"location":"reference/efcore-multitenancy-options/#tenantisolationmode","title":"TenantIsolationMode","text":"<ul> <li><code>SharedDatabase</code>: row-level filtering within a shared database.</li> <li><code>SchemaPerTenant</code>: shared database with per-tenant schema.</li> <li><code>DatabasePerTenant</code>: dedicated database per tenant.</li> </ul>"},{"location":"reference/efcore-multitenancy-options/#notes","title":"Notes","text":"<ul> <li><code>SchemaNameProvider</code> and <code>ConnectionStringProvider</code> are delegates and must be set in code.</li> <li>For database-per-tenant, the DbContext factory sets the connection string per tenant and requires a relational provider.</li> </ul>"},{"location":"reference/multitenancy-options/","title":"Reference: Multitenancy options","text":"<p><code>MultitenancyOptions</code> configures tenant resolution, validation, and correlation.</p>"},{"location":"reference/multitenancy-options/#options","title":"Options","text":"Option Type Default Description <code>RequireTenantByDefault</code> <code>bool</code> <code>true</code> Require a tenant unless a request marks itself optional. <code>AllowAnonymous</code> <code>bool</code> <code>false</code> Allow tenant-less requests when optional. <code>FallbackTenant</code> <code>TenantInfo?</code> <code>null</code> Full fallback tenant model (set in code). <code>FallbackTenantId</code> <code>string?</code> <code>null</code> Fallback tenant ID when no tenant is resolved. <code>ResolutionOrder</code> <code>List&lt;TenantResolutionSource&gt;</code> Route, Host, Header, QueryString, Claim, Default Provider evaluation order. <code>HeaderNames</code> <code>string[]</code> <code>[\"X-Tenant-ID\"]</code> Header names inspected for tenant IDs. <code>ClaimType</code> <code>string</code> <code>\"tenant_id\"</code> Claim type for tenant ID. <code>RouteParameterName</code> <code>string</code> <code>\"tenantId\"</code> Route parameter name. <code>QueryParameterName</code> <code>string</code> <code>\"tenantId\"</code> Query parameter name. <code>ResolutionCacheTtl</code> <code>TimeSpan?</code> <code>00:05:00</code> TTL for tenant cache entries when validation uses a cache. <code>ResolutionTimeout</code> <code>TimeSpan?</code> <code>null</code> Timeout for the resolution pipeline. <code>ValidationMode</code> <code>TenantValidationMode</code> <code>None</code> Validation strategy. <code>RequireMatchAcrossSources</code> <code>bool</code> <code>false</code> Require a single unique tenant ID across all sources. <code>IncludeUnorderedProviders</code> <code>bool</code> <code>true</code> Evaluate providers not listed in <code>ResolutionOrder</code>. <code>AddTenantToLogScope</code> <code>bool</code> <code>true</code> Add tenant ID to log scopes. <code>LogScopeKey</code> <code>string</code> <code>\"tenant_id\"</code> Log scope key name. <code>AddTenantToActivity</code> <code>bool</code> <code>true</code> Add tenant ID to activity tags/baggage. <code>HostTenantSelector</code> <code>Func&lt;string,string?&gt;?</code> <code>null</code> Custom host-to-tenant selector (set in code)."},{"location":"reference/multitenancy-options/#tenantvalidationmode","title":"TenantValidationMode","text":"<ul> <li><code>None</code>: no validation; tenant is assumed active.</li> <li><code>Cache</code>: validate using <code>ITenantInfoCache</code> only.</li> <li><code>Repository</code>: validate using <code>ITenantInfoStore</code> and optionally cache results.</li> </ul>"},{"location":"reference/multitenancy-options/#tenantresolutionsource","title":"TenantResolutionSource","text":"<p>Values include <code>Route</code>, <code>Host</code>, <code>Header</code>, <code>QueryString</code>, <code>Claim</code>, <code>Default</code>, <code>Custom</code>, and <code>Composite</code>.</p>"},{"location":"reference/multitenancy-options/#example-configuration","title":"Example configuration","text":"<pre><code>builder.Services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.RequireTenantByDefault = true;\n    options.AllowAnonymous = false;\n    options.ValidationMode = TenantValidationMode.Repository;\n    options.ResolutionCacheTtl = TimeSpan.FromMinutes(5);\n    options.ResolutionOrder = new List&lt;TenantResolutionSource&gt;\n    {\n        TenantResolutionSource.Route,\n        TenantResolutionSource.Host,\n        TenantResolutionSource.Header,\n        TenantResolutionSource.QueryString,\n        TenantResolutionSource.Claim,\n        TenantResolutionSource.Default\n    };\n});\n</code></pre>"},{"location":"release-notes/","title":"Release notes","text":"<p>Changelog for CleanArchitecture.Extensions (latest-only for now).</p>"},{"location":"release-notes/#unreleased","title":"Unreleased","text":"<ul> <li>No public releases yet.</li> </ul>"},{"location":"release-notes/#release-checklist","title":"Release checklist","text":"<ul> <li>Package metadata validated (<code>README</code>, license, icon, SourceLink, symbols).</li> <li>Docs updated for all shipped packages (install, config, quickstart).</li> <li>CI green (unit tests + EF Core behavior tests).</li> <li>Sample integration against the template works without forked changes.</li> <li>Breaking changes documented with migration guidance.</li> <li>Security and behavior caveats documented (caching, tenant enforcement, isolation).</li> </ul>"},{"location":"roadmap/package-blueprints/","title":"Package blueprints","text":"<p>This page summarizes the intent for each package and links to the detailed extension docs.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionscaching-shipped","title":"CleanArchitecture.Extensions.Caching (shipped)","text":"<p>Purpose</p> <ul> <li>Cache abstractions with memory and distributed adapters.</li> <li>Query caching behavior for MediatR.</li> <li>Deterministic cache key conventions.</li> </ul> <p>Docs</p> <ul> <li>Caching extension</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancy-shipped","title":"CleanArchitecture.Extensions.Multitenancy (shipped)","text":"<p>Purpose</p> <ul> <li>Tenant model and current tenant abstraction.</li> <li>Resolution providers (header, route, host, claims, default).</li> <li>Validation hooks and enforcement behaviors.</li> </ul> <p>Docs</p> <ul> <li>Multitenancy core</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyaspnetcore-shipped","title":"CleanArchitecture.Extensions.Multitenancy.AspNetCore (shipped)","text":"<p>Purpose</p> <ul> <li>HTTP middleware for resolution.</li> <li>Minimal API and MVC enforcement filters.</li> <li>ProblemDetails mapping for tenant errors.</li> </ul> <p>Docs</p> <ul> <li>Multitenancy.AspNetCore</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyefcore-shipped","title":"CleanArchitecture.Extensions.Multitenancy.EFCore (shipped)","text":"<p>Purpose</p> <ul> <li>Query filters and SaveChanges enforcement.</li> <li>Schema-per-tenant and database-per-tenant helpers.</li> <li>Tenant-aware DbContext factory and migration runner.</li> </ul> <p>Docs</p> <ul> <li>Multitenancy.EFCore</li> </ul>"},{"location":"roadmap/package-blueprints/#planned-packages","title":"Planned packages","text":"<ul> <li>Multitenancy.Identity</li> <li>Multitenancy.Provisioning</li> <li>Multitenancy.Redis</li> <li>Multitenancy.Sharding</li> </ul>"},{"location":"samples/","title":"Samples","text":"<p>There are no runnable samples in the repository yet. The current guidance is:</p> <ul> <li>Use the extension pages for step-by-step setup.</li> <li>Review tests under <code>tests/</code> for realistic usage patterns.</li> </ul> <p>Planned samples:</p> <ul> <li>Query caching with explicit invalidation.</li> <li>Multitenancy resolution (header + route) with enforcement.</li> <li>EF Core shared-database isolation with tenant filters.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and fixes for the current extensions.</p> <ul> <li>Caching not working: verify the behavior is registered and the request matches the cache predicate.</li> <li>Tenant not resolved: confirm the resolution context is populated and provider order is correct.</li> <li>Tenant validation failures: ensure <code>ITenantInfoStore</code>/<code>ITenantInfoCache</code> is registered when validation is enabled.</li> <li>EF Core enforcement errors: confirm tenant context is available for writes.</li> </ul> <p>See also:</p> <ul> <li>Multitenancy troubleshooting</li> <li>Caching extension</li> <li>Multitenancy core</li> </ul>"},{"location":"troubleshooting/multitenancy/","title":"Troubleshooting: Multitenancy","text":"<p>Common multitenancy issues and fixes across core, ASP.NET Core, and EF Core adapters.</p>"},{"location":"troubleshooting/multitenancy/#tenantnotresolvedexception","title":"TenantNotResolvedException","text":"<p>Symptoms</p> <ul> <li>Requests fail with \"Tenant not resolved\" or 400 ProblemDetails.</li> </ul> <p>Fixes</p> <ul> <li>Ensure your host adapter populates <code>TenantResolutionContext</code> before handlers run.</li> <li>Verify <code>ResolutionOrder</code> includes the provider you expect (route/host/header/query/claim).</li> <li>Check that your route parameter name, header names, or claim type match the incoming request.</li> </ul>"},{"location":"troubleshooting/multitenancy/#tenantnotfoundexception","title":"TenantNotFoundException","text":"<p>Symptoms</p> <ul> <li>Requests fail even though a tenant ID is present.</li> </ul> <p>Fixes</p> <ul> <li>Register <code>ITenantInfoStore</code> when using <code>TenantValidationMode.Repository</code>.</li> <li>Register <code>ITenantInfoCache</code> when using <code>TenantValidationMode.Cache</code>.</li> <li>Ensure the tenant exists in the store and is marked active.</li> </ul>"},{"location":"troubleshooting/multitenancy/#ambiguous-tenant-candidates","title":"Ambiguous tenant candidates","text":"<p>Symptoms</p> <ul> <li>Tenant resolves as null even though IDs are present.</li> </ul> <p>Fixes</p> <ul> <li>Ensure headers/queries contain only a single tenant ID.</li> <li>Disable <code>RequireMatchAcrossSources</code> or ensure all sources agree on the same ID.</li> <li>Avoid sending multiple <code>X-Tenant-ID</code> values separated by commas or semicolons.</li> </ul>"},{"location":"troubleshooting/multitenancy/#host-based-resolution-returns-null","title":"Host-based resolution returns null","text":"<p>Symptoms</p> <ul> <li>Host provider does not resolve tenant for subdomains.</li> </ul> <p>Fixes</p> <ul> <li>Ensure requests include a subdomain (for example, <code>tenant.app.com</code>).</li> <li>Configure <code>HostTenantSelector</code> to support custom host patterns.</li> <li>Host provider ignores IP addresses and single-segment hosts.</li> </ul>"},{"location":"troubleshooting/multitenancy/#cache-scope-mismatch-warnings","title":"Cache scope mismatch warnings","text":"<p>Symptoms</p> <ul> <li>Logs show \"Cache scope tenant mismatch\".</li> </ul> <p>Fixes</p> <ul> <li>Call <code>AddCleanArchitectureMultitenancyCaching</code> after <code>AddCleanArchitectureCaching</code>.</li> <li>Ensure tenant resolution runs before caching behaviors.</li> </ul>"},{"location":"troubleshooting/multitenancy/#tenant-context-lost-in-background-jobs","title":"Tenant context lost in background jobs","text":"<p>Symptoms</p> <ul> <li>Background workers execute without tenant context.</li> </ul> <p>Fixes</p> <ul> <li>Serialize <code>TenantContext</code> with <code>ITenantContextSerializer</code> and restore it in the worker.</li> <li>Wrap work in <code>ITenantAccessor.BeginScope</code> to avoid AsyncLocal leakage.</li> </ul>"},{"location":"troubleshooting/multitenancy/#ef-core-tenantsavechangesinterceptor-errors","title":"EF Core: TenantSaveChangesInterceptor errors","text":"<p>Symptoms</p> <ul> <li>Writes throw <code>TenantNotResolvedException</code> or a tenant mismatch exception.</li> </ul> <p>Fixes</p> <ul> <li>Ensure tenant context is set before SaveChanges executes.</li> <li>Verify <code>TenantIdPropertyName</code> matches your model configuration.</li> <li>Confirm global entities are excluded with <code>IGlobalEntity</code> or <code>[GlobalEntity]</code>.</li> </ul>"},{"location":"troubleshooting/multitenancy/#ef-core-database-per-tenant-errors","title":"EF Core: database-per-tenant errors","text":"<p>Symptoms</p> <ul> <li><code>TenantDbContextFactory</code> throws \"Tenant connection string was not resolved\".</li> </ul> <p>Fixes</p> <ul> <li>Configure <code>ConnectionStringFormat</code> or register a custom <code>ITenantConnectionResolver</code>.</li> <li>Ensure the current tenant is resolved before creating a DbContext.</li> <li>Use a relational EF Core provider (database-per-tenant requires relational).</li> </ul>"}]}