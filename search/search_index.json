{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CleanArchitecture.Extensions","text":"<p>Extensions ecosystem inspired by Jason Taylor's Clean Architecture template, delivered as opt-in NuGet packages without touching the upstream template.</p> <ul> <li>Why: keep Jason's template pristine while offering opinionated, composable plugins.</li> <li>What you get: quickstarts, concepts, extension catalog, recipes, samples, reference, contributing guidance, release notes.</li> <li>How to use: pick your goal (getting started, add an extension, follow a recipe) and jump in.</li> </ul> <p>Reference style</p> <p>Keep JasonTaylorCleanArchitecture nearby to mirror his conventions and naming.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started</li> <li>Extensions Catalog</li> <li>Roadmap</li> <li>Contributing</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Early-stage view of where CleanArchitecture.Extensions is heading. Status tags keep us honest about what is shipping now versus what is queued or still being explored.</p>"},{"location":"roadmap/#status-legend","title":"Status legend","text":"<ul> <li>Now: active development and doc polish.</li> <li>Next: planned immediately after the current focus.</li> <li>Exploring: shaping scope and design; timeline not locked.</li> <li>Later: anchored idea, likely to follow once earlier phases land.</li> </ul>"},{"location":"roadmap/#current-focus","title":"Current focus","text":"<ul> <li>Harden the Core extension (guards, <code>Result</code>/<code>Error</code>, correlation/logging/performance behaviors) and add quickstart-style samples.</li> <li>Finish the Multitenancy Core outline: tenant resolution pipeline, tenant context propagation, and doc coverage that matches the Clean Architecture template.</li> </ul>"},{"location":"roadmap/#domains-and-extensions","title":"Domains and extensions","text":""},{"location":"roadmap/#foundations","title":"Foundations","text":"<ul> <li>Core \u2014 Guard clauses, rich <code>Result</code>/<code>Error</code> primitives, logging/time abstractions, and pipeline behaviors for correlation, logging, and performance. Status: Now. Focus: API polish, samples that mirror Jason Taylor's template, and logging adapter guidance.</li> </ul>"},{"location":"roadmap/#multitenancy","title":"Multitenancy","text":"<ul> <li>Multitenancy Core \u2014 Tenant resolution strategies (host/header/route/claims), tenant context, and middleware/pipeline hooks to enforce tenant scope. Status: Next. Focus: finalize the resolution pipeline, document data-access patterns, and validate with a starter sample.</li> <li>Tenant-aware caching helpers \u2014 Key conventions and pipeline behaviors layered on the caching extension to prevent cross-tenant leakage. Status: Exploring. Focus: design cache key builders that compose with tenant resolution.</li> </ul>"},{"location":"roadmap/#identity-access","title":"Identity &amp; Access","text":"<ul> <li>Authentication bridge \u2014 Opinionated integration with ASP.NET Core Identity/external IdPs that fits the Clean Architecture layers and Core pipeline behaviors. Status: Exploring. Focus: align with the Authentication recipe and ensure multi-tenant awareness.</li> <li>Authorization policies kit \u2014 Simple policy helpers/guards for role-, permission-, and tenant-based checks in the Application and Domain layers. Status: Exploring.</li> </ul>"},{"location":"roadmap/#data-caching","title":"Data &amp; Caching","text":"<ul> <li>Caching extension \u2014 Abstractions and behaviors for cache-first queries, invalidation helpers, and tenant-aware key builders. Status: Planning. Focus: lock the API surface, pick in-memory/distributed adapters, and wire it into the Caching recipe.</li> <li>Resilience helpers \u2014 Standardized retry/circuit-breaker wrappers for external calls with Core logging/correlation baked in. Status: Later. Focus: decide whether to ship as behaviors, decorators, or both.</li> </ul>"},{"location":"roadmap/#observability-operations","title":"Observability &amp; Operations","text":"<ul> <li>Logging adapters \u2014 Bind <code>IAppLogger</code>/<code>ILogContext</code> to Serilog/<code>ILogger</code> with correlation and performance scopes. Status: Exploring. Focus: document adapter patterns and provide a Serilog starter.</li> <li>Metrics and tracing hooks \u2014 Minimal instrumentation around pipeline behaviors and background jobs. Status: Later. Focus: choose baseline OpenTelemetry conventions and keep them opt-in.</li> </ul>"},{"location":"roadmap/#developer-experience","title":"Developer Experience","text":"<ul> <li>Samples and templates \u2014 End-to-end sample solutions that combine Core + Multitenancy + caching/auth recipes. Status: Next. Focus: publish a minimal sample first, then layer on multitenancy and caching variants.</li> <li>Documentation hygiene \u2014 Keep MkDocs navigation, quick links, and extension templates in sync with shipped packages. Status: Now. Focus: update extension pages as APIs settle and keep this roadmap current.</li> </ul>"},{"location":"concepts/architecture-fit/","title":"Architecture Fit","text":"<p>How extensions align with Jason Taylor's Clean Architecture template.</p> <ul> <li>Keep the template untouched: extensions plug in via packages, configuration, middleware/behaviors\u2014not by forking or editing the upstream template.</li> <li>Preserve boundaries: respect domain/application/infrastructure/UI separation and dependency direction.</li> <li>Prefer composition: use pipeline behaviors, decorators, filters, and adapters instead of modifying core layers.</li> <li>Match conventions: mirror naming, folder structure, and coding style from the reference <code>JasonTaylorCleanArchitecture</code> copy.</li> <li>Stay optional: every extension should be opt-in with clear defaults and minimal required configuration.</li> </ul>"},{"location":"concepts/composition/","title":"Composition &amp; Invariants","text":"<p>Principles for combining extensions safely.</p> <ul> <li>Isolation: each extension should have clear dependencies and avoid implicit cross-talk.</li> <li>Pipelines first: prefer mediatr behaviors, filters, and decorators to hook in cross-cutting concerns.</li> <li>Config clarity: document required settings, defaults, and compat matrices; fail fast on invalid configs.</li> <li>Observability: emit structured logs/events for extension lifecycle (init, errors, important decisions).</li> <li>Compatibility: declare supported .NET versions and CleanArchitecture template versions per extension page.</li> <li>Exit strategy: provide guidance for disabling/removing an extension cleanly.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Guidance for code and docs contributions.</p>"},{"location":"contributing/#principles","title":"Principles","text":"<ul> <li>Mirror Jason Taylor's Clean Architecture conventions.</li> <li>Keep extensions opt-in with minimal required config.</li> <li>Update docs when behavior changes.</li> </ul>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Fork/branch and make changes inside CleanArchitecture.Extensions/ solution.</li> <li>Add/adjust docs alongside code changes.</li> <li>Run tests relevant to the change (TBD as test suites grow).</li> <li>For docs: pip install -r docs/requirements.txt &amp;&amp; mkdocs serve for local preview.</li> </ol>"},{"location":"contributing/#style-docs","title":"Style (docs)","text":"<ul> <li>Follow the templates in the documentation strategy.</li> <li>Keep snippets concise and prefer includes from source when possible.</li> </ul>"},{"location":"extensions/","title":"Extensions Catalog","text":"<p>Catalog of CleanArchitecture.Extensions packages. Each page follows the extension template (overview, when to use, compat, install, usage, troubleshooting, samples/tests).</p> <ul> <li>Start with Core (guards, results, logging, clocks, pipeline behaviors), then Multitenancy Core; add more pages as packages land.</li> <li>Keep compat tables up to date with template/.NET/package versions.</li> <li>Track upcoming packages and priorities in the Roadmap.</li> <li>Published pages: Core, Core Options, Core Time, Core Domain Events, Core Logging Abstractions, Core Pipeline Behaviors, Core Guard Clauses, Core Result Primitives, Validation, Multitenancy Core.</li> </ul>"},{"location":"extensions/core-domain-events/","title":"Core Domain Events","text":"<p>Domain events in Jason Taylor\u2019s Clean Architecture template are simple: <code>BaseEvent</code> is an empty <code>INotification</code>, <code>BaseEntity</code> holds a list of events, and an EF Core <code>DispatchDomainEventsInterceptor</code> publishes them via MediatR on <code>SaveChanges</code>. The Core extension adds richer metadata, a tracker, and an abstraction for dispatch so you can route events beyond EF, attach correlation IDs, and test event flows without EF or MediatR plumbing. This guide explains the template baseline, what Core adds, how to wire it, and real-world patterns for handlers, integration, and testing.</p>"},{"location":"extensions/core-domain-events/#what-the-template-already-covers","title":"What the template already covers","text":"<ul> <li>Types: <code>BaseEvent : INotification</code> (no properties) and <code>BaseEntity</code> keeps <code>List&lt;BaseEvent&gt; DomainEvents</code>.</li> <li>Dispatch: <code>DispatchDomainEventsInterceptor</code> (SaveChanges interceptor) drains <code>DomainEvents</code> from tracked entities and publishes each via <code>IMediator.Publish</code>.</li> <li>Usage: Entities call <code>AddDomainEvent(new TodoItemCreatedEvent(...))</code>. When EF <code>SaveChanges</code> runs, events are published in-process to notification handlers.</li> <li>Gaps: No correlation metadata, no timestamps, no tracking outside EF, and no abstraction to swap the dispatcher (e.g., to an outbox or message bus).</li> </ul>"},{"location":"extensions/core-domain-events/#what-core-adds","title":"What Core adds","text":"<ul> <li>Event base: <code>DomainEvent</code> (record, INotification) with <code>Id</code>, <code>OccurredOnUtc</code>, and optional <code>CorrelationId</code>.</li> <li>Tracking: <code>DomainEventTracker</code> to collect/clear events independent of EF change tracking; useful for aggregates not persisted via EF, or for outbox patterns.</li> <li>Dispatch abstraction: <code>IDomainEventDispatcher</code> defines <code>DispatchAsync(DomainEvent)</code> and <code>DispatchAsync(IEnumerable&lt;DomainEvent&gt;)</code>, letting Infrastructure choose how to publish (MediatR, bus, outbox).</li> <li>Correlation-first: Events can carry <code>CorrelationId</code> so you can tie logs, results, and integration messages together.</li> <li>Testability: In-memory tracker/dispatcher implementations make it easy to assert event emission without a database.</li> </ul>"},{"location":"extensions/core-domain-events/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.DomainEvents</code></p> <ul> <li><code>abstract record DomainEvent(string? correlationId = null)</code> : <code>Guid Id</code>, <code>DateTimeOffset OccurredOnUtc</code>, <code>string? CorrelationId</code>.</li> <li><code>DomainEventTracker</code> : <code>Add(DomainEvent)</code>, <code>HasEvents</code>, <code>Drain()</code>, <code>Clear()</code>, <code>Events</code> (read-only snapshot).</li> <li><code>IDomainEventDispatcher</code> : <code>DispatchAsync(DomainEvent, CancellationToken)</code>, <code>DispatchAsync(IEnumerable&lt;DomainEvent&gt;, CancellationToken)</code>.</li> </ul>"},{"location":"extensions/core-domain-events/#why-use-the-core-approach","title":"Why use the Core approach","text":"<ul> <li>Correlation: Attach <code>CorrelationId</code> from <code>ILogContext</code> or incoming HTTP headers so downstream handlers/logs share the same ID.</li> <li>Flexibility: Use the tracker in non-EF scenarios (Dapper, document DBs, in-memory aggregates) and dispatch via any mechanism (MediatR, message bus, outbox table).</li> <li>Testing: Assert on tracker contents without spinning up EF. Fake dispatchers keep tests fast and deterministic.</li> <li>Consistency: Aligns with Core logging and Result primitives\u2014errors and events can share the same correlation token for observability.</li> </ul>"},{"location":"extensions/core-domain-events/#wiring-in-di-typical-setups","title":"Wiring in DI (typical setups)","text":"<p>MediatR in-process dispatch: <pre><code>public sealed class MediatorDomainEventDispatcher : IDomainEventDispatcher\n{\n    private readonly IMediator _mediator;\n\n    public MediatorDomainEventDispatcher(IMediator mediator) =&gt; _mediator = mediator;\n\n    public Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct = default) =&gt;\n        _mediator.Publish(domainEvent, ct);\n\n    public async Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; domainEvents, CancellationToken ct = default)\n    {\n        foreach (var e in domainEvents)\n        {\n            await _mediator.Publish(e, ct);\n        }\n    }\n}\n</code></pre> Register: <pre><code>services.AddScoped&lt;IDomainEventDispatcher, MediatorDomainEventDispatcher&gt;();\nservices.AddScoped&lt;DomainEventTracker&gt;(); // per request/unit-of-work\n</code></pre></p> <p>EF Core dispatch using tracker: <pre><code>public sealed class TrackingDispatchInterceptor : SaveChangesInterceptor\n{\n    private readonly DomainEventTracker _tracker;\n    private readonly IDomainEventDispatcher _dispatcher;\n\n    public TrackingDispatchInterceptor(DomainEventTracker tracker, IDomainEventDispatcher dispatcher)\n    {\n        _tracker = tracker;\n        _dispatcher = dispatcher;\n    }\n\n    public override InterceptionResult&lt;int&gt; SavingChanges(DbContextEventData eventData, InterceptionResult&lt;int&gt; result)\n    {\n        CaptureEvents(eventData.Context);\n        return base.SavingChanges(eventData, result);\n    }\n\n    public override async ValueTask&lt;InterceptionResult&lt;int&gt;&gt; SavingChangesAsync(DbContextEventData eventData, InterceptionResult&lt;int&gt; result, CancellationToken ct = default)\n    {\n        CaptureEvents(eventData.Context);\n        await _dispatcher.DispatchAsync(_tracker.Drain(), ct);\n        return await base.SavingChangesAsync(eventData, result, ct);\n    }\n\n    private void CaptureEvents(DbContext? context)\n    {\n        if (context == null) return;\n        var entities = context.ChangeTracker.Entries&lt;HasDomainEvents&gt;()\n            .Where(e =&gt; e.Entity.DomainEvents.Any())\n            .Select(e =&gt; e.Entity);\n\n        foreach (var entity in entities)\n        {\n            foreach (var e in entity.DomainEvents)\n            {\n                _tracker.Add(e);\n            }\n            entity.ClearDomainEvents();\n        }\n    }\n}\n</code></pre> (Example assumes <code>HasDomainEvents</code> is a common interface/base similar to <code>BaseEntity</code>.)</p>"},{"location":"extensions/core-domain-events/#sample-backed-walkthrough-domain-events-sample","title":"Sample-backed walkthrough (domain events sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample</code>.</p>"},{"location":"extensions/core-domain-events/#tracker-dispatcher-with-correlation","title":"Tracker + dispatcher with correlation","text":"<p><code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample/src/Infrastructure/Data/Interceptors/DispatchDomainEventsInterceptor.cs</code>: <pre><code>var correlationId = EnsureCorrelationId();\nvar correlatedEvents = _tracker\n    .Drain()\n    .Select(domainEvent =&gt; EnsureCorrelation(domainEvent, correlationId))\n    .ToArray();\n\nawait _dispatcher.DispatchAsync(correlatedEvents, cancellationToken);\n</code></pre> - Domain events raised in aggregates are captured by <code>DomainEventTracker</code>, correlated (using <code>ILogContext</code> or the options factory), and dispatched through the <code>IDomainEventDispatcher</code>. - Events without a correlation ID are cloned via record <code>with</code> expressions so handlers/logs see the request-scoped identifier.</p>"},{"location":"extensions/core-domain-events/#recording-dispatched-events-for-diagnostics","title":"Recording dispatched events for diagnostics","text":"<p><code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample/src/Application/Diagnostics/Queries/GetRecentDomainEvents/GetRecentDomainEventsQuery.cs</code>: <pre><code>public sealed record GetRecentDomainEventsQuery(int Count = 20) : IRequest&lt;IReadOnlyCollection&lt;DomainEventLogEntry&gt;&gt;;\n\npublic Task&lt;IReadOnlyCollection&lt;DomainEventLogEntry&gt;&gt; Handle(GetRecentDomainEventsQuery request, CancellationToken cancellationToken)\n{\n    var take = Math.Clamp(request.Count, 1, 50);\n    var entries = _domainEventLog.ReadRecent(take);\n    return Task.FromResult(entries);\n}\n</code></pre> - The sample decorates the dispatcher with an in-memory <code>IDomainEventLog</code> and exposes recent events at <code>/api/DomainEvents/recent</code>.</p>"},{"location":"extensions/core-domain-events/#creating-events-with-request-correlation","title":"Creating events with request correlation","text":"<p><code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample/src/Application/TodoItems/Commands/CreateTodoItem/CreateTodoItem.cs</code>: <pre><code>var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n_logContext.CorrelationId = correlationId;\n\nentity.AddDomainEvent(new TodoItemCreatedEvent(entity, correlationId));\n</code></pre> - Correlation is set by middleware (or generated in the handler) and flows into domain events, making it easy to trace end-to-end alongside the recorded event log entries.</p>"},{"location":"extensions/core-domain-events/#real-world-scenarios","title":"Real-world scenarios","text":""},{"location":"extensions/core-domain-events/#1-correlation-aware-events-from-handlers","title":"1) Correlation-aware events from handlers","text":"<p><pre><code>public sealed class CreateOrderCommandHandler : IRequest&lt;Result&lt;Guid&gt;&gt;\n{\n    private readonly IOrderRepository _orders;\n    private readonly IDomainEventDispatcher _dispatcher;\n    private readonly ILogContext _logContext;\n\n    public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateOrderCommand request, CancellationToken ct)\n    {\n        var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n        var order = Order.Create(request.CustomerId, correlationId); // domain factory sets correlation on events\n\n        await _orders.AddAsync(order, ct);\n        await _dispatcher.DispatchAsync(order.DomainEvents, ct);\n        order.ClearDomainEvents();\n\n        return Result.Success(order.Id, correlationId);\n    }\n}\n</code></pre> - Events and Result share the same correlation ID, making logs and downstream handlers traceable.</p>"},{"location":"extensions/core-domain-events/#2-outbox-friendly-dispatch","title":"2) Outbox-friendly dispatch","text":"<p><pre><code>public sealed class OutboxDomainEventDispatcher : IDomainEventDispatcher\n{\n    private readonly IOutboxWriter _outbox;\n\n    public Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct = default) =&gt;\n        _outbox.AppendAsync(new OutboxMessage(domainEvent), ct);\n\n    public Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; domainEvents, CancellationToken ct = default) =&gt;\n        _outbox.AppendAsync(domainEvents.Select(e =&gt; new OutboxMessage(e)), ct);\n}\n</code></pre> - Swap dispatchers per environment: in-process for dev/tests; outbox for production.</p>"},{"location":"extensions/core-domain-events/#3-aggregating-events-outside-ef","title":"3) Aggregating events outside EF","text":"<p><pre><code>public sealed class InMemoryAggregateStore\n{\n    private readonly DomainEventTracker _tracker;\n\n    public InMemoryAggregateStore(DomainEventTracker tracker) =&gt; _tracker = tracker;\n\n    public void Save(AggregateRoot aggregate)\n    {\n        foreach (var e in aggregate.DomainEvents)\n        {\n            _tracker.Add(e);\n        }\n        aggregate.ClearDomainEvents();\n    }\n}\n</code></pre> - Later, call <code>_dispatcher.DispatchAsync(_tracker.Drain())</code> to publish.</p>"},{"location":"extensions/core-domain-events/#4-mapping-existing-template-events","title":"4) Mapping existing template events","text":"<p>If you have existing <code>BaseEvent</code> types from the template, wrap or replace them: <pre><code>public sealed record TodoItemCreatedEvent(Guid ItemId, string? CorrelationId = null) \n    : DomainEvent(CorrelationId);\n</code></pre> - You can keep handler code; MediatR sees it as <code>INotification</code> like before.</p>"},{"location":"extensions/core-domain-events/#5-logging-event-publication","title":"5) Logging event publication","text":"<p><pre><code>public sealed class LoggingDomainEventDispatcher : IDomainEventDispatcher\n{\n    private readonly IDomainEventDispatcher _inner;\n    private readonly IAppLogger&lt;LoggingDomainEventDispatcher&gt; _logger;\n    private readonly ILogContext _context;\n\n    public LoggingDomainEventDispatcher(IDomainEventDispatcher inner, IAppLogger&lt;LoggingDomainEventDispatcher&gt; logger, ILogContext context)\n    {\n        _inner = inner;\n        _logger = logger;\n        _context = context;\n    }\n\n    public async Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct = default)\n    {\n        _logger.Info(\"Dispatching domain event\", new Dictionary&lt;string, object?&gt;\n        {\n            [\"EventType\"] = domainEvent.GetType().Name,\n            [\"EventId\"] = domainEvent.Id,\n            [\"CorrelationId\"] = domainEvent.CorrelationId ?? _context.CorrelationId\n        });\n        await _inner.DispatchAsync(domainEvent, ct);\n    }\n\n    public async Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; domainEvents, CancellationToken ct = default)\n    {\n        foreach (var e in domainEvents)\n        {\n            await DispatchAsync(e, ct);\n        }\n    }\n}\n</code></pre> - Decorators let you log without changing handler or dispatcher implementations.</p>"},{"location":"extensions/core-domain-events/#patterns-and-guidance","title":"Patterns and guidance","text":"<ul> <li>Set correlation at creation time: Pass <code>ILogContext.CorrelationId</code> into domain event constructors in factories/handlers so it flows everywhere.</li> <li>Drain after dispatch: When using trackers, call <code>Drain()</code> to get a snapshot and clear them, mirroring the EF interceptor behavior.</li> <li>Avoid double dispatch: If you keep the template interceptor, ensure you\u2019re not also manually dispatching the same events. Choose one dispatch path per unit of work.</li> <li>Event ordering: <code>DomainEventTracker</code> preserves insertion order. If ordering matters across aggregates, consider sequencing or timestamp-based ordering in your dispatcher.</li> <li>Exception handling: Decide whether dispatcher exceptions should fail the transaction (typical) or be retried via outbox. The abstraction lets you choose.</li> <li>Background jobs: When handling commands in background workers, you can still use the same behaviors; ensure a correlation ID is set (middleware or behavior).</li> </ul>"},{"location":"extensions/core-domain-events/#testing-domain-events","title":"Testing domain events","text":"<p>Using the tracker + mediator dispatcher: <pre><code>[Fact]\npublic async Task DispatchAsync_Publishes_All_Tracked_Events()\n{\n    var tracker = new DomainEventTracker();\n    var published = new List&lt;DomainEvent&gt;();\n    var dispatcher = new StubDispatcher(published);\n    tracker.Add(new TestEvent(\"corr-1\"));\n    tracker.Add(new TestEvent(\"corr-1\"));\n\n    await dispatcher.DispatchAsync(tracker.Drain());\n\n    published.Should().HaveCount(2);\n    published.All(e =&gt; e.CorrelationId == \"corr-1\").Should().BeTrue();\n}\n\nfile sealed class TestEvent(string? CorrelationId = null) : DomainEvent(CorrelationId);\nfile sealed class StubDispatcher(List&lt;DomainEvent&gt; published) : IDomainEventDispatcher\n{\n    public Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct = default)\n    {\n        published.Add(domainEvent);\n        return Task.CompletedTask;\n    }\n\n    public Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; domainEvents, CancellationToken ct = default)\n    {\n        published.AddRange(domainEvents);\n        return Task.CompletedTask;\n    }\n}\n</code></pre></p>"},{"location":"extensions/core-domain-events/#integration-with-results-and-logging","title":"Integration with Results and logging","text":"<ul> <li>Use the same correlation ID across Results, logs, and events:</li> <li><code>var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");</code></li> <li>Pass to domain events: <code>new OrderSubmittedEvent(orderId, correlationId)</code>.</li> <li>Return <code>Result.Success(orderId, correlationId)</code>.</li> <li>Logging adapters can add <code>CorrelationId</code> to scopes; event dispatchers can log using the same ID, making troubleshooting and tracing straightforward.</li> </ul>"},{"location":"extensions/core-domain-events/#migration-from-template","title":"Migration from template","text":"<ul> <li>Replace <code>BaseEvent</code> with Core <code>DomainEvent</code> to get correlation and timestamps. Existing handlers still work because it\u2019s an <code>INotification</code>.</li> <li>Optionally replace <code>DispatchDomainEventsInterceptor</code> with a version that uses <code>DomainEventTracker</code> + <code>IDomainEventDispatcher</code> if you need more control (outbox, bus).</li> <li>Keep <code>BaseEntity</code> domain event list concept; ensure your entities expose/clear events just like the template.</li> <li>You can mix old and new event types during migration; MediatR can handle both.</li> </ul>"},{"location":"extensions/core-domain-events/#faq","title":"FAQ","text":"<ul> <li>Do I need a tracker if I use EF interceptor? Not strictly. The interceptor can dispatch directly. Use the tracker when you want to buffer events, inspect them, or reuse in non-EF contexts.</li> <li>Can I publish to a message bus? Yes\u2014implement <code>IDomainEventDispatcher</code> to translate events to bus messages. Use correlation IDs for tracing across services.</li> <li>Should events carry state or IDs? Prefer IDs and minimal snapshots. Use handlers to load additional data if needed. Keep payloads lean to avoid duplication and staleness.</li> <li>How do I avoid duplicate publishes? Ensure each event is cleared after dispatch. When using outbox, let the outbox process ensure exactly-once semantics for external delivery.</li> <li>What about transactions? For in-process MediatR handlers, dispatch before commit to keep consistency, or use outbox to decouple. The abstraction lets you choose per use case.</li> </ul>"},{"location":"extensions/core-domain-events/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Introduce <code>DomainEvent</code> for new events; add <code>CorrelationId</code> when available from <code>ILogContext</code>. 2) Register <code>IDomainEventDispatcher</code> (mediator, outbox, or bus) and optionally <code>DomainEventTracker</code>. 3) If using EF, wire an interceptor (or replace the template interceptor) that collects events and dispatches via the dispatcher. 4) Standardize event naming and payloads; keep them immutable and small. 5) Update tests to assert on <code>DomainEventTracker</code> contents or dispatcher invocations. 6) Log dispatches (via decorator) if you need observability of event publication paths.</p>"},{"location":"extensions/core-domain-events/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for correlation/logging that feeds correlation IDs into events.</li> <li>Core logging abstractions for scopes/adapters used by dispatchers.</li> <li>Core result primitives to align correlation IDs across results and events.</li> <li>Core guard clauses for input validation that may precede event emission.</li> <li>Core extension overview for the package-level summary and registration guidance.</li> </ul>"},{"location":"extensions/core-guard-clauses/","title":"Core Guard Clauses","text":"<p>Guard clauses in the Core extension give you a consistent, testable way to enforce invariants without scattering <code>if/throw</code> statements across handlers and entities. They pair with the extension\u2019s <code>Result</code> primitives so you can choose return-based validation (preferred for application flows) or exception-based validation (when you rely on middleware). This page explains how the Clean Architecture template handles validation today, why the extension adds more flexible guards, and how to integrate them with pipelines, Results, and domain logic.</p>"},{"location":"extensions/core-guard-clauses/#what-the-template-already-covers","title":"What the template already covers","text":"<p>Jason Taylor\u2019s template leans on two mechanisms:</p> <ul> <li>FluentValidation + MediatR ValidationBehaviour: Validators throw <code>ValidationException</code> when rules fail. Controllers/middleware translate those exceptions into ProblemDetails responses.</li> <li>Ad hoc checks: Handlers and services sometimes do simple <code>if (string.IsNullOrWhiteSpace(...)) throw ...;</code> for quick guards. There is no common error shape or trace propagation.</li> <li>Result type is minimal: The template\u2019s <code>Result</code> is <code>Succeeded + string[] Errors</code> and is mainly used in Identity flows; it does not pair with guard outcomes elsewhere.</li> </ul> <p>This works for demos but makes it harder to:</p> <ul> <li>Return structured errors without throwing.</li> <li>Accumulate multiple guard failures for richer UX.</li> <li>Keep correlation/trace IDs attached to validation failures.</li> <li>Reuse guard logic in domain entities without bringing FluentValidation into the domain layer.</li> </ul>"},{"location":"extensions/core-guard-clauses/#why-use-core-guard-clauses","title":"Why use Core guard clauses","text":"<p>The Core package introduces a focused guard library that aligns with the template\u2019s MediatR wiring while keeping your domain/application code technology-agnostic:</p> <ul> <li>Strategy-driven: Choose per-call whether to return <code>Result</code> failures (<code>ReturnFailure</code>), throw (<code>Throw</code>), or accumulate errors (<code>Accumulate</code>) into a shared sink.</li> <li>Trace-friendly: Guards accept <code>GuardOptions.TraceId</code>; failures propagate trace IDs into <code>Error</code> instances, staying aligned with correlation behaviors.</li> <li>Result-native: Guards produce <code>Result&lt;T&gt;</code> (or <code>Result</code>) so you can compose with <code>Map/Bind/Combine</code> instead of relying on exceptions.</li> <li>Domain-ready: No FluentValidation dependency; the API is simple enough to use inside aggregates while keeping error metadata consistent with the application layer.</li> <li>Batch-aware: <code>Accumulate</code> lets you gather multiple failures (e.g., CSV import) and report them together.</li> </ul>"},{"location":"extensions/core-guard-clauses/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.Guards</code></p> <p>Guards:</p> <ul> <li><code>AgainstNull&lt;T&gt;(value, parameterName, options?)</code></li> <li><code>AgainstNullOrWhiteSpace(string?, parameterName, options?)</code></li> <li><code>AgainstOutOfRange&lt;T&gt;(value, min, max, parameterName, options?) where T : IComparable&lt;T&gt;</code></li> <li><code>AgainstUndefinedEnum&lt;TEnum&gt;(value, parameterName, options?) where TEnum : struct, Enum</code></li> <li><code>AgainstTooShort(string value, minLength, parameterName, options?)</code></li> <li><code>AgainstTooLong(string value, maxLength, parameterName, options?)</code></li> <li><code>Ensure(bool condition, code, message, options?)</code></li> </ul> <p>Support types:</p> <ul> <li><code>GuardOptions</code> (strategy, error sink, exception factory, trace ID; plus <code>FromOptions(CoreExtensionsOptions, errorSink?)</code>).</li> <li><code>GuardStrategy</code> (<code>ReturnFailure</code>, <code>Throw</code>, <code>Accumulate</code>).</li> </ul> <p>Outputs:</p> <ul> <li><code>Result&lt;T&gt;</code> or <code>Result</code> from the Core Result primitives, carrying <code>Error</code> objects with <code>Code</code>, <code>Message</code>, <code>TraceId</code>.</li> </ul>"},{"location":"extensions/core-guard-clauses/#strategy-modes-explained","title":"Strategy modes explained","text":"<ul> <li>ReturnFailure (default): Guards return <code>Result</code>/<code>Result&lt;T&gt;</code> failures. Handlers can short-circuit or combine errors. No exceptions are thrown.</li> <li>Throw: Guards throw immediately. If you prefer exception-driven flows (e.g., existing middleware for 400s), set <code>GuardOptions.Strategy = GuardStrategy.Throw</code> or configure <code>CoreExtensionsOptions.GuardStrategy</code>.</li> <li>Accumulate: Guard errors are added to an <code>ICollection&lt;Error&gt;</code> sink (provided via <code>GuardOptions.ErrorSink</code>), and a failure <code>Result</code> is returned. Use this for batch operations where you want to report all issues at once.</li> </ul> <p><code>ExceptionFactory</code> lets you shape exceptions when <code>Throw</code> is selected (e.g., custom domain exceptions).</p>"},{"location":"extensions/core-guard-clauses/#comparing-to-template-validation","title":"Comparing to template validation","text":"<ul> <li>FluentValidation Behaviour: Runs after <code>AuthorizationBehaviour</code> and before <code>PerformanceBehaviour</code>. Throws <code>ValidationException</code> on first validation failure batch.</li> <li>Core Guards: Can run inside the handler or domain entity. When configured to return failures, they avoid exceptions and keep control in the handler. You can still use FluentValidation for complex cross-field rules while using guards for fast, local checks.</li> <li>Blended approach: Use guards for early, cheap validations (null/length/range) and FluentValidation for business rules that benefit from rich tooling and localization. Both can coexist because guards do not change pipeline signatures.</li> </ul>"},{"location":"extensions/core-guard-clauses/#installation-refresher","title":"Installation refresher","text":"<p>If you have not yet installed the Core extension:</p> <pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Core\n</code></pre> <p>Register <code>CoreExtensionsOptions</code> in DI so guards can inherit defaults:</p> <pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(configuration.GetSection(\"Extensions:Core\"));\n</code></pre>"},{"location":"extensions/core-guard-clauses/#quick-start-examples-backed-by-the-guard-sample","title":"Quick-start examples (backed by the guard sample)","text":"<p>A runnable solution that demonstrates each strategy lives at <code>samples/CleanArchitecture.Extensions.Core.Guards.Sample</code>.</p>"},{"location":"extensions/core-guard-clauses/#short-circuit-on-first-failure-returnfailure","title":"Short-circuit on first failure (ReturnFailure)","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Guards.Sample/src/Application/Projects/Commands/CreateProject/CreateProject.cs</code>:</p> <pre><code>var traceId = Guid.NewGuid().ToString(\"N\");\nvar guardOptions = new CoreGuardOptions { TraceId = traceId };\n\nvar name = CoreGuard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name), guardOptions)\n    .Ensure(n =&gt; n.Length &lt;= MaxNameLength, new CoreResults.Error(\"projects.name.length\", $\"Name must be {MaxNameLength} characters or fewer.\", traceId));\n\nvar description = string.IsNullOrWhiteSpace(request.Description)\n    ? CoreResults.Result.Success&lt;string?&gt;(null, traceId)\n    : CoreGuard.AgainstTooLong(request.Description, MaxDescriptionLength, nameof(request.Description), guardOptions)\n        .Map(value =&gt; (string?)value.Trim(), traceId);\n\nvar budget = CoreGuard.Ensure(request.Budget &gt;= 0,\n    \"projects.budget.range\",\n    \"Budget cannot be negative.\",\n    guardOptions);\n\nvar validation = CoreResults.Result.Combine(name, description, budget);\nif (validation.IsFailure)\n{\n    return CoreResults.Result.Failure&lt;int&gt;(validation.Errors, traceId);\n}\n</code></pre> <ul> <li>Guards stay branch-light until all cheap checks run, then short-circuit with a single <code>Result.Combine</code> failure.</li> <li>The handler continues on success to check duplicates and persist, preserving the same <code>traceId</code>.</li> </ul>"},{"location":"extensions/core-guard-clauses/#accumulate-multiple-failures-batch-import","title":"Accumulate multiple failures (batch import)","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Guards.Sample/src/Application/Projects/Commands/ImportProjects/ImportProjects.cs</code>:</p> <pre><code>var sink = new List&lt;CoreResults.Error&gt;();\nvar guardOptions = new CoreGuardOptions\n{\n    Strategy = GuardStrategy.Accumulate,\n    ErrorSink = sink,\n    TraceId = traceId\n};\n\nfor (var index = 0; index &lt; incoming.Count; index++)\n{\n    var project = incoming[index];\n    var beforeCount = sink.Count;\n\n    var nameResult = CoreGuard.AgainstNullOrWhiteSpace(project.Name, nameof(project.Name), guardOptions)\n        .Ensure(n =&gt; n.Length &lt;= MaxNameLength, new CoreResults.Error(\"projects.name.length\", $\"Name must be {MaxNameLength} characters or fewer.\", traceId));\n\n    var budgetResult = CoreGuard.Ensure(project.Budget &gt;= 0, \"projects.budget.range\", \"Budget cannot be negative.\", guardOptions);\n\n    if (nameResult.IsSuccess &amp;&amp; budgetResult.IsSuccess)\n    {\n        projects.Add(new Project(project.Name.Trim(), project.Description, project.Budget));\n    }\n    else\n    {\n        AddRowMetadata(sink, beforeCount, index + 1);\n    }\n}\n\nif (sink.Count &gt; 0)\n{\n    return CoreResults.Result.Failure&lt;IReadOnlyList&lt;int&gt;&gt;(sink, traceId);\n}\n</code></pre> <ul> <li><code>GuardStrategy.Accumulate</code> keeps looping and decorates new errors with a <code>row</code> metadata entry so the client can show all issues at once.</li> <li>Only when the sink is empty do we add the batch to the DbContext and save.</li> </ul>"},{"location":"extensions/core-guard-clauses/#throwing-for-exception-first-pipelines","title":"Throwing for exception-first pipelines","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Guards.Sample/src/Application/Projects/Commands/ArchiveProjectWithThrow/ArchiveProjectWithThrow.cs</code>:</p> <pre><code>var guardOptions = new CoreGuardOptions\n{\n    Strategy = GuardStrategy.Throw,\n    ExceptionFactory = error =&gt; new InvalidOperationException($\"{error.Code}: {error.Message}\")\n};\n\nvar project = await _context.Projects.FirstOrDefaultAsync(p =&gt; p.Id == request.Id, cancellationToken);\n\nCoreGuard.AgainstNull(project, nameof(project), guardOptions);\nCoreGuard.Ensure(!project!.IsArchived, \"projects.archived\", \"Project is already archived.\", guardOptions);\n\nproject.Archive(DateTimeOffset.UtcNow);\nawait _context.SaveChangesAsync(cancellationToken);\n</code></pre> <ul> <li>When <code>Throw</code> is chosen, guards raise exceptions immediately. In the sample API, the endpoint catches and translates them to a 400 response to demonstrate exception-first wiring.</li> </ul>"},{"location":"extensions/core-guard-clauses/#detailed-guard-behaviors","title":"Detailed guard behaviors","text":"<ul> <li>Trace propagation: When <code>TraceId</code> is set in options, every guard-generated error carries it. If omitted, the guard produces errors without a trace; you can still attach a trace later when turning guard results into handler results.</li> <li>Error codes: Each guard uses a stable code:</li> <li><code>guard.null</code></li> <li><code>guard.empty</code></li> <li><code>guard.range</code></li> <li><code>guard.enum</code></li> <li><code>guard.length</code></li> <li>custom code for <code>Ensure</code> (you pass it).     Use these codes for client-side localization or analytics.</li> <li>Messages: Default English messages are provided. If you need localization, wrap guards in a helper that maps codes to localized strings, or set <code>ExceptionFactory</code> to craft localized exceptions when throwing.</li> <li>Range check semantics: <code>AgainstOutOfRange</code> is inclusive (<code>minimum &lt;= value &lt;= maximum</code>). For exclusive checks, call it with adjusted bounds or add an <code>Ensure</code> with your own predicate.</li> <li>Enum checks: <code>AgainstUndefinedEnum</code> defends against undefined numeric casts or new values introduced without handler changes.</li> <li>Length checks: <code>AgainstTooShort</code> and <code>AgainstTooLong</code> operate on <code>string.Length</code>; for grapheme-aware length, add a custom guard using <code>Ensure</code>.</li> </ul>"},{"location":"extensions/core-guard-clauses/#composition-with-result-helpers","title":"Composition with Result helpers","text":"<p>Because guards return Results, you can compose them without <code>if</code> ladders:</p> <pre><code>public Result&lt;CheckoutRequest&gt; Validate(CheckoutRequest input, GuardOptions options)\n{\n    return Guard.AgainstNullOrWhiteSpace(input.CustomerId, \"CustomerId\", options)\n        .Bind(_ =&gt; Guard.AgainstOutOfRange(input.Items.Count, 1, 100, \"Items.Count\", options))\n        .Bind(_ =&gt; Guard.Ensure(input.Currency == \"USD\", \"checkout.currency\", \"Only USD supported\", options))\n        .Map(_ =&gt; input);\n}\n</code></pre> <ul> <li><code>Bind</code> short-circuits on first failure.</li> <li><code>Ensure</code> inserts custom predicate-based checks without new guard methods.</li> <li><code>Map</code> wraps the validated input back into the result, preserving the trace ID.</li> </ul>"},{"location":"extensions/core-guard-clauses/#using-guards-in-domain-entities","title":"Using guards in domain entities","text":"<p>Domain entities should not depend on FluentValidation. Guards give you lightweight checks while keeping errors structured:</p> <pre><code>public sealed class Money\n{\n    public string Currency { get; }\n    public decimal Amount { get; }\n\n    private Money(string currency, decimal amount)\n    {\n        Currency = currency;\n        Amount = amount;\n    }\n\n    public static Result&lt;Money&gt; Create(string currency, decimal amount, GuardOptions options)\n    {\n        return Guard.AgainstNullOrWhiteSpace(currency, nameof(currency), options)\n            .Bind(_ =&gt; Guard.AgainstOutOfRange(amount, 0m, 1_000_000m, nameof(amount), options))\n            .Map(_ =&gt; new Money(currency.Trim().ToUpperInvariant(), amount));\n    }\n}\n</code></pre> <ul> <li>The factory returns <code>Result&lt;Money&gt;</code>; handlers can propagate failures, aggregate them, or translate them into API responses without throwing.</li> </ul>"},{"location":"extensions/core-guard-clauses/#integrating-with-mediatr-pipelines","title":"Integrating with MediatR pipelines","text":"<ul> <li>Ordering: Use guards inside handlers before hitting infrastructure. If you prefer middleware-level handling, set strategy to <code>Throw</code> and let <code>UnhandledExceptionBehaviour</code> or your API middleware translate exceptions.</li> <li>Correlation: Run <code>CorrelationBehavior</code> early so <code>ILogContext.CorrelationId</code> is set. Pass that ID into <code>GuardOptions.TraceId</code> to keep guard errors aligned with logs.</li> <li>PerformanceBehavior: Guards are synchronous and cheap; they do not materially affect elapsed timing unless used in tight loops on large collections (batch validation). In those cases, consider aggregating and emitting a single performance log.</li> </ul>"},{"location":"extensions/core-guard-clauses/#working-with-fluentvalidation","title":"Working with FluentValidation","text":"<ul> <li>Complementary roles: Use guards for fast, mechanical checks (null/length/range) and FluentValidation for richer, cross-field rules or localized error messages.</li> <li>Avoid double work: If FluentValidation already covers a rule, do not duplicate it with guards unless you want early short-circuiting before expensive operations (e.g., DB calls).</li> <li>Shared error shape: You can map <code>ValidationFailure</code> to <code>Error</code> to stay consistent with guard outputs:</li> </ul> <pre><code>var errors = failures.Select(f =&gt;\n    new Error($\"validation.{f.PropertyName.ToLowerInvariant()}\", f.ErrorMessage, traceId));\nreturn Result.Failure&lt;TResponse&gt;(errors, traceId);\n</code></pre>"},{"location":"extensions/core-guard-clauses/#configuration-via-coreextensionsoptions","title":"Configuration via CoreExtensionsOptions","text":"<p><code>GuardOptions.FromOptions(CoreExtensionsOptions options, ICollection&lt;Error&gt;? errorSink = null)</code> lets you centralize defaults:</p> <ul> <li><code>GuardStrategy</code> (default <code>ReturnFailure</code>).</li> <li><code>TraceId</code> default.</li> <li>Injected <code>ErrorSink</code> when you want accumulation.   Set <code>Extensions:Core:GuardStrategy</code> in configuration to change the default behavior across the app, then override per call as needed.</li> </ul>"},{"location":"extensions/core-guard-clauses/#error-accumulation-patterns","title":"Error accumulation patterns","text":"<p>For scenarios where you must present all issues (e.g., admin bulk imports), combine <code>Accumulate</code> with <code>Result.Combine</code>:</p> <pre><code>var sink = new List&lt;Error&gt;();\nvar options = new GuardOptions { Strategy = GuardStrategy.Accumulate, ErrorSink = sink, TraceId = traceId };\n\nGuard.AgainstTooShort(user.FirstName, 2, \"FirstName\", options);\nGuard.AgainstTooShort(user.LastName, 2, \"LastName\", options);\nGuard.Ensure(user.Email.Contains('@'), \"user.email\", \"Email is invalid\", options);\n\nreturn sink.Count == 0\n    ? Result.Success(options.TraceId)\n    : Result.Failure(sink, options.TraceId);\n</code></pre> <ul> <li>You can still return a single <code>Result</code> to the caller while surfacing all errors.</li> </ul>"},{"location":"extensions/core-guard-clauses/#httpapi-translation","title":"HTTP/API translation","text":"<p>Pair guard-produced errors with ProblemDetails:</p> <pre><code>var result = await mediator.Send(command, ct);\nif (result.IsFailure)\n{\n    var problems = result.Errors.Select(e =&gt; new { e.Code, e.Message, e.TraceId, e.Metadata });\n    return Results.Problem(\n        title: \"Validation failed\",\n        statusCode: StatusCodes.Status400BadRequest,\n        detail: \"One or more validation errors occurred.\",\n        extensions: new Dictionary&lt;string, object?&gt;\n        {\n            [\"errors\"] = problems,\n            [\"traceId\"] = result.TraceId\n        });\n}\nreturn Results.Ok(new { result.Value, traceId = result.TraceId });\n</code></pre> <ul> <li>Clients get consistent codes/messages and a trace ID for troubleshooting.</li> </ul>"},{"location":"extensions/core-guard-clauses/#testing-guards","title":"Testing guards","text":"<ul> <li>Deterministic: Guards have no time dependency. You can assert on <code>IsSuccess</code>, <code>Errors.Count</code>, <code>Error.Code</code>, and <code>TraceId</code>.</li> <li>Example:</li> </ul> <pre><code>[Fact]\npublic void AgainstTooShort_ReturnsError_WhenBelowThreshold()\n{\n    var options = new GuardOptions { TraceId = \"unit-1\" };\n    var result = Guard.AgainstTooShort(\"ab\", 3, \"Name\", options);\n\n    result.IsFailure.Should().BeTrue();\n    result.Errors.Single().Code.Should().Be(\"guard.length\");\n    result.TraceId.Should().Be(\"unit-1\");\n}\n</code></pre> <ul> <li>Accumulate mode: Assert that the error sink contains all errors and that the returned <code>Result</code> is failure.</li> </ul>"},{"location":"extensions/core-guard-clauses/#performance-considerations","title":"Performance considerations","text":"<ul> <li>Guards are lightweight and allocation-friendly (simple Error structs, minimal collections). The main cost in accumulation mode is list growth; reuse sinks where appropriate for large batches.</li> <li>For high-frequency hot paths, prefer <code>ReturnFailure</code> to avoid exception costs. Reserve <code>Throw</code> for places where exceptions are part of your existing contract.</li> </ul>"},{"location":"extensions/core-guard-clauses/#extending-guards","title":"Extending guards","text":"<p>You can add custom guards alongside the built-ins by wrapping <code>Ensure</code>:</p> <pre><code>public static class GuardExtras\n{\n    public static Result&lt;T&gt; AgainstWeekend&lt;T&gt;(DateOnly date, string parameterName, GuardOptions? options = null)\n    {\n        var isWeekend = date.DayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday;\n        return Guard.Ensure(!isWeekend, $\"date.{parameterName}.weekend\", $\"{parameterName} cannot fall on a weekend.\", options)\n            .Map(_ =&gt; (T)(object)date); // or return Result.Success(date, options?.TraceId)\n    }\n}\n</code></pre> <p>Keep codes prefixed by the domain area to avoid collisions (<code>inventory.*</code>, <code>billing.*</code>, etc.).</p>"},{"location":"extensions/core-guard-clauses/#adoption-playbook","title":"Adoption playbook","text":"<ol> <li>Configure defaults: Set <code>Extensions:Core:GuardStrategy</code> to <code>ReturnFailure</code> (recommended). Enable a correlation-aware <code>TraceId</code> if you have one.</li> <li>Update new handlers: Use guards at the top of handlers to validate inputs, returning <code>Result&lt;T&gt;</code> on failure.</li> <li>Add accumulation for batch workflows: Introduce <code>Accumulate</code> + sinks where you previously looped over items with ad hoc validation.</li> <li>Bridge to existing exception flows: Where middleware expects exceptions, set strategy to <code>Throw</code> or wrap guard results in exceptions until you migrate clients.</li> <li>Refine codes/messages: Standardize error codes across teams. Document them near your domain services or in a shared constants file.</li> </ol>"},{"location":"extensions/core-guard-clauses/#reference-methods-and-codes","title":"Reference: Methods and codes","text":"<ul> <li><code>AgainstNull</code> \u2192 <code>guard.null</code></li> <li><code>AgainstNullOrWhiteSpace</code> \u2192 <code>guard.empty</code></li> <li><code>AgainstOutOfRange</code> \u2192 <code>guard.range</code></li> <li><code>AgainstUndefinedEnum</code> \u2192 <code>guard.enum</code></li> <li><code>AgainstTooShort</code> \u2192 <code>guard.length</code></li> <li><code>AgainstTooLong</code> \u2192 <code>guard.length</code></li> <li><code>Ensure</code> \u2192 user-supplied code</li> </ul>"},{"location":"extensions/core-guard-clauses/#related-docs","title":"Related docs","text":"<ul> <li>Core extension overview for pipeline behaviors, logging, time, domain events, and options.</li> <li>Core Result Primitives to see how guard outputs compose with results and downstream handlers.</li> <li>Validation extension when you need FluentValidation-driven behaviors in addition to guards.</li> </ul>"},{"location":"extensions/core-logging-abstractions/","title":"Core Logging Abstractions","text":"<p>Logging in Clean Architecture is intentionally minimal in Jason Taylor\u2019s template: it relies on <code>ILogger&lt;T&gt;</code> plus user/context services inside MediatR behaviors. The Core extension adds provider-agnostic logging and context abstractions so you can swap providers, capture correlation, and test without mocking concrete logging frameworks. This page explains the template baseline, what the Core abstractions add, how to wire them, and how to adapt them to providers like Microsoft.Extensions.Logging (MEL) or Serilog. It also shows how correlation and Results fit together so logs, errors, and responses share identifiers.</p>"},{"location":"extensions/core-logging-abstractions/#what-the-template-already-covers","title":"What the template already covers","text":"<ul> <li>Behaviors: <code>LoggingBehaviour&lt;TRequest&gt;</code> (pre-processor) uses <code>ILogger&lt;TRequest&gt;</code>, <code>IUser</code>, and <code>IIdentityService</code> to log the request name, user ID, and user name. <code>PerformanceBehaviour</code> uses <code>ILogger&lt;TRequest&gt;</code> with a <code>Stopwatch</code> to warn on slow requests (&gt;500 ms). <code>UnhandledExceptionBehaviour</code> logs exceptions with <code>ILogger&lt;TRequest&gt;</code>.</li> <li>Context: There is no dedicated log context abstraction. Correlation is not explicitly propagated; any correlation is left to ambient scopes set by the hosting pipeline.</li> <li>Result + errors: The template\u2019s <code>Result</code> has <code>Succeeded</code> and <code>string[] Errors</code>; logs do not attach trace IDs or structured error metadata.</li> <li>Time: Behaviors depend directly on <code>Stopwatch</code>/system time, not an abstraction.</li> </ul> <p>This setup is fine for demos, but teams often need: - Consistent correlation IDs across logs, results, and HTTP responses. - Provider-agnostic logging contracts so Application layer code and behaviors don\u2019t depend on MEL. - In-memory/no-op loggers for tests and quiet scenarios. - Structured properties without coupling to a specific logger\u2019s API.</p>"},{"location":"extensions/core-logging-abstractions/#what-the-core-logging-abstractions-add","title":"What the Core logging abstractions add","text":"<ul> <li>Interfaces, not providers: <code>IAppLogger&lt;T&gt;</code> mirrors common log levels but stays provider-neutral. <code>ILogContext</code> stores correlation ID and exposes <code>PushProperty</code> for scoped properties.</li> <li>Implementations for tests/quiet runs: <code>InMemoryAppLogger&lt;T&gt;</code> captures entries with correlation and properties; <code>NoOpAppLogger&lt;T&gt;</code> discards logs. <code>InMemoryLogContext</code> stores properties in-memory with scoped push/pop; <code>NoOpLogContext</code> is a no-op scope holder.</li> <li>Structured entries: <code>LogEntry</code> record captures <code>Timestamp</code>, <code>Level</code>, <code>Message</code>, <code>CorrelationId</code>, optional <code>Exception</code>, and optional <code>Properties</code>.</li> <li>Integration with behaviors: Core pipeline behaviors depend on these abstractions, letting you plug in your provider with a small adapter.</li> <li>Correlation-first: <code>ILogContext.CorrelationId</code> is the single place for correlation used by behaviors; you can set it from HTTP headers or allow <code>CorrelationBehavior</code> to generate it.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.Logging</code></p> <ul> <li><code>IAppLogger&lt;T&gt;</code> with <code>Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)</code> plus convenience methods <code>Trace/Debug/Info/Warn/Error/Critical</code>.</li> <li><code>ILogContext</code> with <code>string? CorrelationId { get; set; }</code> and <code>IDisposable PushProperty(string name, object? value)</code>.</li> <li>Implementations:</li> <li><code>InMemoryAppLogger&lt;T&gt;</code> (stores entries thread-safely).</li> <li><code>NoOpAppLogger&lt;T&gt;</code> (ignores logs).</li> <li><code>InMemoryLogContext</code> (stores correlation ID + properties; supports scoped push/pop).</li> <li><code>NoOpLogContext</code> (does nothing; safe stub).</li> <li>Supporting types:</li> <li><code>LogEntry</code> record (timestamp, level, message, correlation ID, exception, properties).</li> <li><code>LogLevel</code> enum (Trace, Debug, Information, Warning, Error, Critical, None).</li> </ul>"},{"location":"extensions/core-logging-abstractions/#why-this-matters-for-clean-architecture","title":"Why this matters for Clean Architecture","text":"<ul> <li>Layer isolation: Application layer doesn\u2019t depend on MEL/Serilog; Infrastructure can choose the provider and supply adapters. Tests run without heavy logging dependencies.</li> <li>Correlation consistency: Behaviors ensure correlation IDs reach logs; handlers can propagate the same ID into Results and domain events.</li> <li>Observability readiness: Structured properties enable search and analytics (e.g., request type, elapsed time, tenant) without forcing a specific logging library.</li> <li>Testability: In-memory logger/context make assertions straightforward in unit/integration tests.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#wiring-in-di","title":"Wiring in DI","text":"<p>Minimum registration to get logging working with Core behaviors: <pre><code>services.AddScoped&lt;ILogContext, InMemoryLogContext&gt;();              // replace with provider-specific context\nservices.AddScoped(typeof(IAppLogger&lt;&gt;), typeof(NoOpAppLogger&lt;&gt;));   // replace with adapter for your logger\nservices.AddSingleton&lt;IClock, SystemClock&gt;();                       // behaviors need a clock\n</code></pre> If you\u2019re using Core pipeline behaviors, ensure they\u2019re registered (see the Pipeline Behaviors doc). You can swap <code>NoOpAppLogger&lt;&gt;</code> with an adapter that bridges to MEL or Serilog.</p>"},{"location":"extensions/core-logging-abstractions/#adapting-to-microsoftextensionslogging-mel","title":"Adapting to Microsoft.Extensions.Logging (MEL)","text":"<p><pre><code>public sealed class MelAppLogger&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    private readonly ILogger&lt;T&gt; _logger;\n    private readonly ILogContext _context;\n\n    public MelAppLogger(ILogger&lt;T&gt; logger, ILogContext context)\n    {\n        _logger = logger;\n        _context = context;\n    }\n\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        using var scope = _logger.BeginScope(new Dictionary&lt;string, object?&gt;\n        {\n            [\"CorrelationId\"] = _context.CorrelationId\n        });\n\n        _logger.Log(Map(level), exception, message + \" {@props}\", properties);\n    }\n\n    private Microsoft.Extensions.Logging.LogLevel Map(LogLevel level) =&gt; level switch\n    {\n        LogLevel.Trace =&gt; Microsoft.Extensions.Logging.LogLevel.Trace,\n        LogLevel.Debug =&gt; Microsoft.Extensions.Logging.LogLevel.Debug,\n        LogLevel.Information =&gt; Microsoft.Extensions.Logging.LogLevel.Information,\n        LogLevel.Warning =&gt; Microsoft.Extensions.Logging.LogLevel.Warning,\n        LogLevel.Error =&gt; Microsoft.Extensions.Logging.LogLevel.Error,\n        LogLevel.Critical =&gt; Microsoft.Extensions.Logging.LogLevel.Critical,\n        _ =&gt; Microsoft.Extensions.Logging.LogLevel.None\n    };\n}\n</code></pre> Register it: <pre><code>services.AddScoped(typeof(IAppLogger&lt;&gt;), typeof(MelAppLogger&lt;&gt;));\nservices.AddScoped&lt;ILogContext, InMemoryLogContext&gt;(); // or your own scope wrapper\n</code></pre></p>"},{"location":"extensions/core-logging-abstractions/#adapting-to-serilog","title":"Adapting to Serilog","text":"<p><pre><code>public sealed class SerilogAppLogger&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    private readonly ILogger _logger; // Serilog.ILogger\n    private readonly ILogContext _context;\n\n    public SerilogAppLogger(ILogger logger, ILogContext context)\n    {\n        _logger = logger.ForContext(\"SourceContext\", typeof(T).FullName ?? typeof(T).Name);\n        _context = context;\n    }\n\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        var enriched = _logger.ForContext(\"CorrelationId\", _context.CorrelationId);\n        if (properties is { Count: &gt; 0 })\n        {\n            foreach (var kvp in properties)\n            {\n                enriched = enriched.ForContext(kvp.Key, kvp.Value, destructureObjects: true);\n            }\n        }\n\n        enriched.Write(Map(level), exception, message);\n    }\n\n    private Serilog.Events.LogEventLevel Map(LogLevel level) =&gt; level switch\n    {\n        LogLevel.Trace =&gt; Serilog.Events.LogEventLevel.Verbose,\n        LogLevel.Debug =&gt; Serilog.Events.LogEventLevel.Debug,\n        LogLevel.Information =&gt; Serilog.Events.LogEventLevel.Information,\n        LogLevel.Warning =&gt; Serilog.Events.LogEventLevel.Warning,\n        LogLevel.Error =&gt; Serilog.Events.LogEventLevel.Error,\n        LogLevel.Critical =&gt; Serilog.Events.LogEventLevel.Fatal,\n        _ =&gt; Serilog.Events.LogEventLevel.Information\n    };\n}\n</code></pre> Register with a Serilog-backed <code>ILogContext</code> (could wrap <code>LogContext.PushProperty</code> if desired).</p>"},{"location":"extensions/core-logging-abstractions/#sample-backed-walkthrough-logging-sample","title":"Sample-backed walkthrough (logging sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Logging.Sample</code>.</p>"},{"location":"extensions/core-logging-abstractions/#composite-logger-that-records-forwards-to-mel","title":"Composite logger that records + forwards to MEL","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Logging.Sample/src/Application/Common/Logging/CompositeAppLogger.cs</code>: <pre><code>public sealed class CompositeAppLogger&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        var correlationId = _logContext.CorrelationId;\n        using var correlationScope = _logger.BeginScope(new Dictionary&lt;string, object?&gt; { [\"CorrelationId\"] = correlationId });\n\n        IDisposable? propsScope = null;\n        if (properties is { Count: &gt; 0 })\n        {\n            propsScope = _logger.BeginScope(properties);\n        }\n\n        _logger.Log(MapLevel(level), exception, message);\n        propsScope?.Dispose();\n\n        _recorder.Record(new LogEntry(\n            DateTimeOffset.UtcNow,\n            level,\n            message,\n            correlationId,\n            exception,\n            properties));\n    }\n}\n</code></pre> - Logs flow to <code>ILogger&lt;T&gt;</code> scopes with correlation and are also stored in-memory via <code>ILogRecorder</code> for diagnostics.</p>"},{"location":"extensions/core-logging-abstractions/#correlation-middleware-diagnostics-endpoints","title":"Correlation middleware + diagnostics endpoints","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Logging.Sample/src/Web/Infrastructure/CorrelationMiddleware.cs</code> ensures every request has a correlation ID and pushes it into <code>ILogContext</code>.</p> <p><code>samples/CleanArchitecture.Extensions.Core.Logging.Sample/src/Application/Diagnostics/Commands/EmitLogPulse/EmitLogPulseCommand.cs</code> shows emitting structured logs with correlation and optional warning/error entries: <pre><code>var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n_logContext.CorrelationId = correlationId;\nusing var featureScope = _logContext.PushProperty(\"Feature\", \"LoggingSample\");\n\n_logger.Log(LogLevel.Information, $\"Received log pulse: {request.Message ?? \"(no message)\"}\", properties: properties);\n</code></pre> <code>GET /api/Diagnostics/logs</code> (see <code>.../Endpoints/Diagnostics.cs</code>) returns recent <code>LogEntry</code> items recorded by the in-memory recorder so you can see correlation + structured properties end-to-end.</p>"},{"location":"extensions/core-logging-abstractions/#correlation-flows","title":"Correlation flows","text":"<ul> <li><code>CorrelationBehavior</code> sets <code>ILogContext.CorrelationId</code> early in the pipeline.</li> <li><code>LoggingBehavior</code> uses <code>ILogContext</code> to push <code>CorrelationId</code> into scopes.</li> <li><code>PerformanceBehavior</code> includes <code>CorrelationId</code> in structured properties.</li> <li>Handlers can propagate <code>_logContext.CorrelationId</code> into <code>Result.TraceId</code> or <code>DomainEvent.CorrelationId</code>.</li> <li>HTTP middleware can set <code>ILogContext.CorrelationId</code> from <code>CoreExtensionsOptions.CorrelationHeaderName</code> and echo it back to clients.</li> </ul> <p>Example middleware: <pre><code>public class CorrelationMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogContext _context;\n    private readonly CoreExtensionsOptions _options;\n\n    public CorrelationMiddleware(RequestDelegate next, ILogContext context, IOptions&lt;CoreExtensionsOptions&gt; options)\n    {\n        _next = next;\n        _context = context;\n        _options = options.Value;\n    }\n\n    public async Task Invoke(HttpContext http)\n    {\n        var header = _options.CorrelationHeaderName;\n        var incoming = http.Request.Headers[header].FirstOrDefault();\n        _context.CorrelationId = string.IsNullOrWhiteSpace(incoming) ? _options.CorrelationIdFactory() : incoming;\n        using var scope = _context.PushProperty(\"CorrelationId\", _context.CorrelationId);\n        http.Response.Headers[header] = _context.CorrelationId!;\n        await _next(http);\n    }\n}\n</code></pre></p>"},{"location":"extensions/core-logging-abstractions/#using-inmemoryapplogger-in-tests","title":"Using InMemoryAppLogger in tests","text":"<p><pre><code>[Fact]\npublic async Task LoggingBehavior_WritesStartAndEnd_WithCorrelation()\n{\n    var clock = new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\"));\n    var context = new InMemoryLogContext { CorrelationId = \"corr-123\" };\n    var logger = new InMemoryAppLogger&lt;TestRequest&gt;(context);\n    var options = Microsoft.Extensions.Options.Options.Create(new CoreExtensionsOptions());\n    var behavior = new LoggingBehavior&lt;TestRequest, Unit&gt;(logger, context, clock, options);\n\n    await behavior.Handle(new TestRequest(), _ =&gt; Task.FromResult(Unit.Value), CancellationToken.None);\n\n    logger.Entries.Should().Contain(e =&gt; e.Message.Contains(\"Handling\") &amp;&amp; e.CorrelationId == \"corr-123\");\n    logger.Entries.Should().Contain(e =&gt; e.Message.Contains(\"Handled\") &amp;&amp; e.CorrelationId == \"corr-123\");\n}\n</code></pre> - <code>InMemoryAppLogger</code> captures correlation automatically from <code>ILogContext</code>.</p>"},{"location":"extensions/core-logging-abstractions/#handling-exceptions-and-errors","title":"Handling exceptions and errors","text":"<ul> <li>Behaviors don\u2019t automatically log exceptions; <code>UnhandledExceptionBehaviour</code> (template) still does that with <code>ILogger&lt;T&gt;</code>. You can adapt it to <code>IAppLogger&lt;T&gt;</code> or register a global exception middleware that logs via your adapter.</li> <li>You can log <code>Result</code> failures explicitly in handlers: <pre><code>if (result.IsFailure)\n{\n    _logger.Warn(\"Use case failed\", new Dictionary&lt;string, object?&gt;\n    {\n        [\"Errors\"] = result.Errors.Select(e =&gt; new { e.Code, e.Message, e.TraceId }),\n        [\"CorrelationId\"] = result.TraceId ?? _logContext.CorrelationId\n    });\n    return result;\n}\n</code></pre></li> </ul>"},{"location":"extensions/core-logging-abstractions/#properties-and-scopes","title":"Properties and scopes","text":"<ul> <li><code>ILogContext.PushProperty</code> returns an <code>IDisposable</code> scope; use <code>using</code> statements to ensure pop happens even on exceptions.</li> <li><code>InMemoryLogContext</code> keeps a dictionary of properties; it\u2019s primarily for tests/diagnostics. For production, adapt to your logger\u2019s native scope API (<code>BeginScope</code>, <code>LogContext.PushProperty</code>, etc.).</li> <li><code>NoOpLogContext</code> is safe for scenarios where you don\u2019t care about correlation or scopes (e.g., simple console apps).</li> </ul>"},{"location":"extensions/core-logging-abstractions/#configuration-touchpoints","title":"Configuration touchpoints","text":"<p>Logging abstractions themselves aren\u2019t configured via <code>CoreExtensionsOptions</code>, but they participate in options used by pipeline behaviors: - <code>CoreExtensionsOptions.CorrelationHeaderName</code> and <code>CorrelationIdFactory</code> affect correlation handling. - <code>CoreExtensionsOptions.EnablePerformanceLogging</code> and <code>PerformanceWarningThreshold</code> influence <code>PerformanceBehavior</code> logs. Set these in <code>appsettings</code> under <code>Extensions:Core</code>: <pre><code>{\n  \"Extensions\": {\n    \"Core\": {\n      \"CorrelationHeaderName\": \"X-Correlation-ID\",\n      \"EnablePerformanceLogging\": true,\n      \"PerformanceWarningThreshold\": \"00:00:00.500\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"extensions/core-logging-abstractions/#real-world-patterns","title":"Real-world patterns","text":""},{"location":"extensions/core-logging-abstractions/#enriching-logs-with-usertenant-without-coupling-handlers","title":"Enriching logs with user/tenant without coupling handlers","text":"<p><pre><code>public sealed class UserAwareLoggerAdapter&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    private readonly IAppLogger&lt;T&gt; _inner;\n    private readonly ICurrentUser _currentUser;\n\n    public UserAwareLoggerAdapter(IAppLogger&lt;T&gt; inner, ICurrentUser currentUser)\n    {\n        _inner = inner;\n        _currentUser = currentUser;\n    }\n\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        var enriched = new Dictionary&lt;string, object?&gt;(properties ?? new Dictionary&lt;string, object?&gt;())\n        {\n            [\"UserId\"] = _currentUser.Id,\n            [\"UserName\"] = _currentUser.UserName\n        };\n        _inner.Log(level, message, exception, enriched);\n    }\n}\n</code></pre> - Register <code>UserAwareLoggerAdapter&lt;T&gt;</code> as a decorator over your provider adapter.</p>"},{"location":"extensions/core-logging-abstractions/#logging-domain-events-with-correlation","title":"Logging domain events with correlation","text":"<p><pre><code>public sealed class DomainEventLoggingDispatcher : IDomainEventDispatcher\n{\n    private readonly IMediator _mediator;\n    private readonly IAppLogger&lt;DomainEventLoggingDispatcher&gt; _logger;\n    private readonly ILogContext _context;\n\n    public DomainEventLoggingDispatcher(IMediator mediator, IAppLogger&lt;DomainEventLoggingDispatcher&gt; logger, ILogContext context)\n    {\n        _mediator = mediator;\n        _logger = logger;\n        _context = context;\n    }\n\n    public async Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; events, CancellationToken cancellationToken = default)\n    {\n        foreach (var e in events)\n        {\n            _logger.Info(\"Publishing domain event\", new Dictionary&lt;string, object?&gt;\n            {\n                [\"EventType\"] = e.GetType().Name,\n                [\"CorrelationId\"] = e.CorrelationId ?? _context.CorrelationId\n            });\n            await _mediator.Publish(e, cancellationToken);\n        }\n    }\n}\n</code></pre> - Correlation flows from <code>ILogContext</code> to domain events, keeping observability aligned.</p>"},{"location":"extensions/core-logging-abstractions/#quiet-mode-for-tests-or-local-dev","title":"Quiet mode for tests or local dev","text":"<ul> <li>Use <code>NoOpAppLogger&lt;T&gt;</code> and <code>NoOpLogContext</code> to suppress logs entirely.</li> <li>Switch to <code>InMemoryAppLogger</code> when you want to assert on log emission without external sinks.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#migration-guidance-from-the-template","title":"Migration guidance from the template","text":"<ul> <li>Keep using MEL/Serilog in Infrastructure, but inject adapters for <code>IAppLogger&lt;T&gt;</code> and <code>ILogContext</code>.</li> <li>Replace usages of <code>ILogger&lt;T&gt;</code> in new behaviors with <code>IAppLogger&lt;T&gt;</code> to avoid leaking provider dependencies into Application layer. Existing behaviors from the template can stay until you swap them for Core equivalents.</li> <li>In controllers or middleware, if you rely on <code>ILogger</code>, you can still do so; <code>IAppLogger</code> is primarily for Application layer and behaviors.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#testing-tips","title":"Testing tips","text":"<ul> <li>With <code>InMemoryAppLogger</code>, assert:</li> <li><code>Entries.Count</code> for expected log count.</li> <li><code>Entries.Any(e =&gt; e.Level == LogLevel.Warning &amp;&amp; e.Message.Contains(\"Long running\"))</code>.</li> <li><code>CorrelationId</code> presence matches <code>ILogContext.CorrelationId</code>.</li> <li>Use <code>FrozenClock</code> to make time-based properties deterministic when your adapter adds timestamps.</li> <li>When testing correlation middleware + behaviors end-to-end, set <code>ILogContext.CorrelationId</code> in middleware and ensure behavior logs carry the same value.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#faq","title":"FAQ","text":"<ul> <li>Do I have to abandon <code>ILogger</code>? No. Use adapters so Application code stays on <code>IAppLogger</code>; Infrastructure can still be MEL/Serilog. Existing <code>ILogger</code> usages in Web/Infrastructure remain valid.</li> <li>Where should I store correlation ID? In <code>ILogContext.CorrelationId</code>. Set it from middleware or let <code>CorrelationBehavior</code> generate it. Adapters should read it when creating scopes.</li> <li>Can I add scopes besides correlation? Yes\u2014<code>PushProperty</code> is generic. Add tenant ID, user ID, feature flag states, etc. Ensure sensitive data policies are followed.</li> <li>What about OpenTelemetry? Bridge <code>CorrelationId</code> to trace/span IDs in your adapter or middleware. The Core abstractions avoid a hard dependency on OTEL packages.</li> <li>Do the abstractions log JSON automatically? No. Serialization is handled by your provider. Properties are provided as structured objects; your adapter decides how to render them.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Register <code>ILogContext</code> and <code>IAppLogger&lt;T&gt;</code> implementations (NoOp/InMemory or provider adapters). 2) Ensure <code>CorrelationBehavior</code> and <code>LoggingBehavior</code> are registered so correlation and lifecycle logs flow. 3) Add middleware (optional) to source correlation IDs from incoming requests. 4) Decorate your logger adapter if you need user/tenant enrichment. 5) For tests, swap <code>IAppLogger&lt;T&gt;</code> with <code>InMemoryAppLogger&lt;T&gt;</code> and assert on <code>LogEntry</code> data. 6) Gradually replace direct <code>ILogger</code> usage in new Application components with <code>IAppLogger</code> to keep the Application layer decoupled from provider specifics.</p>"},{"location":"extensions/core-logging-abstractions/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for correlation/logging/performance behaviors that consume these abstractions.</li> <li>Core result primitives to see how trace IDs in results/errors align with correlation IDs in logs.</li> <li>Core guard clauses for guards that emit errors you might log with correlation.</li> <li>Core extension overview for the big-picture view and registration guidance.</li> </ul>"},{"location":"extensions/core-options/","title":"Core Options","text":"<p>The Core extension exposes a single options class\u2014<code>CoreExtensionsOptions</code>\u2014to configure correlation, guard behavior, and performance logging. While Jason Taylor\u2019s Clean Architecture template wires MediatR behaviors without centralized options, the Core package adds a cohesive configuration surface so you can control cross-cutting behavior from appsettings or DI. This page explains the template baseline, what options exist, how they affect guards, logging, pipeline behaviors, and how to use them in different environments (dev, test, prod).</p>"},{"location":"extensions/core-options/#template-baseline","title":"Template baseline","text":"<ul> <li>Behaviors: Template MediatR behaviors (<code>LoggingBehaviour</code>, <code>AuthorizationBehaviour</code>, <code>ValidationBehaviour</code>, <code>PerformanceBehaviour</code>, <code>UnhandledExceptionBehaviour</code>) are hard-coded\u2014no central options for thresholds or correlation.</li> <li>Correlation: No explicit correlation header or ID factory; logging relies on <code>ILogger&lt;T&gt;</code> scopes populated with user info.</li> <li>Guards: Template doesn\u2019t ship guard options; validation uses FluentValidation with exception throwing.</li> </ul>"},{"location":"extensions/core-options/#what-core-configures","title":"What Core configures","text":"<p><code>CoreExtensionsOptions</code> lives in <code>CleanArchitecture.Extensions.Core.Options</code> and governs: - <code>CorrelationHeaderName</code> (string, default <code>\"X-Correlation-ID\"</code>) - <code>GuardStrategy</code> (enum, default <code>ReturnFailure</code>) - <code>EnablePerformanceLogging</code> (bool, default <code>true</code>) - <code>PerformanceWarningThreshold</code> (TimeSpan, default 500 ms) - <code>CorrelationIdFactory</code> (<code>Func&lt;string&gt;</code>, default GUID \u201cN\u201d) - <code>TraceId</code> (string?, default <code>null</code>)</p>"},{"location":"extensions/core-options/#how-options-are-used-across-core","title":"How options are used across Core","text":"<ul> <li>Correlation behaviors: <code>CorrelationBehavior</code> uses <code>CorrelationIdFactory</code> when <code>ILogContext.CorrelationId</code> is missing. Controllers/middleware can use <code>CorrelationHeaderName</code> to read/write headers.</li> <li>Logging behavior: Uses <code>CorrelationBehavior</code>-set IDs; if none are set, it can seed correlation via <code>IClock.NewGuid()</code>\u2014you can align that with <code>CorrelationIdFactory</code> for consistency.</li> <li>Performance behavior: Respects <code>EnablePerformanceLogging</code> and <code>PerformanceWarningThreshold</code> to toggle logging and control warnings vs. debug logs.</li> <li>Guards: <code>GuardOptions.FromOptions</code> maps <code>GuardStrategy</code> and <code>TraceId</code> into guard calls; you can supply an error sink for accumulation.</li> <li>Results: <code>TraceId</code> can be propagated to Result/Errors for consistent tracing between logs, domain events, and HTTP responses.</li> </ul>"},{"location":"extensions/core-options/#configuration-via-appsettings","title":"Configuration via appsettings","text":"<p><pre><code>{\n  \"Extensions\": {\n    \"Core\": {\n      \"CorrelationHeaderName\": \"X-Correlation-ID\",\n      \"GuardStrategy\": \"ReturnFailure\",\n      \"EnablePerformanceLogging\": true,\n      \"PerformanceWarningThreshold\": \"00:00:00.500\",\n      \"TraceId\": null\n    }\n  }\n}\n</code></pre> - Strings like <code>\"ReturnFailure\"</code> bind to <code>GuardStrategy</code>. - TimeSpan format is standard .NET (<code>hh:mm:ss.fff</code>). - <code>CorrelationIdFactory</code> cannot be bound via configuration; set it in code when registering options.</p>"},{"location":"extensions/core-options/#registering-options-in-di","title":"Registering options in DI","text":"<p><pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(configuration.GetSection(\"Extensions:Core\"));\n</code></pre> Override programmatically when needed: <pre><code>services.PostConfigure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.CorrelationIdFactory = () =&gt; $\"svc-{Guid.NewGuid():N}\";\n    options.PerformanceWarningThreshold = TimeSpan.FromMilliseconds(250);\n});\n</code></pre></p>"},{"location":"extensions/core-options/#sample-backed-walkthrough-options-sample","title":"Sample-backed walkthrough (options sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Options.Sample</code>.</p>"},{"location":"extensions/core-options/#inspect-current-options-at-runtime","title":"Inspect current options at runtime","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Options.Sample/src/Application/Diagnostics/Queries/GetCoreOptions/GetCoreOptionsQuery.cs</code>: <pre><code>var value = _options.Value;\nvar dto = new CoreOptionsDto(\n    value.CorrelationHeaderName,\n    value.GuardStrategy,\n    value.EnablePerformanceLogging,\n    value.PerformanceWarningThreshold);\n</code></pre> - Exposed via <code>GET /api/Diagnostics/options</code> to see the live values bound from <code>appsettings.json</code> (correlation header, guard strategy, performance threshold).</p>"},{"location":"extensions/core-options/#drive-guard-behavior-from-options","title":"Drive guard behavior from options","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Options.Sample/src/Application/Diagnostics/Commands/EvaluateName/EvaluateNameCommand.cs</code>: <pre><code>var guardOptions = GuardOptions.FromOptions(_options.Value);\n\nvar result = CoreGuard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name), guardOptions)\n    .Ensure(n =&gt; n.Length &lt;= 50, new Error(\"diagnostics.name.length\", \"Name must be 50 characters or fewer.\", guardOptions.TraceId));\n</code></pre> - <code>POST /api/Diagnostics/guard</code> returns a Core <code>Result&lt;string&gt;</code>; switch <code>GuardStrategy</code> in config between <code>ReturnFailure</code> and <code>Throw</code> to see the behavior change without code changes. - Appsettings in the sample set <code>PerformanceWarningThreshold</code> to 750 ms and <code>CorrelationHeaderName</code> to <code>\"X-Correlation-ID\"</code> to show how pipeline behaviors and middleware pick them up.</p>"},{"location":"extensions/core-options/#environment-specific-guidance","title":"Environment-specific guidance","text":"<ul> <li>Development: Keep <code>EnablePerformanceLogging = true</code> and threshold at 500 ms for visibility. Consider human-readable correlation IDs (<code>dev-{Guid}</code>) for quick searches.</li> <li>Production: Standardize <code>CorrelationHeaderName</code> with your API gateway. Keep thresholds aligned with SLOs; raise if noise is high. Ensure correlation IDs are opaque (GUIDs) to avoid leaking info.</li> <li>Tests: Inject <code>TraceId</code> for deterministic assertions. You can turn off performance logging to reduce noise or set a very low threshold to assert warnings in tests.</li> </ul>"},{"location":"extensions/core-options/#using-options-with-guards","title":"Using options with guards","text":"<p><pre><code>var guardOptions = GuardOptions.FromOptions(coreOptions.Value);\nvar result = Guard.AgainstNullOrWhiteSpace(name, nameof(name), guardOptions);\nif (result.IsFailure) return Result.Failure&lt;string&gt;(result.Errors, result.TraceId);\n</code></pre> - <code>GuardStrategy</code> drives return/throw/accumulate. - <code>TraceId</code> flows into errors produced by guards. - For accumulation, pass an <code>ErrorSink</code> into <code>GuardOptions.FromOptions(options, sink)</code>.</p>"},{"location":"extensions/core-options/#using-options-with-pipeline-behaviors","title":"Using options with pipeline behaviors","text":"<p><pre><code>services.AddScoped(typeof(IPipelineBehavior&lt;,&gt;), typeof(CorrelationBehavior&lt;,&gt;));\nservices.AddScoped(typeof(IPipelineBehavior&lt;,&gt;), typeof(PerformanceBehavior&lt;,&gt;));\nservices.AddScoped(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));\nservices.Configure&lt;CoreExtensionsOptions&gt;(configuration.GetSection(\"Extensions:Core\"));\n</code></pre> - PerformanceBehavior will skip logging if <code>EnablePerformanceLogging</code> is false. - CorrelationBehavior will use <code>CorrelationIdFactory</code> when no correlation ID is present.</p>"},{"location":"extensions/core-options/#patterns-and-scenarios","title":"Patterns and scenarios","text":""},{"location":"extensions/core-options/#1-matching-gatewayheader-expectations","title":"1) Matching gateway/header expectations","text":"<p>If your API gateway uses <code>X-Request-ID</code>, align it: <pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.CorrelationHeaderName = \"X-Request-ID\";\n    options.CorrelationIdFactory = () =&gt; Guid.NewGuid().ToString(\"N\");\n});\n</code></pre> Ensure middleware echoes the same header; <code>CorrelationBehavior</code> will reuse IDs set in <code>ILogContext</code>.</p>"},{"location":"extensions/core-options/#2-tightening-performance-thresholds-for-hot-paths","title":"2) Tightening performance thresholds for hot paths","text":"<p><pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.PerformanceWarningThreshold = TimeSpan.FromMilliseconds(200);\n});\n</code></pre> Use feature-specific options (named options) if some handlers are expected to run longer (e.g., reporting).</p>"},{"location":"extensions/core-options/#3-disabling-performance-logs-for-chatty-background-jobs","title":"3) Disabling performance logs for chatty background jobs","text":"<p><pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.EnablePerformanceLogging = false;\n});\n</code></pre> This keeps noise down in queues/cron workers that run high-frequency MediatR requests.</p>"},{"location":"extensions/core-options/#4-correlation-id-strategy-per-environment","title":"4) Correlation ID strategy per environment","text":"<ul> <li>Dev: prefix with <code>dev-</code> for quick grep (<code>dev-{Guid}</code>).</li> <li>Staging/prod: opaque GUIDs. Set <code>CorrelationIdFactory</code> accordingly in environment-specific DI modules.</li> </ul>"},{"location":"extensions/core-options/#5-seeding-traceid-for-resultguard-flows","title":"5) Seeding TraceId for result/guard flows","text":"<p>For APIs that already have a trace/correlation token (e.g., from a reverse proxy): <pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.TraceId = \"injected-from-middleware\"; // or set per-request in middleware using IOptionsSnapshot\n});\n</code></pre> Better: set <code>TraceId</code> per request using <code>IOptionsSnapshot&lt;CoreExtensionsOptions&gt;</code> and a middleware that copies the incoming header value into options for that scope.</p>"},{"location":"extensions/core-options/#per-request-overrides","title":"Per-request overrides","text":"<p>Use <code>IOptionsSnapshot&lt;CoreExtensionsOptions&gt;</code> or a scoped options wrapper to set per-request values (e.g., TraceId) based on incoming HTTP headers: <pre><code>public class CorrelationOptionsMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly IOptionsSnapshot&lt;CoreExtensionsOptions&gt; _options;\n    private readonly ILogContext _context;\n\n    public CorrelationOptionsMiddleware(RequestDelegate next, IOptionsSnapshot&lt;CoreExtensionsOptions&gt; options, ILogContext context)\n    {\n        _next = next;\n        _options = options;\n        _context = context;\n    }\n\n    public async Task Invoke(HttpContext http)\n    {\n        var incoming = http.Request.Headers[_options.Value.CorrelationHeaderName].FirstOrDefault();\n        var correlationId = string.IsNullOrWhiteSpace(incoming) ? _options.Value.CorrelationIdFactory() : incoming;\n        _context.CorrelationId = correlationId;\n        await _next(http);\n    }\n}\n</code></pre> - For <code>TraceId</code>, consider a scoped service that copies <code>_context.CorrelationId</code> into <code>CoreExtensionsOptions.TraceId</code> if you need Results to carry it automatically.</p>"},{"location":"extensions/core-options/#testing-options","title":"Testing options","text":"<ul> <li>Use <code>Options.Create(new CoreExtensionsOptions { ... })</code> for unit tests of behaviors/guards.</li> <li>For performance logs, set <code>EnablePerformanceLogging = true</code> and a low threshold, then assert that <code>InMemoryAppLogger</code> captures warnings.</li> <li>For guard tests, set <code>TraceId</code> and assert it flows into <code>Error.TraceId</code>.</li> </ul>"},{"location":"extensions/core-options/#migration-tips-from-the-template","title":"Migration tips from the template","text":"<ul> <li>Keep template behaviors if desired, but wire <code>CoreExtensionsOptions</code> to control Core behaviors. Template behaviors ignore these options, so ensure you register Core behaviors to benefit from the settings.</li> <li>If you currently hard-code thresholds or headers, move them into <code>Extensions:Core</code> configuration and consume via DI.</li> <li>Replace ad hoc correlation ID generation with <code>CorrelationIdFactory</code> to centralize ID format.</li> </ul>"},{"location":"extensions/core-options/#reference-option-defaults-and-effects","title":"Reference: option defaults and effects","text":"<ul> <li><code>CorrelationHeaderName</code>: Used by middleware/controllers to read/write correlation; behavior uses <code>ILogContext</code> (not header directly).</li> <li><code>CorrelationIdFactory</code>: Used by <code>CorrelationBehavior</code> when <code>ILogContext.CorrelationId</code> is empty.</li> <li><code>GuardStrategy</code>: Default for <code>GuardOptions.FromOptions</code>; controls return vs throw vs accumulate.</li> <li><code>EnablePerformanceLogging</code>: If false, <code>PerformanceBehavior</code> becomes a pass-through.</li> <li><code>PerformanceWarningThreshold</code>: Controls Warn vs Debug logging in <code>PerformanceBehavior</code>.</li> <li><code>TraceId</code>: Applied to guards/results when provided; useful for aligning API trace tokens with internal errors.</li> </ul>"},{"location":"extensions/core-options/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Bind <code>Extensions:Core</code> in configuration and call <code>services.Configure&lt;CoreExtensionsOptions&gt;(...)</code>. 2) Decide on correlation header and ID format; update gateway/middleware accordingly. 3) Set <code>GuardStrategy</code> globally; override per-call with <code>GuardOptions</code> when needed. 4) Tune <code>PerformanceWarningThreshold</code> and <code>EnablePerformanceLogging</code> per environment. 5) If you need TraceId propagation, set it per request (middleware + options snapshot) and pass it into Results/Errors.</p>"},{"location":"extensions/core-options/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for correlation/performance logging powered by these options.</li> <li>Core guard clauses for guard behavior controlled via options.</li> <li>Core result primitives to see how TraceId from options flows into results/errors.</li> <li>Core logging abstractions for correlation scopes influenced by header/factory choices.</li> <li>Core extension overview for the big-picture registration instructions.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/","title":"Core Pipeline Behaviors","text":"<p>The Core extension ships MediatR behaviors that drop into Jason Taylor\u2019s Clean Architecture pipeline without breaking existing registrations. This page explains what the template already includes, why the Core behaviors add correlation- and telemetry-friendly enhancements, and how to wire, order, and use them in real projects. Examples show both the pre-processor signature (<code>IRequestPreProcessor&lt;TRequest&gt;</code>) and the standard <code>IPipelineBehavior&lt;TRequest, TResponse&gt;</code> pattern so you can stay compatible with the template\u2019s DI setup.</p>"},{"location":"extensions/core-pipeline-behaviors/#what-the-template-already-covers","title":"What the template already covers","text":"<p>In the template (<code>src/Application/Common/Behaviours</code>), MediatR is wired with: - <code>LoggingBehaviour&lt;TRequest&gt;</code> (<code>IRequestPreProcessor&lt;TRequest&gt;</code>): Logs request name, user ID, and user name using <code>ILogger&lt;TRequest&gt;</code>, <code>IUser</code>, and <code>IIdentityService&gt;</code>. - <code>UnhandledExceptionBehaviour&lt;TRequest, TResponse&gt;</code>: Catches exceptions, logs them, and rethrows. - <code>AuthorizationBehaviour&lt;TRequest, TResponse&gt;</code>: Enforces <code>AuthorizeAttribute</code> roles/policies using <code>IUser</code> and <code>IIdentityService</code>; throws <code>UnauthorizedAccessException</code>/<code>ForbiddenAccessException</code>. - <code>ValidationBehaviour&lt;TRequest, TResponse&gt;</code>: Runs FluentValidation validators; throws <code>ValidationException</code> when failures exist. - <code>PerformanceBehaviour&lt;TRequest, TResponse&gt;</code>: Uses a <code>Stopwatch</code>; logs warnings via <code>ILogger&lt;TRequest&gt;</code> when elapsed time &gt; 500 ms. It does not attach correlation metadata.</p> <p>Registration order in <code>Application.DependencyInjection</code>: pre-processor logging, then unhandled exception, authorization, validation, performance.</p> <p>Gaps the template intentionally leaves open: - No correlation ID propagation across logs and handlers. - No structured logging abstraction\u2014everything is tied to <code>ILogger&lt;T&gt;</code>. - No toggle for performance logging or threshold configuration via options. - No reusable logging scope that flows into other behaviors.</p>"},{"location":"extensions/core-pipeline-behaviors/#what-the-core-behaviors-add","title":"What the Core behaviors add","text":"<p>The Core behaviors preserve template compatibility while adding cross-cutting concerns you need in production: - Correlation-aware: <code>CorrelationBehavior</code> ensures <code>ILogContext.CorrelationId</code> is set (configurable factory) and pushes it into a logging scope. - Structured logging: <code>LoggingPreProcessor&lt;TRequest&gt;</code> emits start events as a pre-processor; <code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> emits handling/handled events in the pipeline. Both use <code>IAppLogger&lt;T&gt;</code> and <code>ILogContext</code> for provider-agnostic structured logs and correlation. - Configurable performance telemetry: <code>PerformanceBehavior</code> measures elapsed time with <code>IClock</code> and warns when <code>CoreExtensionsOptions.PerformanceWarningThreshold</code> is exceeded; it can be globally disabled via <code>EnablePerformanceLogging</code>. - Option-driven defaults: Correlation header/name, ID factory, and performance thresholds live in <code>CoreExtensionsOptions</code>. - Provider-agnostic logging: Behaviors depend on <code>IAppLogger&lt;T&gt;</code> and <code>ILogContext</code>, making it easy to plug in Serilog, MEL, or in-memory loggers for tests.</p>"},{"location":"extensions/core-pipeline-behaviors/#behavior-apis-core","title":"Behavior APIs (Core)","text":"<ul> <li><code>CorrelationBehavior&lt;TRequest, TResponse&gt;</code> (<code>IPipelineBehavior</code>): Ensures correlation ID, pushes scope via <code>ILogContext.PushProperty</code>.</li> <li><code>LoggingPreProcessor&lt;TRequest&gt;</code> (<code>IRequestPreProcessor&lt;TRequest&gt;</code>): Logs request start with correlation + timestamp; sets correlation if missing.</li> <li><code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> (<code>IPipelineBehavior</code>): Logs handling/end with correlation + request type; sets correlation if missing.</li> <li><code>PerformanceBehavior&lt;TRequest, TResponse&gt;</code> (<code>IPipelineBehavior</code>): Times handler execution; warns vs. debug logs; respects <code>EnablePerformanceLogging</code> and <code>PerformanceWarningThreshold</code>.</li> </ul> <p>Dependencies: - <code>IAppLogger&lt;T&gt;</code> (logging abstraction). - <code>ILogContext</code> (correlation scope). - <code>IClock</code> (time source). - <code>CoreExtensionsOptions</code> (correlation + performance settings).</p>"},{"location":"extensions/core-pipeline-behaviors/#recommended-pipeline-order","title":"Recommended pipeline order","text":"<p>To stay compatible with the template\u2019s semantics while adding correlation: 1) <code>CorrelationBehavior</code> (ensures correlation ID). 2) <code>LoggingPreProcessor</code> registered as <code>IRequestPreProcessor</code> (logs start) and <code>LoggingBehavior</code> registered as <code>IPipelineBehavior</code> (logs handling/end). 3) <code>UnhandledExceptionBehaviour</code> (template). 4) <code>AuthorizationBehaviour</code> (template). 5) <code>ValidationBehaviour</code> (template). 6) <code>PerformanceBehaviour</code> (measures the whole request). 7) Handler.</p> <p>This preserves the template\u2019s order while guaranteeing that correlation and logging scopes exist for subsequent behaviors and for performance logs.</p>"},{"location":"extensions/core-pipeline-behaviors/#wiring-in-di-application-layer","title":"Wiring in DI (Application layer)","text":"<p>A runnable example lives at <code>samples/CleanArchitecture.Extensions.Core.Pipeline.Sample/src/Application/DependencyInjection.cs</code>. It wires Core behaviors plus adapters that bridge to <code>ILogger&lt;T&gt;</code>:</p> <p><pre><code>builder.Services.Configure&lt;CoreExtensionsOptions&gt;(builder.Configuration.GetSection(\"Extensions:Core\"));\nbuilder.Services.AddSingleton&lt;IClock, SystemClock&gt;();\nbuilder.Services.AddScoped&lt;ILogContext, MelLogContext&gt;(); // MEL-backed scope\nbuilder.Services.AddScoped(typeof(IAppLogger&lt;&gt;), typeof(MelAppLogger&lt;&gt;)); // MEL adapter\n\nbuilder.Services.AddMediatR(cfg =&gt; {\n    cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());\n    cfg.AddOpenRequestPreProcessor(typeof(LoggingPreProcessor&lt;&gt;));\n    cfg.AddOpenBehavior(typeof(CorrelationBehavior&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(LoggingBehavior&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(UnhandledExceptionBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(AuthorizationBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(ValidationBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(PerformanceBehavior&lt;,&gt;));\n});\n</code></pre> - The adapter types (<code>MelLogContext</code>, <code>MelAppLogger&lt;T&gt;</code>) show how to reuse existing <code>ILogger</code> pipelines while satisfying Core abstractions. - <code>LoggingPreProcessor</code> is registered as a pre-processor (start log) and <code>LoggingBehavior</code> as a pipeline behavior (handling/end log).</p>"},{"location":"extensions/core-pipeline-behaviors/#sample-backed-walkthrough-pipeline-sample","title":"Sample-backed walkthrough (pipeline sample)","text":"<p>The runnable sample at <code>samples/CleanArchitecture.Extensions.Core.Pipeline.Sample</code> exercises the behaviors with real endpoints.</p>"},{"location":"extensions/core-pipeline-behaviors/#correlation-flowing-into-handlers","title":"Correlation flowing into handlers","text":"<p><code>src/Application/Diagnostics/Queries/GetPipelineDiagnostics/GetPipelineDiagnostics.cs</code>: <pre><code>var correlationId = _logContext.CorrelationId ?? _clock.NewGuid().ToString(\"N\");\n\n_logger.Log(LogLevel.Information, $\"Diagnostics requested with correlation {correlationId}\");\n\nreturn Task.FromResult(new PipelineDiagnosticsDto(correlationId, _clock.UtcNow));\n</code></pre> - <code>CorrelationBehavior</code> seeds <code>_logContext.CorrelationId</code>; the handler reuses it and returns it to the caller.</p>"},{"location":"extensions/core-pipeline-behaviors/#performance-warnings-on-slow-commands","title":"Performance warnings on slow commands","text":"<p><code>src/Application/Diagnostics/Commands/SimulateWork/SimulateWork.cs</code>: <pre><code>var delay = Math.Max(0, request.Milliseconds);\n_logger.Log(LogLevel.Information, $\"Simulating {delay} ms of work\");\n\nawait _clock.Delay(TimeSpan.FromMilliseconds(delay), cancellationToken);\n\n_logger.Log(LogLevel.Debug, $\"Completed simulated work after {delay} ms\");\n</code></pre> - With <code>PerformanceWarningThreshold</code> set to 400 ms in <code>src/Web/appsettings.json</code>, <code>POST /api/Diagnostics/simulate?milliseconds=650</code> emits a performance warning from <code>PerformanceBehavior</code> while returning 202 Accepted.</p>"},{"location":"extensions/core-pipeline-behaviors/#minimal-api-endpoints-exposing-the-behaviors","title":"Minimal API endpoints exposing the behaviors","text":"<p><code>src/Web/Endpoints/Diagnostics.cs</code>: <pre><code>public async Task&lt;IResult&gt; GetPipelineDiagnostics(ISender sender) =&gt;\n    TypedResults.Ok(await sender.Send(new GetPipelineDiagnosticsQuery()));\n\npublic async Task&lt;IResult&gt; SimulateWork(ISender sender, int milliseconds = 600)\n{\n    await sender.Send(new SimulateWorkCommand(milliseconds));\n    return TypedResults.Accepted($\"/api/{nameof(Diagnostics)}/simulate?milliseconds={milliseconds}\");\n}\n</code></pre> - <code>LoggingPreProcessor</code> logs start, <code>LoggingBehavior</code> logs handling/end, <code>CorrelationBehavior</code> scopes correlation, and <code>PerformanceBehavior</code> times the simulated work.</p>"},{"location":"extensions/core-pipeline-behaviors/#behavior-by-behavior-deep-dive","title":"Behavior-by-behavior deep dive","text":""},{"location":"extensions/core-pipeline-behaviors/#correlationbehavior","title":"CorrelationBehavior","text":"<ul> <li>Purpose: Ensure every request has a correlation ID flowing through <code>ILogContext</code> and attached to structured logs.</li> <li>How it works: If <code>ILogContext.CorrelationId</code> is empty, it uses <code>CoreExtensionsOptions.CorrelationIdFactory</code> (default GUID) or <code>_clock.NewGuid()</code> to create one. It pushes a property named <code>CorrelationId</code> into the logging scope via <code>ILogContext.PushProperty</code>, then calls <code>next</code>.</li> <li>Interop with web APIs: Controllers or middleware can set <code>ILogContext.CorrelationId</code> from incoming headers (e.g., <code>X-Correlation-ID</code>). The behavior preserves that value rather than overwriting it.</li> <li>Why before logging: Downstream behaviors and handlers can rely on <code>ILogContext.CorrelationId</code> being present for logs, telemetry, and Results.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#loggingbehavior","title":"LoggingBehavior","text":"<ul> <li>Purpose: Emit structured logs at start and end of request handling, carrying correlation ID and request type.</li> <li>Split start/end logging: <code>LoggingPreProcessor&lt;TRequest&gt;</code> runs as the pre-processor for start logs; <code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> runs in the pipeline for handling/finished logs.</li> <li>Scope handling: Uses <code>ILogContext.PushProperty</code> to keep <code>CorrelationId</code> in scope for downstream logging and for the paired end log.</li> <li>Data logged: Request type (full name), correlation ID, start timestamp (from <code>IClock</code>), and lifecycle messages (\u201cStarting\u201d, \u201cHandling\u201d, \u201cHandled\u201d).</li> <li>Compatibility: Replaces the template <code>LoggingBehaviour&lt;TRequest&gt;</code>; you can still enrich logs with user info by adapting <code>IAppLogger&lt;T&gt;</code> to include user claims.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#performancebehavior","title":"PerformanceBehavior","text":"<ul> <li>Purpose: Measure elapsed time for each request and emit warnings above a configurable threshold; otherwise debug-level messages.</li> <li>Config: <code>CoreExtensionsOptions.EnablePerformanceLogging</code> (bool) and <code>PerformanceWarningThreshold</code> (TimeSpan, default 500 ms).</li> <li>Correlation: Includes <code>CorrelationId</code> from <code>ILogContext</code> in logged properties.</li> <li>Clock: Uses <code>IClock</code> to allow deterministic testing with <code>FrozenClock</code>.</li> <li>Behavior: If logging is disabled, it immediately forwards to <code>next</code>. Otherwise, it records start time, invokes <code>next</code>, computes elapsed, and logs either Warn (over threshold) or Debug (under threshold).</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#real-world-usage-patterns","title":"Real-world usage patterns","text":""},{"location":"extensions/core-pipeline-behaviors/#1-correlating-api-requests-end-to-end","title":"1) Correlating API requests end-to-end","text":"<p><pre><code>public class CorrelationMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogContext _logContext;\n    private readonly CoreExtensionsOptions _options;\n\n    public CorrelationMiddleware(RequestDelegate next, ILogContext logContext, IOptions&lt;CoreExtensionsOptions&gt; options)\n    {\n        _next = next;\n        _logContext = logContext;\n        _options = options.Value;\n    }\n\n    public async Task Invoke(HttpContext context)\n    {\n        var header = _options.CorrelationHeaderName;\n        var incoming = context.Request.Headers[header].FirstOrDefault();\n        _logContext.CorrelationId = string.IsNullOrWhiteSpace(incoming)\n            ? _options.CorrelationIdFactory()\n            : incoming;\n\n        using var scope = _logContext.PushProperty(\"CorrelationId\", _logContext.CorrelationId);\n        context.Response.Headers[header] = _logContext.CorrelationId!;\n        await _next(context);\n    }\n}\n</code></pre> - With the middleware setting <code>ILogContext.CorrelationId</code>, <code>CorrelationBehavior</code> will reuse it, ensuring MediatR logs share the same ID.</p>"},{"location":"extensions/core-pipeline-behaviors/#2-swapping-logging-providers-without-touching-handlers","title":"2) Swapping logging providers without touching handlers","text":"<p><pre><code>// Adapter bridging IAppLogger&lt;T&gt; to Microsoft.Extensions.Logging\npublic sealed class MelAppLogger&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    private readonly ILogger&lt;T&gt; _logger;\n    private readonly ILogContext _context;\n\n    public MelAppLogger(ILogger&lt;T&gt; logger, ILogContext context)\n    {\n        _logger = logger;\n        _context = context;\n    }\n\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        using var scope = _logger.BeginScope(new Dictionary&lt;string, object?&gt;\n        {\n            [\"CorrelationId\"] = _context.CorrelationId\n        });\n        _logger.Log(Map(level), exception, message + \" {@props}\", properties);\n    }\n\n    private Microsoft.Extensions.Logging.LogLevel Map(LogLevel level) =&gt; level switch\n    {\n        LogLevel.Trace =&gt; Microsoft.Extensions.Logging.LogLevel.Trace,\n        LogLevel.Debug =&gt; Microsoft.Extensions.Logging.LogLevel.Debug,\n        LogLevel.Information =&gt; Microsoft.Extensions.Logging.LogLevel.Information,\n        LogLevel.Warning =&gt; Microsoft.Extensions.Logging.LogLevel.Warning,\n        LogLevel.Error =&gt; Microsoft.Extensions.Logging.LogLevel.Error,\n        LogLevel.Critical =&gt; Microsoft.Extensions.Logging.LogLevel.Critical,\n        _ =&gt; Microsoft.Extensions.Logging.LogLevel.None\n    };\n}\n</code></pre> - Behaviors depend on <code>IAppLogger&lt;T&gt;</code>; swapping providers requires only registering a different adapter.</p>"},{"location":"extensions/core-pipeline-behaviors/#3-measuring-command-performance-with-thresholds-per-feature","title":"3) Measuring command performance with thresholds per feature","text":"<p>If some handlers are expected to run longer, you can override options per scope: <pre><code>public class FeaturePerformanceOptions\n{\n    public static CoreExtensionsOptions ForReporting(CoreExtensionsOptions baseOptions) =&gt;\n        new()\n        {\n            CorrelationHeaderName = baseOptions.CorrelationHeaderName,\n            GuardStrategy = baseOptions.GuardStrategy,\n            EnablePerformanceLogging = true,\n            PerformanceWarningThreshold = TimeSpan.FromSeconds(2),\n            CorrelationIdFactory = baseOptions.CorrelationIdFactory\n        };\n}\n</code></pre> Inject a feature-specific options instance where needed (e.g., using named options) if you must raise the threshold for a known long-running report generation command.</p>"},{"location":"extensions/core-pipeline-behaviors/#4-capturing-correlation-in-resulterror-metadata","title":"4) Capturing correlation in Result/Error metadata","text":"<p><pre><code>public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateInvoiceCommand request, CancellationToken ct)\n{\n    var traceId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n\n    var customer = await _customers.GetAsync(request.CustomerId, ct);\n    if (customer is null)\n    {\n        return Result.Failure&lt;Guid&gt;(new Error(\"invoice.customer-not-found\", \"Customer not found\", traceId));\n    }\n\n    var invoiceId = await _invoices.CreateAsync(request.CustomerId, request.Amount, ct);\n    return Result.Success(invoiceId, traceId);\n}\n</code></pre> - Because <code>CorrelationBehavior</code> set <code>ILogContext.CorrelationId</code>, the handler can propagate the same ID into <code>Result</code>/<code>Error</code> for downstream API responses.</p>"},{"location":"extensions/core-pipeline-behaviors/#5-testing-behaviors-deterministically","title":"5) Testing behaviors deterministically","text":"<p><pre><code>[Fact]\npublic async Task PerformanceBehavior_Warns_When_Over_Threshold()\n{\n    var clock = new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\"));\n    var logger = new InMemoryAppLogger&lt;TestRequest&gt;();\n    var context = new InMemoryLogContext { CorrelationId = \"corr-1\" };\n    var options = Microsoft.Extensions.Options.Options.Create(new CoreExtensionsOptions { EnablePerformanceLogging = true, PerformanceWarningThreshold = TimeSpan.FromMilliseconds(10) });\n    var behavior = new PerformanceBehavior&lt;TestRequest, Unit&gt;(logger, context, options, clock);\n\n    var response = await behavior.Handle(new TestRequest(), _ =&gt; Task.FromResult(Unit.Value), CancellationToken.None);\n\n    logger.Entries.Should().Contain(e =&gt; e.Level == LogLevel.Warning &amp;&amp; e.CorrelationId == \"corr-1\");\n}\n</code></pre> - <code>FrozenClock</code> and <code>InMemoryAppLogger</code> make assertions straightforward.</p>"},{"location":"extensions/core-pipeline-behaviors/#configuration-reference","title":"Configuration reference","text":"<p><code>CoreExtensionsOptions</code> fields relevant to behaviors: - <code>CorrelationHeaderName</code>: The header your APIs use for correlation (helps middleware + controllers align). - <code>CorrelationIdFactory</code>: Func to generate correlation IDs when absent (default GUID \u201cN\u201d). - <code>EnablePerformanceLogging</code>: Toggle performance measurement. - <code>PerformanceWarningThreshold</code>: TimeSpan for warning threshold (default 500 ms). - <code>TraceId</code>: Optional trace ID to apply to guard/result flows (not directly used by behaviors but useful for consistency). <p>Example appsettings: <pre><code>{\n  \"Extensions\": {\n    \"Core\": {\n      \"CorrelationHeaderName\": \"X-Correlation-ID\",\n      \"EnablePerformanceLogging\": true,\n      \"PerformanceWarningThreshold\": \"00:00:00.500\",\n      \"GuardStrategy\": \"ReturnFailure\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"extensions/core-pipeline-behaviors/#ordering-and-coexistence-tips","title":"Ordering and coexistence tips","text":"<ul> <li>Pre-processor vs. pipeline: Keep <code>LoggingPreProcessor</code> registered if you need \u201crequest started\u201d logs before other behaviors. <code>LoggingBehavior</code> still logs \u201cHandled\u201d after downstream behaviors.</li> <li>Validation exceptions: If FluentValidation throws, <code>LoggingBehavior</code> will have already logged \u201cHandling\u201d; <code>UnhandledExceptionBehaviour</code> will log the exception. Consider adding error logs in exception middleware if you need both start/finish markers on failure.</li> <li>Multiple correlation sources: If API middleware sets <code>ILogContext.CorrelationId</code>, <code>CorrelationBehavior</code> will respect it. Avoid regenerating IDs in handlers; rely on the behavior + middleware.</li> <li>Performance scope: If you run background jobs with MediatR, performance logs will still flow; set <code>EnablePerformanceLogging = false</code> for noise-sensitive jobs or adjust thresholds.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#migration-from-template-behaviors","title":"Migration from template behaviors","text":"<ul> <li>Replace <code>LoggingBehaviour&lt;TRequest&gt;</code> with Core <code>LoggingPreProcessor</code> + <code>LoggingBehavior</code> registrations.</li> <li>Keep <code>UnhandledExceptionBehaviour</code>, <code>AuthorizationBehaviour</code>, and <code>ValidationBehaviour</code> as-is; Core behaviors are additive.</li> <li>Remove <code>Stopwatch</code>-based performance behavior from the template if you want correlation-aware performance logging; Core <code>PerformanceBehavior</code> is a drop-in replacement with options.</li> <li>Keep handler code unchanged; behaviors are registered in DI and require no handler modifications.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#faq","title":"FAQ","text":"<ul> <li>Do I need both pre-processor and pipeline registrations? Optional but recommended for parity with the template: <code>LoggingPreProcessor</code> captures the \u201cstarting\u201d log before other behaviors run; <code>LoggingBehavior</code> captures \u201chandled\u201d after all behaviors and the handler.</li> <li>Can I add request payload sampling? Wrap <code>IAppLogger&lt;T&gt;</code> to include sanitized payload summaries; keep PII concerns in mind. The behavior provides request type and correlation ID; payload logging is left to your adapter to avoid allocations and sensitivity issues.</li> <li>What about OpenTelemetry? Adapt <code>IAppLogger&lt;T&gt;</code> or <code>ILogContext</code> to bridge correlation IDs to trace/span IDs. The behaviors themselves do not depend on OTEL packages.</li> <li>Does correlation flow to domain events? If you propagate <code>ILogContext.CorrelationId</code> into <code>DomainEvent.CorrelationId</code> or <code>Result.TraceId</code> inside handlers, you can correlate across pipelines. Core behaviors set the context; you attach it to your domain events manually.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Register <code>CorrelationBehavior</code>, <code>LoggingPreProcessor</code> (pre-processor), <code>LoggingBehavior</code> (pipeline), and <code>PerformanceBehavior</code> in the Application DI layer. 2) Configure <code>CoreExtensionsOptions</code> (header name, correlation ID factory, performance threshold). 3) Provide <code>ILogContext</code> and <code>IAppLogger&lt;T&gt;</code> adapters that forward correlation scopes to your logging provider. 4) Add middleware (optional) to set <code>ILogContext.CorrelationId</code> from incoming headers and echo it back. 5) Validate ordering: ensure correlation precedes logging; ensure performance wraps handler work after validation/authorization. 6) Write a smoke test: send a request through MediatR in-memory, assert correlation ID is present in logs and performance logs respect thresholds.</p>"},{"location":"extensions/core-pipeline-behaviors/#related-docs","title":"Related docs","text":"<ul> <li>Core extension overview for the full package and registration guidance.</li> <li>Core Result Primitives to see how correlation flows into results/errors.</li> <li>Core Guard Clauses for input validation that pairs well with these behaviors.</li> <li>Validation extension if you lean on FluentValidation behaviors alongside Core pipeline behaviors.</li> </ul>"},{"location":"extensions/core-result-primitives/","title":"Core Result Primitives","text":"<p>The Core extension ships a richer <code>Result</code> model than the one inside Jason Taylor\u2019s Clean Architecture template. This page explains what the template provides today, why the extension adds more, how to use the upgraded primitives, and how to adopt them incrementally without fighting the template\u2019s MediatR-centric structure.</p>"},{"location":"extensions/core-result-primitives/#what-the-template-already-covers","title":"What the template already covers","text":"<p>Jason\u2019s template keeps the built-in result type intentionally small so new projects stay approachable: - <code>src/Application/Common/Models/Result.cs</code> exposes <code>bool Succeeded</code> plus <code>string[] Errors</code>, with static <code>Success()</code> and <code>Failure(IEnumerable&lt;string&gt;)</code>. - It is used mainly by the Identity layer (<code>Infrastructure/Identity/IdentityResultExtensions.cs</code> converts <code>IdentityResult</code> to <code>Result</code>; <code>IdentityService.DeleteUserAsync</code> returns it). Commands/queries typically return view models or primitives directly, not <code>Result</code>. - MediatR pipeline behaviors (<code>LoggingBehaviour</code>, <code>UnhandledExceptionBehaviour</code>, <code>AuthorizationBehaviour</code>, <code>ValidationBehaviour</code>, <code>PerformanceBehaviour</code>) assume exceptions for failures (e.g., FluentValidation throws <code>ValidationException</code>), not a rich result envelope. - There is no explicit place for trace/correlation IDs. Logging relies on <code>ILogger&lt;T&gt;</code> scopes populated by <code>IUser</code>/<code>IIdentityService</code> rather than a result metadata contract. - Errors are unstructured strings; you cannot attach error codes, metadata, or machine-readable details without inventing your own type downstream.</p> <p>That minimalism works for demos and small features, but it leaves gaps once you need consistent error shapes, correlation-friendly diagnostics, or functional composition across handlers.</p>"},{"location":"extensions/core-result-primitives/#why-use-the-core-result-primitives","title":"Why use the Core Result primitives","text":"<p>The extension keeps the success/failure semantics but adds the capabilities teams routinely need in production: - Traceability: <code>Result</code> and <code>Error</code> carry an optional <code>TraceId</code> so handlers and web APIs can preserve request/operation identifiers without leaking logging concerns into business code. - Structured errors: <code>Error</code> holds <code>Code</code>, <code>Message</code>, and optional <code>Metadata</code> (key/value) to capture domain facts (e.g., constraints, limits, offending values) in a machine-readable way. - Value payloads: <code>Result&lt;T&gt;</code> wraps successful values, avoiding parallel DTOs for \u201cmaybe failed\u201d responses. - Composition: Helpers like <code>Map</code>, <code>Bind</code>, <code>Tap</code>, <code>Ensure</code>, <code>Recover</code>, and <code>Combine</code> let you chain operations without nested <code>if</code> blocks or exception gymnastics. - Guard synergy: Guard clauses in the same package can emit <code>Result&lt;T&gt;</code> with trace IDs and error codes, giving you a uniform contract from validation through handler to API. - Testability: Deterministic results and errors make it easy to assert flows without depending on logging side effects or exception throwing. - Interop: You can adapt the template\u2019s <code>Result</code> (strings) into the richer <code>Result</code>/<code>Error</code> shape and back, enabling gradual adoption.</p>"},{"location":"extensions/core-result-primitives/#api-surface-at-a-glance","title":"API surface at a glance","text":"<ul> <li>Types: <code>Result</code>, <code>Result&lt;T&gt;</code>, and <code>Error</code> live in <code>CleanArchitecture.Extensions.Core.Results</code>.</li> <li>Creation: <code>Result.Success(traceId?)</code>, <code>Result.Success&lt;T&gt;(value, traceId?)</code>, <code>Result.Failure(error|errors, traceId?)</code>, <code>Result.Failure&lt;T&gt;(...)</code>.</li> <li>Inspection: <code>IsSuccess</code>, <code>IsFailure</code>, <code>Errors</code>, <code>TraceId</code>, <code>Value</code>, <code>ValueOrDefault</code>.</li> <li>Composition: </li> <li><code>Result&lt;T&gt;.Map(Func&lt;T, TResult&gt;)</code> and <code>Bind(Func&lt;T, Result&lt;TResult&gt;&gt;)</code></li> <li><code>Result&lt;T&gt;.Tap(Action&lt;T&gt;)</code> for side effects on success</li> <li><code>Result&lt;T&gt;.Ensure(predicate, error)</code> to enforce additional invariants</li> <li><code>ResultExtensions.Ensure(predicate, error)</code> for non-generic results</li> <li><code>Result.Combine(params Result[])</code> to aggregate multiple checks</li> <li><code>ResultExtensions.Recover(fallback)</code> to supply a fallback value on failure</li> <li><code>ResultExtensions.ToResult()</code> to wrap raw values</li> <li>Errors: <code>Error</code> exposes <code>Code</code>, <code>Message</code>, optional <code>TraceId</code>, <code>Metadata</code>, <code>HasMetadata</code>, and helpers <code>WithTraceId(...)</code>, <code>WithMetadata(key, value)</code>.</li> </ul>"},{"location":"extensions/core-result-primitives/#compatibility-and-migration-from-the-template","title":"Compatibility and migration from the template","text":"<p>You can start with the template\u2019s existing patterns and layer Core Results gradually: - Mapping template \u2192 Core: <code>Result.Success()</code> becomes <code>Result.Success(traceId)</code>; <code>Result.Failure(strings)</code> can be projected to <code>Result.Failure(strings.Select(s =&gt; new Error(\"identity\", s)))</code> or use <code>LegacyResult.Failure(strings).ToResult(traceId)</code>. - Mapping Core \u2192 template: <code>Result.Success(traceId)</code> can return <code>CleanArchitecture.Application.Common.Models.Result.Success()</code> or <code>LegacyResult.FromResult(result)</code>. Failures can flatten via <code>Errors.Select(e =&gt; $\"{e.Code}: {e.Message}\")</code> or rely on the adapter\u2019s default formatter. - Handlers: Keep return types as your feature needs (DTOs, primitives). Introduce <code>Result&lt;T&gt;</code> where you want richer errors without throwing. You can adopt it per handler; nothing requires a big bang change. - Pipelines: Core Results do not change pipeline signatures; they work with the template\u2019s behaviors. Validation that throws still bubbles through <code>UnhandledExceptionBehaviour</code>; you can prefer guard/result composition to avoid exceptions when appropriate.</p>"},{"location":"extensions/core-result-primitives/#real-world-use-cases-backed-by-the-sample","title":"Real-world use cases (backed by the sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Result.Sample</code>. It keeps Jason\u2019s <code>IApplicationDbContext</code> style while exercising Core Results in a <code>Projects</code> feature.</p>"},{"location":"extensions/core-result-primitives/#1-creating-a-project-with-guards-combine","title":"1) Creating a project with guards + <code>Combine</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Application/Projects/Commands/CreateProject/CreateProject.cs</code>:</p> <p><pre><code>public async Task&lt;CoreResults.Result&lt;int&gt;&gt; Handle(CreateProjectCommand request, CancellationToken cancellationToken)\n{\n    var traceId = Guid.NewGuid().ToString(\"N\");\n    var guardOptions = new GuardOptions { TraceId = traceId };\n\n    var name = Guard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name), guardOptions)\n        .Ensure(n =&gt; n.Length &lt;= MaxNameLength, new CoreResults.Error(\"projects.name.length\", $\"Project name must be {MaxNameLength} characters or fewer.\", traceId));\n\n    var description = Guard.Ensure(request.Description is null || request.Description.Length &lt;= MaxDescriptionLength,\n        \"projects.description.length\",\n        $\"Description must be {MaxDescriptionLength} characters or fewer.\",\n        guardOptions);\n\n    var budget = Guard.Ensure(request.Budget &gt;= 0,\n        \"projects.budget.range\",\n        \"Budget cannot be negative.\",\n        guardOptions);\n\n    var validation = CoreResults.Result.Combine(name, description, budget);\n    if (validation.IsFailure)\n    {\n        return CoreResults.Result.Failure&lt;int&gt;(validation.Errors, traceId);\n    }\n\n    var project = new Project(name.Value, request.Description, request.Budget);\n\n    var duplicateName = await _context.Projects\n        .AnyAsync(p =&gt; p.Name == project.Name, cancellationToken);\n\n    if (duplicateName)\n    {\n        var duplicateError = new CoreResults.Error(\"projects.name.duplicate\", \"A project with this name already exists.\", traceId)\n            .WithMetadata(\"name\", project.Name);\n\n        return CoreResults.Result.Failure&lt;int&gt;(duplicateError, traceId);\n    }\n\n    _context.Projects.Add(project);\n    await _context.SaveChangesAsync(cancellationToken);\n\n    return CoreResults.Result.Success(project.Id, traceId);\n}\n</code></pre> - <code>GuardOptions.TraceId</code> seeds correlation on every guard failure and success. - <code>Result.Combine</code> keeps the handler branch-free until all synchronous validations run. - Errors capture metadata (<code>name</code>) before returning <code>Result&lt;int&gt;</code> to the caller.</p>"},{"location":"extensions/core-result-primitives/#2-closing-a-project-with-bind-and-tap","title":"2) Closing a project with <code>Bind</code> and <code>Tap</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Application/Projects/Commands/CloseProject/CloseProject.cs</code>:</p> <p><pre><code>var closeResult = Guard.AgainstNull(project, nameof(project), guardOptions)\n    .Bind(p =&gt; EnsureNotClosed(p, traceId))\n    .Tap(p =&gt; p.Close(DateTimeOffset.UtcNow));\n\nif (closeResult.IsFailure)\n{\n    return CoreResults.Result.Failure(closeResult.Errors, traceId);\n}\n\nawait _context.SaveChangesAsync(cancellationToken);\n\nreturn CoreResults.Result.Success(traceId);\n\nstatic CoreResults.Result&lt;Project&gt; EnsureNotClosed(Project project, string traceId)\n{\n    return project.IsClosed\n        ? CoreResults.Result.Failure&lt;Project&gt;(new CoreResults.Error(\"projects.closed\", \"Project is already closed.\", traceId), traceId)\n        : CoreResults.Result.Success(project, traceId);\n}\n</code></pre> - <code>Bind</code> short-circuits if the entity is missing or already closed. - <code>Tap</code> performs the side effect (marking the project closed) without losing the trace ID.</p>"},{"location":"extensions/core-result-primitives/#3-mapping-results-to-http-responses","title":"3) Mapping results to HTTP responses","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Application/Projects/Queries/GetProjectById/GetProjectById.cs</code> and <code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Web/Endpoints/Projects.cs</code>:</p> <p><pre><code>// Query handler\nvar projectResult = Guard.AgainstNull(project, nameof(project), guardOptions);\n\nreturn projectResult.Map(p =&gt; new ProjectSummaryDto\n{\n    Id = p.Id,\n    Name = p.Name,\n    Budget = p.Budget,\n    IsClosed = p.IsClosed,\n    ClosedOn = p.ClosedOn\n}, traceId);\n\n// Minimal API endpoint\npublic async Task&lt;IResult&gt; GetProjectById(ISender sender, int id)\n{\n    var result = await sender.Send(new GetProjectByIdQuery(id));\n\n    return result.Match&lt;IResult&gt;(\n        project =&gt; TypedResults.Ok(new { project, traceId = result.TraceId }),\n        _ =&gt; ToProblemResult(\"Project not found.\", result, StatusCodes.Status404NotFound));\n}\n</code></pre> - <code>Map</code> preserves the guard trace ID when projecting to a DTO. - <code>Match</code> produces consistent HTTP payloads with structured errors + <code>traceId</code>.</p>"},{"location":"extensions/core-result-primitives/#detailed-behavior-notes","title":"Detailed behavior notes","text":"<ul> <li>Trace IDs: If you pass a trace ID into <code>Result.Success</code> or <code>Result.Failure</code>, it will be copied into contained errors (or derived from the first error when not provided). Combine also prefers the first non-empty trace ID it finds.</li> <li>Error metadata: Use <code>WithMetadata</code> to attach machine-readable context (e.g., offending parameter, limit, current balance). Metadata is left untouched unless you clone the error.</li> <li>Value access: <code>Result&lt;T&gt;.Value</code> throws on failure to prevent accidental use; prefer <code>ValueOrDefault</code> when you deliberately ignore failures (rare) or <code>Match</code> for explicit branching.</li> <li>Recover: When you want a fallback without losing errors, <code>Recover</code> converts failure into success with a derived value (and carries the original trace ID). Useful for caching or default projections.</li> <li>Thread safety: Results are immutable; the error list is wrapped in <code>ReadOnlyCollection&lt;Error&gt;</code>. You can safely pass results across tasks without extra locking.</li> </ul>"},{"location":"extensions/core-result-primitives/#usage-patterns-and-guidance","title":"Usage patterns and guidance","text":"<ul> <li>Prefer <code>Result&lt;T&gt;</code> at boundaries: Commands/queries that are exposed to external callers benefit most because you can return rich, predictable errors to API controllers, background jobs, or message handlers.</li> <li>Keep exceptions for truly exceptional cases: Domain validation, guard failures, and expected business rule violations should return <code>Result</code>; infrastructure failures (DB down, unexpected null) can still throw to be caught by <code>UnhandledExceptionBehaviour</code> or global middleware.</li> <li>Name your error codes consistently: Use domain-prefixed codes (<code>billing.credit-limit</code>, <code>cart.empty</code>, <code>user.not-found</code>) so clients and observability tools can filter/search easily.</li> <li>Propagate correlation: When you have a correlation ID in <code>ILogContext</code> or HTTP headers, pass it into your first <code>Result</code> creation so all downstream errors carry it. The pipeline behaviors in Core keep <code>ILogContext</code> hydrated.</li> <li>Compose before persisting: Use <code>Combine</code> to gather errors before calling repositories. This keeps persistence logic free of partial states.</li> <li>Testing: Assert on <code>IsSuccess/IsFailure</code>, <code>Errors.Count</code>, and <code>TraceId</code>. For pipelines, pair <code>InMemoryAppLogger</code> with <code>ILogContext</code> to assert correlation + timing alongside result flows.</li> </ul>"},{"location":"extensions/core-result-primitives/#frequently-asked-questions","title":"Frequently asked questions","text":"<ul> <li>Do I have to return <code>Result</code> from every handler? No. Use it where you want structured errors and correlation in your contract. You can mix <code>Result&lt;T&gt;</code> handlers with plain DTO-returning handlers.</li> <li>Will this break the template\u2019s pipeline behaviors? No. All behaviors keep the same generic signatures. You can register Core behaviors in the same order as the template\u2019s behaviors to preserve semantics.</li> <li>How do I integrate with FluentValidation? You can keep FluentValidation throwing <code>ValidationException</code> (caught by middleware) or map validation failures into <code>Result</code> by projecting <code>ValidationFailure</code> into <code>Error</code> inside handlers/behaviors.</li> <li>Can I log errors automatically? Yes\u2014hook your logger adapter to inspect <code>Result</code> failures and emit logs enriched by <code>TraceId</code> and <code>Metadata</code>. The Core logging abstractions keep this decoupled from MediatR.</li> </ul>"},{"location":"extensions/core-result-primitives/#step-by-step-adoption-plan","title":"Step-by-step adoption plan","text":"<p>1) Add the package and register Core pipeline behaviors (Correlation, Logging, Performance) plus <code>IClock</code>, <code>ILogContext</code>, and logger adapters. 2) Wrap new handlers that benefit from structured errors in <code>Result&lt;T&gt;</code>; start with operations exposed to external clients or sensitive domains (payments, identity). 3) Introduce guards as the first layer in handlers to replace ad-hoc <code>if</code>/throws. Configure <code>GuardStrategy</code> globally via <code>CoreExtensionsOptions</code>. 4) Unify error codes across teams; codify them in a shared static class or constants to avoid drift. 5) Bridge Identity/legacy flows with adapters so you can defer broader refactors while gaining correlation and metadata where you need it.</p>"},{"location":"extensions/core-result-primitives/#reference-type-summaries","title":"Reference: Type summaries","text":"<ul> <li><code>Result</code>: success/failure envelope, trace ID, immutable <code>IReadOnlyList&lt;Error&gt;</code>. Factory methods and <code>Combine</code>.</li> <li><code>Result&lt;T&gt;</code>: extends <code>Result</code> with <code>Value</code>, <code>ValueOrDefault</code>, <code>Map</code>, <code>Bind</code>, <code>Tap</code>, <code>Ensure</code>, <code>Match</code>, and overrides <code>Failure</code> factories to attach trace IDs.</li> <li><code>Error</code>: structured error data with helpers to clone metadata or trace IDs; <code>None</code> sentinel for convenience.</li> <li><code>ResultExtensions</code>: <code>Ensure</code> for non-generic results, <code>ToResult</code> wrappers, and <code>Recover</code>.</li> </ul>"},{"location":"extensions/core-result-primitives/#example-test-asserting-failures-and-metadata","title":"Example test: asserting failures and metadata","text":"<pre><code>[Fact]\npublic void Recover_ReturnsFallbackOnFailure()\n{\n    var error = new Error(\"billing.credit-limit\", \"Insufficient credit\", traceId: \"req-42\");\n    var failed = Result.Failure&lt;int&gt;(error);\n\n    var recovered = failed.Recover(errors =&gt; errors.Count);\n\n    recovered.IsSuccess.Should().BeTrue();\n    recovered.Value.Should().Be(1);\n    recovered.TraceId.Should().Be(\"req-42\");\n}\n</code></pre>"},{"location":"extensions/core-result-primitives/#related-docs","title":"Related docs","text":"<ul> <li>Core extension overview for guard clauses, pipeline behaviors, logging, time, and domain events.</li> <li>Validation extension when you need FluentValidation-first behaviors that complement or replace guard/result flows.</li> </ul>"},{"location":"extensions/core-time/","title":"Core Time Abstractions","text":"<p>Time is a cross-cutting concern in Jason Taylor\u2019s Clean Architecture template. The template uses <code>TimeProvider</code> inside the EF Core <code>AuditableEntityInterceptor</code> to stamp <code>Created</code>/<code>LastModified</code> and uses <code>Stopwatch</code> in <code>PerformanceBehaviour</code> for timing. The Core extension introduces a unified <code>IClock</code> abstraction with system, frozen, and offset implementations, plus GUID generation and async delay, so you can keep tests deterministic, inject time consistently across layers, and align correlation/timing with other Core primitives.</p>"},{"location":"extensions/core-time/#what-the-template-already-covers","title":"What the template already covers","text":"<ul> <li>Auditing: <code>AuditableEntityInterceptor</code> injects <code>TimeProvider</code> to set <code>Created</code>/<code>LastModified</code> timestamps in <code>BaseAuditableEntity</code>.</li> <li>Performance: <code>PerformanceBehaviour</code> (template) uses a <code>Stopwatch</code> directly to time handlers; no configuration or correlation metadata is attached.</li> <li>No clock abstraction: Outside of the interceptor, handlers often call <code>DateTime.UtcNow</code> directly. There\u2019s no interface to mock or offset time across the app.</li> </ul>"},{"location":"extensions/core-time/#what-core-adds","title":"What Core adds","text":"<ul> <li><code>IClock</code> interface: Provides <code>UtcNow</code>, <code>Today</code>, <code>Timestamp</code>, <code>NewGuid()</code>, and async <code>Delay(...)</code>.</li> <li>Implementations: </li> <li><code>SystemClock</code> wraps system time + <code>Stopwatch</code> and GUID generation.</li> <li><code>FrozenClock</code> for deterministic tests; time advances only when you call <code>Advance</code>.</li> <li><code>OffsetClock</code> applies a fixed offset to an inner clock (simulate time zones or \u201ctime travel\u201d for testing).</li> <li>Consistency: Behaviors (logging/performance), guards, results, and correlation flows can share the same clock, improving determinism and observability.</li> <li>Testability: No more scattered <code>DateTime.UtcNow</code>; inject <code>IClock</code> and use <code>FrozenClock</code> in tests to avoid flakiness.</li> </ul>"},{"location":"extensions/core-time/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.Time</code></p> <ul> <li><code>IClock</code></li> <li><code>DateTimeOffset UtcNow { get; }</code></li> <li><code>DateOnly Today { get; }</code></li> <li><code>long Timestamp { get; }</code></li> <li><code>Guid NewGuid();</code></li> <li><code>Task Delay(TimeSpan delay, CancellationToken cancellationToken = default);</code></li> <li>Implementations:</li> <li><code>SystemClock</code></li> <li><code>FrozenClock</code></li> <li><code>OffsetClock</code></li> </ul>"},{"location":"extensions/core-time/#why-this-matters-for-clean-architecture","title":"Why this matters for Clean Architecture","text":"<ul> <li>Layer decoupling: Application/Domain code depends on <code>IClock</code>, not <code>DateTime.UtcNow</code> or <code>TimeProvider</code>. Infrastructure can wrap <code>TimeProvider.System</code> or other sources as needed.</li> <li>Deterministic tests: Use <code>FrozenClock</code> to freeze time and advance manually; assert timestamps, elapsed durations, and GUID flows without relying on real time.</li> <li>Correlation alignment: Behaviors and handlers can share <code>IClock.NewGuid()</code> for correlation IDs if desired, keeping randomness under one abstraction.</li> <li>Simulation: <code>OffsetClock</code> helps simulate different time zones or daylight savings impacts without changing system time.</li> </ul>"},{"location":"extensions/core-time/#wiring-in-di","title":"Wiring in DI","text":"<p><pre><code>services.AddSingleton&lt;IClock, SystemClock&gt;(); // default\n</code></pre> For tests, override with <code>FrozenClock</code> or <code>OffsetClock</code> via DI configuration: <pre><code>services.AddSingleton&lt;IClock&gt;(_ =&gt; new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\")));\n</code></pre></p>"},{"location":"extensions/core-time/#sample-backed-walkthrough-time-sample","title":"Sample-backed walkthrough (time sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Time.Sample</code>.</p>"},{"location":"extensions/core-time/#snapshot-current-time-with-iclock","title":"Snapshot current time with <code>IClock</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Time.Sample/src/Application/Diagnostics/Queries/GetTimeSnapshot/GetTimeSnapshotQuery.cs</code>: <pre><code>var guid = _clock.NewGuid();\nvar now = _clock.UtcNow;\nvar today = _clock.Today;\n\nvar snapshot = new TimeSnapshotDto(now, today, _clock.Timestamp, guid, null);\n</code></pre> - Exposed via <code>GET /api/Diagnostics/time</code> to show <code>UtcNow</code>, <code>Today</code>, a timestamp, and a GUID sourced from the clock.</p>"},{"location":"extensions/core-time/#delay-without-sleeping-in-tests","title":"Delay without sleeping in tests","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Time.Sample/src/Application/Diagnostics/Commands/SimulateDelay/SimulateDelayCommand.cs</code>: <pre><code>var started = _clock.UtcNow;\nawait _clock.Delay(delay, cancellationToken);\nvar ended = _clock.UtcNow;\nvar observed = ended - started;\n</code></pre> - <code>POST /api/Diagnostics/delay</code> echoes requested/observed delays; with <code>SystemClock</code> it really waits, while tests swap in <code>FrozenClock</code> so time advances instantly.</p>"},{"location":"extensions/core-time/#deterministic-tests-with-frozenclock","title":"Deterministic tests with <code>FrozenClock</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Time.Sample/tests/Application.UnitTests/Diagnostics/TimeDiagnosticsTests.cs</code>: <pre><code>var clock = new FrozenClock(fixedTime);\nvar handler = new GetTimeSnapshotQueryHandler(clock);\nvar result = await handler.Handle(new GetTimeSnapshotQuery(), CancellationToken.None);\n\nresult.UtcNow.ShouldBe(fixedTime);\nresult.EndedAtUtc.ShouldBe(fixedTime.AddMilliseconds(250)); // after simulated delay\n</code></pre> - Demonstrates advancing <code>FrozenClock</code> via <code>Delay</code> without real waits, keeping handler assertions deterministic.</p>"},{"location":"extensions/core-time/#adapting-the-templates-auditing-interceptor","title":"Adapting the template\u2019s auditing interceptor","text":"<p>You can keep the existing <code>AuditableEntityInterceptor</code> but inject <code>IClock</code> to stay consistent: <pre><code>public class AuditableEntityInterceptor : SaveChangesInterceptor\n{\n    private readonly IUser _user;\n    private readonly IClock _clock;\n\n    public AuditableEntityInterceptor(IUser user, IClock clock)\n    {\n        _user = user;\n        _clock = clock;\n    }\n\n    public override InterceptionResult&lt;int&gt; SavingChanges(DbContextEventData eventData, InterceptionResult&lt;int&gt; result)\n    {\n        UpdateEntities(eventData.Context);\n        return base.SavingChanges(eventData, result);\n    }\n\n    public override ValueTask&lt;InterceptionResult&lt;int&gt;&gt; SavingChangesAsync(DbContextEventData eventData, InterceptionResult&lt;int&gt; result, CancellationToken cancellationToken = default)\n    {\n        UpdateEntities(eventData.Context);\n        return base.SavingChangesAsync(eventData, result, cancellationToken);\n    }\n\n    private void UpdateEntities(DbContext? context)\n    {\n        if (context == null) return;\n\n        foreach (var entry in context.ChangeTracker.Entries&lt;BaseAuditableEntity&gt;())\n        {\n            if (entry.State is EntityState.Added or EntityState.Modified || entry.HasChangedOwnedEntities())\n            {\n                var utcNow = _clock.UtcNow;\n                if (entry.State == EntityState.Added)\n                {\n                    entry.Entity.CreatedBy = _user.Id;\n                    entry.Entity.Created = utcNow;\n                }\n                entry.Entity.LastModifiedBy = _user.Id;\n                entry.Entity.LastModified = utcNow;\n            }\n        }\n    }\n}\n</code></pre> - Swap <code>TimeProvider</code> for <code>IClock</code> to keep auditing consistent with the rest of Core.</p>"},{"location":"extensions/core-time/#using-iclock-in-pipeline-behaviors","title":"Using <code>IClock</code> in pipeline behaviors","text":"<p>Core behaviors already depend on <code>IClock</code>: - <code>LoggingBehavior</code> uses <code>UtcNow</code> to timestamp start logs and <code>NewGuid</code> to seed correlation when missing. - <code>PerformanceBehavior</code> uses <code>UtcNow</code> to measure elapsed; configurable thresholds live in <code>CoreExtensionsOptions</code>. - This ensures performance logs and correlation IDs can be deterministic in tests (swap in <code>FrozenClock</code>).</p>"},{"location":"extensions/core-time/#patterns-and-examples","title":"Patterns and examples","text":""},{"location":"extensions/core-time/#1-deterministic-tests-with-frozenclock","title":"1) Deterministic tests with FrozenClock","text":"<p><pre><code>[Fact]\npublic async Task Delay_Advances_FrozenClock()\n{\n    var clock = new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\"));\n    await clock.Delay(TimeSpan.FromSeconds(5));\n    clock.UtcNow.Should().Be(DateTimeOffset.Parse(\"2025-01-01T00:00:05Z\"));\n    clock.Timestamp.Should().Be(TimeSpan.FromSeconds(5).Ticks);\n}\n</code></pre> - <code>Delay</code> advances time immediately without sleeping; great for timeout/retry logic tests.</p>"},{"location":"extensions/core-time/#2-time-zone-simulation-with-offsetclock","title":"2) Time zone simulation with OffsetClock","text":"<p><pre><code>var utcClock = new SystemClock();\nvar estClock = new OffsetClock(utcClock, TimeSpan.FromHours(-5));\nvar estNow = estClock.UtcNow; // effectively UTC-5 view\n</code></pre> - Useful when you need to display or test region-specific dates without altering system time.</p>"},{"location":"extensions/core-time/#3-injecting-clock-into-domain-services","title":"3) Injecting clock into domain services","text":"<p><pre><code>public sealed class TokenService\n{\n    private readonly IClock _clock;\n    public TokenService(IClock clock) =&gt; _clock = clock;\n\n    public TokenIssueResult Issue(string subject)\n    {\n        var issuedAt = _clock.UtcNow;\n        var expires = issuedAt.AddMinutes(30);\n        var token = _clock.NewGuid().ToString(\"N\");\n        return new TokenIssueResult(token, issuedAt, expires);\n    }\n}\n</code></pre> - No static <code>DateTime.UtcNow</code>; tests can assert exact timestamps with <code>FrozenClock</code>.</p>"},{"location":"extensions/core-time/#4-combining-with-results-for-expiration","title":"4) Combining with Results for expiration","text":"<p><pre><code>public Result ValidateNotExpired(DateTimeOffset expiresAt, IClock clock)\n{\n    return clock.UtcNow &lt;= expiresAt\n        ? Result.Success()\n        : Result.Failure(new Error(\"token.expired\", \"Token is expired\", traceId: null));\n}\n</code></pre> - Using the clock keeps logic testable and consistent with behaviors.</p>"},{"location":"extensions/core-time/#5-using-timestamp-for-perf-without-stopwatch","title":"5) Using Timestamp for perf without Stopwatch","text":"<p>If you prefer high-resolution ticks: <pre><code>var start = _clock.Timestamp;\n// do work\nvar elapsedTicks = _clock.Timestamp - start;\nvar elapsedMs = elapsedTicks * 1000.0 / Stopwatch.Frequency;\n</code></pre> - <code>SystemClock.Timestamp</code> delegates to <code>Stopwatch.GetTimestamp</code>; tests can override with <code>FrozenClock</code> if you set <code>_timestamp</code> appropriately when advancing.</p>"},{"location":"extensions/core-time/#interop-and-migration-tips","title":"Interop and migration tips","text":"<ul> <li>From <code>DateTime.UtcNow</code>: Inject <code>IClock</code> where you need time. For minimal code churn, add a constructor parameter and assign to a private field; replace calls to <code>DateTime.UtcNow</code> with <code>_clock.UtcNow</code>.</li> <li>From <code>TimeProvider</code>: Create an adapter that implements <code>IClock</code> by delegating to <code>TimeProvider</code>: <pre><code>public sealed class TimeProviderClock : IClock\n{\n    private readonly TimeProvider _provider;\n    public TimeProviderClock(TimeProvider provider) =&gt; _provider = provider;\n\n    public DateTimeOffset UtcNow =&gt; _provider.GetUtcNow();\n    public DateOnly Today =&gt; DateOnly.FromDateTime(_provider.GetUtcNow().UtcDateTime);\n    public long Timestamp =&gt; _provider.GetTimestamp();\n    public Guid NewGuid() =&gt; Guid.NewGuid();\n    public Task Delay(TimeSpan delay, CancellationToken cancellationToken = default) =&gt;\n        _provider.Delay(delay, cancellationToken);\n}\n</code></pre></li> <li>Register <code>TimeProviderClock</code> in Infrastructure if you rely on <code>TimeProvider</code> elsewhere.</li> </ul>"},{"location":"extensions/core-time/#correlation-alignment","title":"Correlation alignment","text":"<ul> <li>If you want correlation IDs to be GUIDs generated by the same source, use <code>IClock.NewGuid()</code> in <code>CorrelationBehavior</code> (as Core does by default). This keeps randomness and time abstractions under one roof.</li> <li>For deterministic correlation in tests, seed <code>FrozenClock</code> and use <code>NewGuid</code> from a predictable GUID source if needed (e.g., inject a GUID factory or extend <code>FrozenClock</code>).</li> </ul>"},{"location":"extensions/core-time/#configuration-touchpoints","title":"Configuration touchpoints","text":"<p>Time itself has no options in <code>CoreExtensionsOptions</code>, but it influences behaviors that have options (<code>PerformanceWarningThreshold</code>, <code>EnablePerformanceLogging</code>, <code>CorrelationIdFactory</code>). Use <code>IClock</code> consistently to avoid divergence between time and correlation behaviors.</p>"},{"location":"extensions/core-time/#testing-guidance","title":"Testing guidance","text":"<ul> <li>Use <code>FrozenClock</code> in unit tests for services/handlers that depend on time.</li> <li>Use <code>OffsetClock</code> to test date boundary conditions (end-of-day, DST transitions).</li> <li>For integration tests of performance logging, pair <code>FrozenClock</code> with <code>InMemoryAppLogger</code> to assert elapsed times and correlation IDs.</li> </ul>"},{"location":"extensions/core-time/#faq","title":"FAQ","text":"<ul> <li>Does <code>FrozenClock</code> auto-advance? Only when you call <code>Advance</code> or <code>Delay</code>. It will not change on its own.</li> <li>Is <code>OffsetClock</code> thread-safe? It delegates to an inner clock; thread safety follows the inner implementation. <code>SystemClock</code> is thread-safe; <code>FrozenClock</code> uses simple fields and is safe for typical test usage.</li> <li>Should domain entities depend on <code>IClock</code>? Prefer passing timestamps into entities from services/handlers to keep entities pure. Factories can receive <code>IClock</code> and pass values to entity constructors.</li> <li>Can I mock <code>IClock</code> manually? Yes\u2014implement a test double or use a mocking framework; the interface is small.</li> </ul>"},{"location":"extensions/core-time/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Register <code>IClock</code> (SystemClock by default) in DI. 2) Swap time usages in Application/Infrastructure to <code>IClock</code> (auditing interceptor, handlers, services). 3) For tests, replace registration with <code>FrozenClock</code> or <code>OffsetClock</code>. 4) Align performance logging and correlation behaviors to use the injected clock (already true for Core behaviors). 5) Consider a <code>TimeProviderClock</code> adapter if your Infrastructure already relies on <code>TimeProvider</code>.</p>"},{"location":"extensions/core-time/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for performance/correlation that depend on <code>IClock</code>.</li> <li>Core logging abstractions where correlation may use <code>IClock.NewGuid()</code>.</li> <li>Core result primitives for aligning trace IDs with correlation/time flows.</li> <li>Core guard clauses and Core domain events to see how time can interplay with validation and event stamping.</li> <li>Core extension overview for the package summary and registration guidance.</li> </ul>"},{"location":"extensions/core/","title":"Extension: Core","text":""},{"location":"extensions/core/#why-this-package-exists","title":"Why this package exists","text":"<p>Jason Taylor\u2019s Clean Architecture template ships a thin set of primitives: a minimal <code>Result</code> (bool + string array), MediatR behaviors for logging/validation/authorization/performance, domain-event plumbing via EF Core interceptors, Microsoft.Extensions.Logging abstractions, and <code>TimeProvider</code> for auditing. Those building blocks are intentionally small so the template stays approachable, but teams often need richer primitives (correlation, error metadata, deterministic time, test-friendly logging) without rewriting the template. The Core extension keeps you aligned with Jason\u2019s wiring while supplying opinionated, dependency-light upgrades:</p> <ul> <li>Rich <code>Result</code>/<code>Error</code> types with trace IDs, metadata, and composition helpers.</li> <li>Guard clauses that return results, throw, or accumulate errors.</li> <li>Pipeline behaviors that preserve the template\u2019s order/signatures while adding correlation scopes and structured logging.</li> <li>Logging abstractions (<code>IAppLogger&lt;T&gt;</code>, <code>ILogContext&gt;</code>) decoupled from any provider, plus in-memory/no-op implementations for tests.</li> <li>Domain event base types and a tracker for dispatch pipelines beyond EF interceptors.</li> <li>Time abstraction (<code>IClock</code>) that wraps <code>TimeProvider</code> concepts and unlocks deterministic clocks.</li> </ul> <p>If you want a deep dive into Results specifically, see Result primitives. The rest of this page orients you to everything in the Core package.</p>"},{"location":"extensions/core/#alignment-with-the-template","title":"Alignment with the template","text":"<ul> <li>Result: In the template (<code>src/Application/Common/Models/Result.cs</code>), success is a boolean with <code>string[] Errors</code>. It is used primarily by the Identity service (<code>IdentityService.ToApplicationResult</code>, <code>DeleteUserAsync</code>). There is no correlation metadata or value payload. Core keeps the pattern (success/failure) but adds trace IDs, error codes/messages/metadata, and generic payloads.</li> <li>Pipeline behaviors: The template wires <code>LoggingBehaviour</code> (pre-processor), <code>UnhandledExceptionBehaviour</code>, <code>AuthorizationBehaviour</code>, <code>ValidationBehaviour</code>, and <code>PerformanceBehaviour</code> in <code>DependencyInjection.cs</code>. Core behaviors mirror these signatures so you can swap without changing registrations, while layering correlation scopes and structured properties.</li> <li>Domain events: Template entities derive from <code>BaseEntity</code> and raise <code>BaseEvent</code> (INotification). EF\u2019s <code>DispatchDomainEventsInterceptor</code> drains events and publishes via MediatR on SaveChanges. Core keeps the MediatR-friendly event shape and supplies a <code>DomainEventTracker</code> plus <code>IDomainEventDispatcher</code> abstraction for alternate dispatch pipelines (e.g., outbox, bus).</li> <li>Time: Template uses <code>TimeProvider</code> inside <code>AuditableEntityInterceptor</code> to stamp <code>Created</code>/<code>LastModified</code>. Core\u2019s <code>IClock</code> wraps similar capabilities (<code>UtcNow</code>, <code>Today</code>, <code>Timestamp</code>, <code>Delay</code>, <code>NewGuid</code>) with test clocks and offsets.</li> <li>Logging: Template relies on <code>ILogger&lt;T&gt;</code>, <code>IUser</code>, and <code>IIdentityService</code> to enrich logs. Core introduces provider-agnostic logging + context abstractions so you can plug in Serilog, MEL, or in-memory loggers without coupling application code to a specific provider.</li> </ul>"},{"location":"extensions/core/#package-contents-what-you-get","title":"Package contents (what you get)","text":""},{"location":"extensions/core/#result-primitives-summary","title":"Result primitives (summary)","text":"<ul> <li><code>Result</code> and <code>Result&lt;T&gt;</code> capture success/failure, <code>TraceId</code>, and <code>IReadOnlyList&lt;Error&gt;</code>.</li> <li><code>Error</code> holds <code>Code</code>, <code>Message</code>, optional <code>Metadata</code>, and helpers to attach trace IDs.</li> <li>Composition helpers: <code>Map</code>, <code>Bind</code>, <code>Tap</code>, <code>Ensure</code>, <code>Recover</code>, <code>Combine</code>, plus convenience conversions (<code>ToResult</code>).</li> <li>All primitives live in <code>CleanArchitecture.Extensions.Core.Results</code> and avoid external dependencies.</li> <li>Deep dive: Result primitives.</li> </ul>"},{"location":"extensions/core/#guard-clauses","title":"Guard clauses","text":"<ul> <li><code>Guard</code> static helpers: null/whitespace, enum, range, min/max length, boolean <code>Ensure</code>.</li> <li><code>GuardOptions</code> lets you pick a strategy per call: <code>ReturnFailure</code> (default), <code>Throw</code>, or <code>Accumulate</code> (push into an <code>ErrorSink</code> collection).</li> <li>Trace IDs propagate from options so guard failures stay correlated with the request.</li> <li><code>GuardStrategy</code> enum documents strategies and can be derived from shared <code>CoreExtensionsOptions</code>.</li> <li>Deep dive: Core Guard Clauses.</li> </ul>"},{"location":"extensions/core/#pipeline-behaviors","title":"Pipeline behaviors","text":"<ul> <li>CorrelationBehavior: Ensures a correlation ID exists (uses <code>CoreExtensionsOptions.CorrelationIdFactory</code> or clock-based GUID), pushes it to <code>ILogContext</code>, and preserves scope for downstream logs.</li> <li>Logging: <code>LoggingPreProcessor&lt;TRequest&gt;</code> logs start-of-request; <code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> logs handling/handled with correlation and request type.</li> <li>PerformanceBehavior: Measures elapsed time via <code>IClock</code>, emits warnings when <code>PerformanceWarningThreshold</code> is exceeded, can be toggled with <code>EnablePerformanceLogging</code>.</li> <li>Ordering guidance (matching the template\u2019s intent): <code>Correlation</code> \u2192 <code>Logging (pre)</code> \u2192 <code>UnhandledException</code> \u2192 <code>Authorization</code> \u2192 <code>Validation</code> \u2192 <code>Performance</code> \u2192 Handler. Insert Core behaviors accordingly to maintain compatibility.</li> <li>Deep dive: Core Pipeline Behaviors.</li> </ul>"},{"location":"extensions/core/#logging-abstractions","title":"Logging abstractions","text":"<ul> <li><code>IAppLogger&lt;T&gt;</code> mirrors <code>ILogger&lt;T&gt;</code> severity levels but keeps the surface minimal; overloads for Trace/Debug/Info/Warn/Error/Critical delegate to <code>Log</code>.</li> <li><code>ILogContext</code> stores <code>CorrelationId</code> and supports <code>PushProperty</code> to enrich structured logs. You can wrap <code>ILogger.BeginScope</code> or Serilog\u2019s <code>LogContext</code> in your adapter.</li> <li>Implementations: <code>NoOpAppLogger&lt;T&gt;</code> for silent runs, <code>InMemoryAppLogger&lt;T&gt;</code> + <code>InMemoryLogContext</code> for tests/diagnostics, <code>NoOpLogContext</code> as a stand-in when scope handling is optional.</li> <li>Deep dive: Core Logging Abstractions.</li> </ul>"},{"location":"extensions/core/#domain-events","title":"Domain events","text":"<ul> <li><code>DomainEvent</code> base record (INotification) with <code>Id</code>, <code>OccurredOnUtc</code>, and optional <code>CorrelationId</code>.</li> <li><code>DomainEventTracker</code> buffers events until dispatched; <code>Drain</code> returns a snapshot and clears, mirroring EF interceptor behavior while enabling non-EF dispatch paths.</li> <li><code>IDomainEventDispatcher</code> abstraction so Infrastructure can publish to MediatR, a message bus, or an outbox without changing Application.</li> <li>Deep dive: Core Domain Events.</li> </ul>"},{"location":"extensions/core/#time","title":"Time","text":"<ul> <li><code>IClock</code> abstraction with <code>UtcNow</code>, <code>Today</code>, <code>Timestamp</code>, <code>NewGuid</code>, and async <code>Delay</code>.</li> <li>Implementations: <code>SystemClock</code> (live), <code>FrozenClock</code> (manually advance for tests), <code>OffsetClock</code> (apply fixed offset to an inner clock). Aligns with <code>TimeProvider</code> semantics but adds GUID generation for correlation and deterministic tests.</li> <li>Deep dive: Core Time.</li> </ul>"},{"location":"extensions/core/#options","title":"Options","text":"<ul> <li><code>CoreExtensionsOptions</code> gathers cross-cutting defaults: correlation header name, guard strategy, performance logging toggle/threshold, correlation ID factory, and a default <code>TraceId</code> to flow into guards/results.</li> <li><code>GuardOptions.FromOptions</code> lets you hydrate guard config from shared options while providing per-call sinks.</li> <li>Deep dive: Core Options.</li> </ul>"},{"location":"extensions/core/#install","title":"Install","text":"<pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Core\n</code></pre>"},{"location":"extensions/core/#integration-guide-application-layer","title":"Integration guide (Application layer)","text":"<ol> <li>Register clocks, log context, and logger:</li> </ol> <pre><code>services.AddSingleton&lt;IClock, SystemClock&gt;();\nservices.AddScoped&lt;ILogContext, InMemoryLogContext&gt;(); // replace with Serilog/MEL adapter\nservices.AddScoped(typeof(IAppLogger&lt;&gt;), typeof(NoOpAppLogger&lt;&gt;)); // swap with your provider adapter\n</code></pre> <ol> <li>Wire pipeline behaviors: keep template order; prefer correlation first.</li> </ol> <pre><code>services.AddScoped(typeof(IPipelineBehavior&lt;,&gt;), typeof(CorrelationBehavior&lt;,&gt;));\nservices.AddScoped(typeof(IRequestPreProcessor&lt;&gt;), typeof(LoggingPreProcessor&lt;&gt;)); // pre-processor registration\nservices.AddScoped(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));\nservices.AddScoped(typeof(IPipelineBehavior&lt;,&gt;), typeof(PerformanceBehavior&lt;,&gt;));\n</code></pre> <ol> <li>Configure options: align with your transports/logging/search queries.</li> </ol> <pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(configuration.GetSection(\"Extensions:Core\"));\n</code></pre> <ol> <li>Adopt Results + guards in handlers: return <code>Result&lt;T&gt;</code> from commands/queries; compose with guards and validation.</li> </ol> <pre><code>var nameResult = Guard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name),\n    GuardOptions.FromOptions(options.Value));\nif (nameResult.IsFailure) return Result.Failure&lt;string&gt;(nameResult.Errors, nameResult.TraceId);\n\nvar created = await _repository.CreateAsync(nameResult.Value, cancellationToken);\nreturn Result.Success(created.Id, nameResult.TraceId);\n</code></pre>"},{"location":"extensions/core/#compatibility-notes","title":"Compatibility notes","text":"<ul> <li>Drop-in for template behaviors: Signatures are compatible with <code>cfg.AddOpenBehavior</code> and <code>AddOpenRequestPreProcessor</code> in the template DI (<code>LoggingPreProcessor</code> for pre-processing, <code>LoggingBehavior</code> for pipeline). Swap registrations without changing handlers.</li> <li>Interop with existing Result: You can map template <code>Result</code> to/from Core\u2019s <code>Result</code> by projecting errors into <code>Error</code> codes/messages and vice versa (e.g., <code>Result.Success().Errors</code> \u2192 <code>Result.Success(traceId)</code>).</li> <li>EF interceptors: <code>DomainEventTracker</code> can complement <code>DispatchDomainEventsInterceptor</code>; use the tracker when you need to buffer events outside DbContext lifetime or forward to a bus/outbox.</li> <li>Time/Auditing: Replace <code>TimeProvider</code> injections with <code>IClock</code> adapters that internally call <code>TimeProvider.System</code> if you need 1:1 behavior.</li> </ul>"},{"location":"extensions/core/#configuration-reference","title":"Configuration reference","text":"<p><code>appsettings.json</code> example:</p> <pre><code>{\n  \"Extensions\": {\n    \"Core\": {\n      \"CorrelationHeaderName\": \"X-Correlation-ID\",\n      \"GuardStrategy\": \"ReturnFailure\",\n      \"EnablePerformanceLogging\": true,\n      \"PerformanceWarningThreshold\": \"00:00:00.500\",\n      \"TraceId\": null\n    }\n  }\n}\n</code></pre> <ul> <li>CorrelationHeaderName: match your API gateway/clients.</li> <li>GuardStrategy: choose <code>ReturnFailure</code> for handler-friendly results, <code>Throw</code> when using middleware to translate exceptions, <code>Accumulate</code> for batch validations.</li> <li>PerformanceWarningThreshold: keep 500 ms to mirror template defaults; tune for your SLOs.</li> <li>TraceId: set when upstream (API) passes a trace/correlation token you want to propagate through results and guard errors.</li> </ul>"},{"location":"extensions/core/#troubleshooting-adoption-tips","title":"Troubleshooting &amp; adoption tips","text":"<ul> <li>Missing correlation ID in logs: ensure <code>ILogContext</code> is scoped, <code>CorrelationBehavior</code> runs before logging, and your logger adapter copies <code>ILogContext.CorrelationId</code> into scopes/enrichers.</li> <li>Performance logs silent: confirm <code>EnablePerformanceLogging</code> is true and behavior is registered; ensure <code>IClock</code> returns consistent <code>UtcNow</code>.</li> <li>Guard exceptions unexpected: switch strategy to <code>ReturnFailure</code> or <code>Accumulate</code>; when throwing, set <code>ExceptionFactory</code> to shape domain-specific exceptions.</li> <li>Too many <code>Result</code>-wrapped signatures: keep simple commands/queries returning primitives until you need rich errors; adopt Core Results incrementally via adapters.</li> </ul>"},{"location":"extensions/core/#what-to-read-next","title":"What to read next","text":"<ul> <li>Deep dive on results, composition patterns, and real-world handlers: Result primitives.</li> <li>For validation-focused behaviors and FluentValidation hand-offs, see Validation extension.</li> <li>Multitenancy-specific pipeline glue lives in Multitenancy Core; it composes with the Core behaviors described here.</li> </ul>"},{"location":"extensions/multitenancy-core/","title":"Extension: Multitenancy Core","text":""},{"location":"extensions/multitenancy-core/#overview","title":"Overview","text":"<p>Tenant context and resolution primitives for Clean Architecture solutions.</p>"},{"location":"extensions/multitenancy-core/#when-to-use","title":"When to use","text":"<ul> <li>You need per-tenant isolation (data access, caching, authorization).</li> <li>You want pluggable tenant resolution strategies (host/header/route/claims).</li> </ul>"},{"location":"extensions/multitenancy-core/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target .NET: TBD</li> <li>CleanArchitecture template: TBD</li> <li>Dependencies: TBD</li> </ul>"},{"location":"extensions/multitenancy-core/#install","title":"Install","text":"<p>`\bash</p>"},{"location":"extensions/multitenancy-core/#replace-with-actual-package-name-when-published","title":"replace with actual package name when published","text":"<p>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Multitenancy `</p>"},{"location":"extensions/multitenancy-core/#usage","title":"Usage","text":"<ul> <li>Register tenant resolution middleware/providers.</li> <li>Flow TenantId through application services and persistence.</li> <li>Add behaviors/filters to enforce tenant scope.</li> </ul>"},{"location":"extensions/multitenancy-core/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure a tenant resolution strategy is configured; fallbacks should be explicit.</li> <li>Log resolved tenant identifiers and resolution source for diagnostics.</li> </ul>"},{"location":"extensions/multitenancy-core/#samples-tests","title":"Samples &amp; Tests","text":"<ul> <li>Link to runnable sample (add when available).</li> <li>Link to related tests once published.</li> </ul>"},{"location":"extensions/validation/","title":"Extension: Validation","text":""},{"location":"extensions/validation/#overview","title":"Overview","text":"<p>Validation pipeline and helpers built on FluentValidation for Clean Architecture solutions. Ships a configurable MediatR behaviour, a template-shaped <code>ValidationException</code>, rule helpers, and a base validator that applies common conventions. Designed to be drop-in compatible with Jason Taylor\u2019s template while enabling Result-based short-circuiting when desired.</p>"},{"location":"extensions/validation/#when-to-use","title":"When to use","text":"<ul> <li>You follow the template\u2019s MediatR pipeline and want richer control over how validation failures surface (throw vs Result vs notify).</li> <li>You need shared validator conventions and basic rule helpers for identifiers, paging, and email without re-writing boilerplate.</li> <li>You want compatibility with existing <code>ValidationException</code> handling (dictionary of property -&gt; messages) but also want to map failures to <code>Result</code>.</li> </ul>"},{"location":"extensions/validation/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target frameworks: <code>net10.0</code> (current).</li> <li>Dependencies: FluentValidation <code>12.1.0</code>, MediatR <code>13.1.0</code>.</li> <li>Template fit: register the behavior in Application after Authorization and before Performance, same signature as the template\u2019s <code>ValidationBehaviour&lt;,&gt;</code>.</li> </ul>"},{"location":"extensions/validation/#install","title":"Install","text":"<pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Validation\n</code></pre>"},{"location":"extensions/validation/#usage","title":"Usage","text":""},{"location":"extensions/validation/#wire-up-validators-and-behaviour-di","title":"Wire up validators and behaviour (DI)","text":"<pre><code>services.AddValidatorsFromAssemblyContaining&lt;Startup&gt;(); // or your Application assembly marker\nservices.AddScoped(typeof(IPipelineBehavior&lt;,&gt;), typeof(ValidationBehaviour&lt;,&gt;));\n\n// Optional: configure strategy/options\nservices.Configure&lt;ValidationOptions&gt;(options =&gt;\n{\n    options.Strategy = ValidationStrategy.Throw; // default to template behavior\n    options.MaxFailures = 50;\n    options.IncludeAttemptedValue = false;\n});\n</code></pre>"},{"location":"extensions/validation/#strategies","title":"Strategies","text":"<ul> <li><code>Throw</code> (default): matches template; throws <code>ValidationException</code> with <code>Dictionary&lt;string,string[]&gt;</code>.</li> <li><code>ReturnResult</code>: short-circuits with <code>Result.Failure</code>/<code>Result&lt;T&gt;.Failure</code> when handlers return <code>Result</code>.</li> <li><code>Notify</code>: publishes via <code>IValidationNotificationPublisher</code> then either throws or returns <code>Result</code> based on <code>NotifyBehavior</code>.</li> </ul> <p>Key options: <code>MaxFailures</code>, <code>IncludePropertyName</code>, <code>IncludeAttemptedValue</code>, <code>IncludePlaceholderValues</code>, <code>DefaultErrorCode</code>, <code>TraceId</code>, <code>ErrorCodeSelector</code>, <code>MessageFormatter</code>.</p>"},{"location":"extensions/validation/#error-model","title":"Error model","text":"<ul> <li><code>ValidationError</code> maps FluentValidation failures to Core <code>Error</code>, carrying code, message, property, attempted value (opt-in), severity, and metadata.</li> <li><code>ValidationException</code> is provided for compatibility with the template\u2019s shape and can be thrown by the behavior.</li> </ul>"},{"location":"extensions/validation/#base-validator-rules","title":"Base validator + rules","text":"<ul> <li><code>AbstractValidatorBase&lt;T&gt;</code> sets rule-level cascade to fail fast per chain.</li> <li><code>Rules/CommonRules</code> helpers:</li> <li><code>NotEmptyTrimmed</code></li> <li><code>EmailAddressBasic</code></li> <li><code>OptionalEmailAddress</code></li> <li><code>PositiveId</code></li> <li><code>PageNumber</code></li> <li><code>PageSize</code></li> <li><code>PhoneE164</code></li> <li><code>UrlAbsoluteHttpHttps</code></li> <li><code>CultureCode</code></li> <li><code>SortExpression</code> (whitelist allowed fields)</li> <li>Tenant-aware rules (planned with the Multitenancy module)</li> </ul>"},{"location":"extensions/validation/#result-short-circuit-example","title":"Result short-circuit example","text":"<pre><code>var options = new ValidationOptions { Strategy = ValidationStrategy.ReturnResult };\nvar behavior = new ValidationBehaviour&lt;CreateTodo, Result&lt;TodoVm&gt;&gt;(validators, options);\n// When validation fails, the behaviour returns Result&lt;T&gt;.Failure(errors) instead of throwing.\n</code></pre>"},{"location":"extensions/validation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Behavior throws when handler return type is not <code>Result</code>/<code>Result&lt;T&gt;</code> and strategy is <code>ReturnResult</code>/<code>Notify</code> with <code>ReturnResult</code>; switch to <code>Throw</code> or update handler return types.</li> <li>Missing correlation/trace IDs: set <code>ValidationOptions.TraceId</code> from your pipeline or leave null to let downstream behaviors apply correlation.</li> </ul>"},{"location":"extensions/validation/#samples-tests","title":"Samples &amp; Tests","text":"<ul> <li>See <code>tests/CleanArchitecture.Extensions.Validation.Tests</code> for strategy coverage and rule helper usage.</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 8 SDK (for consuming extensions and running samples/tests)</li> <li>git (to pull the repo)</li> <li>Python 3.10+ (only if you want to build/serve docs locally)</li> </ul>"},{"location":"getting-started/installation/#install-an-extension-placeholder","title":"Install an extension (placeholder)","text":"<p>Replace names with real packages when published. <code>\bash  dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Sample</code></p>"},{"location":"getting-started/installation/#local-docs-tooling-optional","title":"Local docs tooling (optional)","text":"<p><code>\bash python -m venv .venv . .venv/Scripts/Activate.ps1 pip install -r docs/requirements.txt mkdocs serve</code> \"@;</p> <p>'docs/concepts/architecture-fit.md' = @\"</p>"},{"location":"getting-started/installation/#architecture-fit","title":"Architecture Fit","text":"<p>How extensions align with Jason Taylor's Clean Architecture template.</p> <ul> <li>Extensions stay out of the template repo; they plug in via packages, configuration, and middleware/behaviors.</li> <li>Favor composition over modification: add pipeline behaviors, decorators, and adapters rather than changing core layers.</li> <li>Preserve boundaries: respect domain/application/infrastructure/UI separation and dependency direction.</li> <li>Match conventions: naming, folder structure, and style should mirror Jason's reference repo (see ../JasonTaylorCleanArchitecture).</li> <li>Keep optionality: each extension should be opt-in, with clear defaults and minimal required configuration.</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Get an extension running fast. Adjust package names/configs as real packages land.</p>"},{"location":"getting-started/quickstart/#1-create-or-open-a-clean-architecture-solution","title":"1) Create or open a Clean Architecture solution","text":"<p>Use Jason Taylor's template as the base (see repository root for reference copy).</p>"},{"location":"getting-started/quickstart/#2-add-an-extension-package","title":"2) Add an extension package","text":""},{"location":"getting-started/quickstart/#example-placeholder-package-name","title":"example placeholder package name","text":""},{"location":"getting-started/quickstart/#replace-with-the-actual-extension-when-available","title":"replace with the actual extension when available","text":"<p>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Sample `</p>"},{"location":"getting-started/quickstart/#3-configure-the-extension","title":"3) Configure the extension","text":"<p>Add minimal configuration (placeholder example): <code>json {   \"Extensions\": {     \"Sample\": {       \"Enabled\": true     }   } }</code></p>"},{"location":"getting-started/quickstart/#4-run-and-verify","title":"4) Run and verify","text":"<p><code>dotnet run --project src/YourProject/YourProject.csproj</code> Check logs/output for the extension initializing successfully.</p> <p>Tip</p> <p>When real packages land, swap the package name/config keys and link to the relevant recipe or extension page.</p>"},{"location":"recipes/authentication/","title":"Recipe: Authentication","text":""},{"location":"recipes/authentication/#goal","title":"Goal","text":"<p>Wire authentication with extension-friendly hooks.</p>"},{"location":"recipes/authentication/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Auth provider chosen (e.g., JWT, IdentityServer) \u2014 placeholder until packages land.</li> </ul>"},{"location":"recipes/authentication/#steps","title":"Steps","text":"<ol> <li>Add the relevant authentication adapter package (TBD).</li> <li>Configure authentication in Program.cs (or equivalent) with provided helpers.</li> <li>Add middleware/filters for tenant-aware auth if needed.</li> </ol>"},{"location":"recipes/authentication/#verify","title":"Verify","text":"<ul> <li>Hitting a protected endpoint returns 200 with valid token; 401 otherwise.</li> </ul>"},{"location":"recipes/authentication/#pitfalls","title":"Pitfalls","text":"<ul> <li>Misaligned schemes between API and client; ensure defaults match.</li> <li>Ensure tenant resolution occurs before authz when multitenancy is enabled.</li> </ul>"},{"location":"recipes/caching/","title":"Recipe: Caching","text":""},{"location":"recipes/caching/#goal","title":"Goal","text":"<p>Add caching with clear cache key conventions and opt-in behaviors.</p>"},{"location":"recipes/caching/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Choose cache store (in-memory, distributed) \u2014 adapters TBD.</li> </ul>"},{"location":"recipes/caching/#steps","title":"Steps","text":"<ol> <li>Add the cache adapter package (TBD).</li> <li>Register cache services and behaviors.</li> <li>Apply caching to queries/handlers where appropriate; define cache durations and invalidation rules.</li> </ol>"},{"location":"recipes/caching/#verify","title":"Verify","text":"<ul> <li>First call hits data source; subsequent call hits cache (check logs/metrics).</li> </ul>"},{"location":"recipes/caching/#pitfalls","title":"Pitfalls","text":"<ul> <li>Cache stampede: add locking or jitter where needed.</li> <li>Tenant-aware caching: ensure keys include tenant context when multitenancy is enabled.</li> </ul>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>Configuration keys and environment variables for extensions.</p> <ul> <li>This section will expand per extension as packages ship.</li> <li>Include defaults, required values, and sample \u0007ppsettings snippets.</li> </ul>"},{"location":"reference/configuration/#placeholder-keys","title":"Placeholder keys","text":"<ul> <li>Extensions::Enabled <li>Extensions::Options (TBD per extension)"},{"location":"release-notes/","title":"Release Notes","text":"<p>Changelog for CleanArchitecture.Extensions (latest-only for now).</p> <ul> <li>Add a section per release once packages ship.</li> <li>Call out breaking changes and migration steps.</li> </ul>"},{"location":"samples/","title":"Samples","text":"<p>Runnable samples to demonstrate extensions in real projects.</p> <ul> <li>Located under samples/ in the repo.</li> <li>Each sample should include setup instructions and expected output.</li> <li>Use scripts to reset/run samples for consistent results.</li> </ul>"},{"location":"samples/#planned-samples","title":"Planned samples","text":"<ul> <li>Minimal API with one extension enabled.</li> <li>Multitenant API with tenant resolution strategies.</li> <li>Observability-enabled API (metrics/tracing/logging) once adapters are added.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and fixes (expand as features land).</p> <ul> <li>Extension fails to start: enable debug logs and check config keys.</li> <li>Tenant not resolved: verify provider order (host/header/route/claims) and add logging for resolution steps.</li> <li>Caching mismatches: confirm cache keys include tenant/user when required.</li> </ul>"}]}