{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CleanArchitecture.Extensions \u2014 home","text":"<p>Built for developers who start from Jason Taylor's Clean Architecture template and refuse to fork it. This site is the narrative version of the long-form README: it explains what the ecosystem is, what ships today, how to install it in minutes, and what is coming next. Everything here is Markdown-first, wired to MkDocs, and backed by runnable samples so you can copy/paste with confidence.</p>"},{"location":"#what-this-page-gives-you","title":"What this page gives you","text":"<ul> <li>Understand how CleanArchitecture.Extensions stays aligned with Jason Taylor's template while adding opt-in capabilities.</li> <li>See the current catalog (Core, Validation, Exceptions) plus the roadmap across multitenancy, enterprise, SaaS, infrastructure, and developer experience.</li> <li>Install the preview packages in under ten minutes with copy-ready commands and pipeline wiring.</li> <li>Navigate docs, samples, recipes, and tests without guessing where things live.</li> <li>Pick an adoption path that matches your project (greenfield, migration, observability-first, SaaS, compliance-ready).</li> </ul>"},{"location":"#why-this-ecosystem-exists-template-first-fork-free","title":"Why this ecosystem exists (template-first, fork-free)","text":"<ul> <li>The upstream template is the starting point; we do not fork it. Extensions arrive as NuGet packages that plug into the MediatR pipeline, middleware, and abstractions you already know.</li> <li>Every package mirrors the template's structure and dependency discipline. If you are comfortable in the original solution, you will be comfortable here.</li> <li>Opt-in is non-negotiable: install only what you need, toggle via configuration, and remove without rewriting handlers.</li> <li>Docs, samples, and tests live beside the code so the guidance you read matches the code you run.</li> <li>Correlation IDs, deterministic time, guards, and validation are provided without leaking infrastructure into Application or Domain layers.</li> </ul>"},{"location":"#tldr-quickstart-10-minutes","title":"TL;DR quickstart (10 minutes)","text":"<p>1) Start from Jason Taylor's template if you have not already:</p> <pre><code>dotnet new install Clean.Architecture.Solution.Template\n</code></pre> <p>2) Add the Core extension to your Application project to get correlation, logging, performance, results, guards, domain events, and time abstractions:</p> <pre><code>dotnet add package CleanArchitecture.Extensions.Core --version 0.1.1-preview.1\n</code></pre> <p>Wire pipeline behaviors (ordering matches the template):</p> <pre><code>services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(CorrelationBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(PerformanceBehavior&lt;,&gt;));\n</code></pre> <p>3) Add Validation if you rely on FluentValidation in the pipeline:</p> <pre><code>dotnet add package CleanArchitecture.Extensions.Validation --version 0.1.1-preview.1\n</code></pre> <p>Register validators and the behavior:</p> <pre><code>services.AddValidatorsFromAssemblyContaining&lt;CreateOrderValidator&gt;();\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(ValidationBehaviour&lt;,&gt;));\n</code></pre> <p>4) Run the samples that match what you enabled. Open <code>CleanArchitecture.Extensions.sln</code>, pick a sample in <code>samples/</code>, and run it:</p> <pre><code>dotnet run --project samples/CleanArchitecture.Extensions.Core.Pipeline.Sample/CleanArchitecture.Extensions.Core.Pipeline.Sample.csproj\n</code></pre> <p>5) Read the matching docs pages for details and options:</p> <ul> <li>Core overview: extensions/core.md</li> <li>Result primitives: extensions/core-result-primitives.md</li> <li>Pipeline behaviors: extensions/core-pipeline-behaviors.md</li> <li>Validation: extensions/validation.md</li> </ul>"},{"location":"#status-at-a-glance","title":"Status at a glance","text":"<ul> <li>Implemented (preview): <code>CleanArchitecture.Extensions.Core</code>, <code>CleanArchitecture.Extensions.Validation</code>, <code>CleanArchitecture.Extensions.Exceptions</code></li> <li>In design/build-out: Caching, Multitenancy family, Enterprise extensions, SaaS extensions, Infrastructure adapters, Developer Experience toolchain (CLI, templates, testing, packaging).</li> <li>Target frameworks: <code>net10.0</code></li> <li>Packaging discipline: SourceLink, XML docs, snupkg symbols for debugger-friendly consumption.</li> <li>Docs: MkDocs + Material; everything lives under <code>docs/</code> and is published to GitHub Pages.</li> <li>Samples: runnable under <code>samples/</code>; each mirrors a doc scenario.</li> <li>Solution layout: open <code>CleanArchitecture.Extensions/CleanArchitecture.Extensions.sln</code> to see <code>src</code>, <code>tests</code>, <code>samples</code>, <code>build</code>.</li> </ul>"},{"location":"#how-to-use-this-docs-site","title":"How to use this docs site","text":"<ul> <li>Start here to understand the ecosystem and pick your first package.</li> <li>Jump to Getting started for a copy/paste path if you just want to install.</li> <li>Use Concepts to see how we honor Clean Architecture boundaries and composition rules.</li> <li>Browse the Extensions catalog for per-package deep dives, compat, install, usage, troubleshooting, and samples.</li> <li>Check Recipes for task-based guidance and Samples for runnable walkthroughs.</li> <li>Track Roadmap and Release notes to see what is shipping next.</li> <li>Contributors: read Contributing and the HighLevelDocs design notes before sending a PR.</li> </ul>"},{"location":"#core-principles-compatibility-and-discipline","title":"Core principles (compatibility and discipline)","text":"<ul> <li>Template alignment: pipeline order follows Jason's template: Correlation \u2192 Logging pre-processor \u2192 UnhandledException \u2192 Authorization \u2192 Validation \u2192 Performance \u2192 Handler.</li> <li>Opt-in behaviors: everything is additive. You can enable or disable behaviors via DI registration and options without rewriting handlers.</li> <li>Deterministic tests: <code>IClock</code> and <code>FrozenClock</code> keep time stable; results carry trace IDs; behaviors log correlation scopes.</li> <li>Minimal dependencies: stay close to <code>Microsoft.Extensions.*</code>, MediatR, and FluentValidation. Infrastructure adapters are optional packages.</li> <li>Migration-friendly: Legacy result shims let you migrate from the template's <code>Result</code> shape gradually.</li> <li>Docs-first: every capability ships with a doc page, sample, and tests that match. This page is the canonical overview; each subpage is the deep dive.</li> </ul>"},{"location":"#getting-started-expanded-walkthrough","title":"Getting started (expanded walkthrough)","text":"<p>The quickstart above gets you running; this section adds context and verification steps.</p>"},{"location":"#1-prepare-a-solution-based-on-jason-taylors-template","title":"1) Prepare a solution based on Jason Taylor's template","text":"<ul> <li>Install the template and create a new solution, or open your existing template-based repo.</li> <li>Keep the upstream template untouched; you will add packages and behaviors only.</li> </ul>"},{"location":"#2-add-core","title":"2) Add Core","text":"<p>Install and wire the behaviors:</p> <pre><code>dotnet add package CleanArchitecture.Extensions.Core --version 0.1.1-preview.1\n</code></pre> <pre><code>services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(CorrelationBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(PerformanceBehavior&lt;,&gt;));\n</code></pre> <p>Optional toggles (see extensions/core-options.md):</p> <pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.CorrelationIdHeader = \"X-Correlation-ID\";\n    options.PerformanceThresholdMilliseconds = 250;\n    options.DefaultGuardStrategy = GuardStrategy.ReturnResult;\n});\n</code></pre>"},{"location":"#3-add-validation","title":"3) Add Validation","text":"<p>Install and register validators:</p> <pre><code>dotnet add package CleanArchitecture.Extensions.Validation --version 0.1.1-preview.1\n</code></pre> <pre><code>services.AddValidatorsFromAssemblyContaining&lt;CreateOrderValidator&gt;();\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(ValidationBehaviour&lt;,&gt;));\n</code></pre> <p>Configure strategy (see extensions/validation.md):</p> <pre><code>services.Configure&lt;ValidationOptions&gt;(options =&gt;\n{\n    options.Strategy = ValidationStrategy.ReturnResult;\n    options.IncludePropertyName = true;\n    options.LogValidationFailures = true;\n    options.SeverityLogLevels[Severity.Error] = LogLevel.Warning;\n});\n</code></pre>"},{"location":"#4-run-and-verify","title":"4) Run and verify","text":"<ul> <li>Run the pipeline sample to see correlation, logging, performance, and validation in action.</li> <li>Inspect logs for correlation IDs and performance warnings.</li> <li>Switch <code>ValidationOptions.Strategy</code> between Throw and ReturnResult to see behavior differences.</li> </ul>"},{"location":"#5-adopt-gradually","title":"5) Adopt gradually","text":"<ul> <li>Use Legacy result shims to migrate handlers without breaking controllers.</li> <li>Toggle behaviors on or off per environment via configuration options.</li> <li>Add more packages later as they ship; everything is composable.</li> </ul>"},{"location":"#shipped-packages-deep-highlights","title":"Shipped packages (deep highlights)","text":""},{"location":"#cleanarchitectureextensionscore","title":"CleanArchitecture.Extensions.Core","text":"<p>Focus: result primitives, guard clauses, correlation-aware logging, performance monitoring, domain events, time abstractions, options toggles.</p> <ul> <li>Result and Result: carry status, error codes, messages, trace IDs, and combinators (<code>Map</code>, <code>Bind</code>, <code>Ensure</code>, <code>Combine</code>, <code>Recover</code>, <code>Tap</code>). Legacy shims (<code>LegacyResult</code>, <code>LegacyResult&lt;T&gt;</code>) help migrate from the template shape. <li>Guard clauses: consistent validation for null/empty, ranges, enums, lengths, and state invariants. Configurable to throw or return <code>Result</code>.</li> <li>Pipeline behaviors: correlation, logging, and performance behaviors aligned to template ordering. Correlation assigns/propagates IDs; logging emits structured start/finish; performance warns when thresholds are exceeded.</li> <li>Logging abstractions: <code>IAppLogger</code> and <code>ILogContext</code> wrap your logging stack with scopes that include correlation metadata.</li> <li>Domain events: helpers for raising/dispatching events from aggregates while keeping Application clean.</li> <li>Time abstractions: <code>IClock</code>, <code>FrozenClock</code>, <code>OffsetClock</code> keep time deterministic across environments.</li> <li>Options: <code>CoreExtensionsOptions</code> centralize defaults for correlation IDs, thresholds, guard strategies, trace identifiers.</li> <li>Docs: start at extensions/core.md and follow links to result, guards, pipeline, logging, domain events, time, and options pages.</li> <li>Samples: see <code>samples/CleanArchitecture.Extensions.Core.*</code> for pipeline, logging, result, guards, domain events, time, and options.</li> <li>Tests: <code>tests/CleanArchitecture.Extensions.Core.Tests/</code> with result and legacy shims plus growing coverage for other pieces.</li>"},{"location":"#cleanarchitectureextensionsvalidation","title":"CleanArchitecture.Extensions.Validation","text":"<p>Focus: predictable FluentValidation integration in the MediatR pipeline with correlation-aware logging and configurable strategies.</p> <ul> <li>Behavior: <code>ValidationBehaviour&lt;TRequest, TResponse&gt;</code> runs validators discovered via DI.</li> <li>Strategies: <code>Throw</code>, <code>ReturnResult</code>, or <code>Notify</code> (via <code>IValidationNotificationPublisher</code>).</li> <li>Rule catalog: <code>CommonRules</code> for trimmed strings, email, phone, pagination, culture codes, sort expressions, and optional values.</li> <li>Logging: integrates with <code>IAppLogger</code> and <code>ILogContext</code> to log failures with correlation IDs; map severities to log levels.</li> <li>Docs: extensions/validation.md with install, options, strategies, troubleshooting.</li> <li>Samples: validation behavior is showcased in pipeline samples; more samples are planned as the catalog grows.</li> <li>Planned: tenant-aware rules, Minimal API/MVC filters, metrics hooks once Observability lands.</li> </ul>"},{"location":"#ecosystem-and-roadmap-preview","title":"Ecosystem and roadmap (preview)","text":"<p>This repo is a monorepo for a plug-in ecosystem. Only Core and Validation ship today; everything else is designed in <code>HighLevelDocs/</code> and staged under <code>docs/extensions/</code> as placeholders.</p>"},{"location":"#domain-1-core-architecture","title":"Domain 1 \u2014 Core Architecture","text":"<ul> <li>CleanArchitecture.Extensions.Core (shipped, preview)</li> <li>CleanArchitecture.Extensions.Validation (shipped, preview)</li> <li>CleanArchitecture.Extensions.Exceptions (shipped, preview)</li> <li>CleanArchitecture.Extensions.Caching (planned)</li> </ul>"},{"location":"#domain-2-multitenancy-ecosystem","title":"Domain 2 \u2014 Multitenancy ecosystem","text":"<ul> <li>Multitenancy core plus EFCore, AspNetCore, Identity, Sharding, Provisioning, Storage, Redis adapters (all planned; see extensions/multitenancy-core.md for intent).</li> </ul>"},{"location":"#domain-3-enterprise-extensions","title":"Domain 3 \u2014 Enterprise extensions","text":"<ul> <li>Audit, Settings, FeatureFlags, Notifications, RateLimiting, Localization, Authorization (planned).</li> </ul>"},{"location":"#domain-4-saas-business-extensions","title":"Domain 4 \u2014 SaaS business extensions","text":"<ul> <li>Payments, Documents, UserManagement (planned).</li> </ul>"},{"location":"#domain-5-infrastructure-adapters","title":"Domain 5 \u2014 Infrastructure adapters","text":"<ul> <li>Redis, MessageBus, Observability, Storage, Search (planned).</li> </ul>"},{"location":"#domain-6-developer-experience","title":"Domain 6 \u2014 Developer Experience","text":"<ul> <li>CLI, Templates, Testing, SourceLinkAndSymbols, NuGetPackaging (planned).</li> </ul> <p>Roadmap depth and rationale live in <code>HighLevelDocs/CLEANARCHITECTURE.EXTENSIONS-MASTER-ROADMAP.md</code> and per-domain design docs. Each upcoming module will arrive with docs, samples, and compatibility guidance before code ships.</p>"},{"location":"#adoption-playbooks-pick-the-one-that-matches-you","title":"Adoption playbooks (pick the one that matches you)","text":""},{"location":"#telemetry-first-adoption","title":"Telemetry-first adoption","text":"<ul> <li>Start with Core correlation, logging, and performance behaviors to light up tracing.</li> <li>Layer Validation with <code>ReturnResult</code> strategy to collect validation feedback without exceptions.</li> <li>Add Observability adapters later for OTEL export without touching handlers.</li> <li>Success signals: logs/traces include correlation IDs (and tenant IDs when multitenancy arrives); pipeline ordering is explicit; teams can toggle behaviors via config.</li> </ul>"},{"location":"#migration-from-the-template-result","title":"Migration from the template Result","text":"<ul> <li>Use Core's LegacyResult shims to bridge the template's <code>bool + errors</code> shape to richer results.</li> <li>Keep controllers intact while migrating handlers incrementally.</li> <li>Pair with Validation <code>ReturnResult</code> to avoid throwing where explicit outcomes are preferred.</li> <li>Success signals: handlers return richer metadata; no controller refactors; tests cover both shapes during transition.</li> </ul>"},{"location":"#saas-with-tenant-isolation-forward-looking","title":"SaaS with tenant isolation (forward-looking)","text":"<ul> <li>Plan for Multitenancy core with EFCore and AspNetCore adapters once released.</li> <li>Pair with RateLimiting and Caching using tenant-aware strategies.</li> <li>Connect Provisioning and Payments when billing arrives.</li> <li>Success signals: tenant boundaries enforced in data, HTTP, and caches; correlation and logs carry tenant identifiers.</li> </ul>"},{"location":"#event-driven-integration","title":"Event-driven integration","text":"<ul> <li>Use Core domain events today; plan for MessageBus and Outbox patterns later.</li> <li>Keep correlation IDs flowing across process boundaries; use Observability for traces.</li> <li>Success signals: integration events carry trace/tenant context; handlers stay clean; retries and idempotency documented when adapters land.</li> </ul>"},{"location":"#compliance-and-audit-readiness","title":"Compliance and audit readiness","text":"<ul> <li>Plan for Audit (events, diffs, stores) plus Authorization and Settings for policy controls.</li> <li>Use Core time and correlation primitives for audit trails now.</li> <li>Success signals: who/what/when trails exist; configuration toggles gate risky behaviors; localization and feature flags help rollout safely.</li> </ul>"},{"location":"#developer-experience-at-scale","title":"Developer experience at scale","text":"<ul> <li>Watch for CLI, Templates, Testing, NuGetPackaging, and SourceLinkAndSymbols.</li> <li>Goal: reproducible setups, deterministic handler tests, consistent packaging, and debugger-friendly NuGets.</li> <li>Success signals: scaffolds reduce setup drift; packages include symbols and SourceLink; tests are deterministic via <code>IClock</code> and fakes.</li> </ul>"},{"location":"#samples-and-runnable-stories","title":"Samples and runnable stories","text":"<p>All samples live under <code>samples/</code> and are runnable via <code>dotnet run</code>. They mirror the docs so you can see real code wired into the pipeline.</p> <ul> <li>Pipeline: <code>samples/CleanArchitecture.Extensions.Core.Pipeline.Sample</code> \u2014 correlation, logging, performance behaviors.</li> <li>Logging: <code>samples/CleanArchitecture.Extensions.Core.Logging.Sample</code> \u2014 <code>IAppLogger</code>, scopes, correlation metadata.</li> <li>Result: <code>samples/CleanArchitecture.Extensions.Core.Result.Sample</code> \u2014 <code>Result</code>/<code>Result&lt;T&gt;</code>, legacy mapping, error aggregation.</li> <li>Guards: <code>samples/CleanArchitecture.Extensions.Core.Guards.Sample</code> \u2014 guard catalog and strategies.</li> <li>Domain events: <code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample</code> \u2014 raising and dispatching events.</li> <li>Time: <code>samples/CleanArchitecture.Extensions.Core.Time.Sample</code> \u2014 <code>IClock</code>, <code>FrozenClock</code>, <code>OffsetClock</code>.</li> <li>Options: <code>samples/CleanArchitecture.Extensions.Core.Options.Sample</code> \u2014 toggling defaults for correlation IDs and thresholds.</li> </ul> <p>Run a sample:</p> <pre><code>dotnet run --project samples/CleanArchitecture.Extensions.Core.Result.Sample/CleanArchitecture.Extensions.Core.Result.Sample.csproj\n</code></pre>"},{"location":"#documentation-map-where-to-go-next","title":"Documentation map (where to go next)","text":"<ul> <li>Getting started: getting-started/quickstart.md \u00b7 getting-started/installation.md</li> <li>Concepts: concepts/architecture-fit.md \u00b7 concepts/composition.md</li> <li>Catalog: extensions/index.md with links to Core, Validation, Multitenancy placeholder, and future stubs.</li> <li>Package blueprints: roadmap/package-blueprints.md for the long-form per-extension blueprint formerly in the README.</li> <li>Recipes: recipes/authentication.md \u00b7 recipes/caching.md</li> <li>Samples: samples/index.md</li> <li>Reference &amp; Ops: reference/configuration.md \u00b7 troubleshooting/index.md \u00b7 release-notes/index.md \u00b7 roadmap.md</li> <li>Adoption playbooks: getting-started/adoption-playbooks.md for scenario-driven guidance moved from the README.</li> <li>Contributing: contributing/index.md</li> </ul>"},{"location":"#quality-packaging-and-compatibility-promises","title":"Quality, packaging, and compatibility promises","text":"<ul> <li>SourceLink and symbols: every package ships with SourceLink and snupkg symbols for debugger-friendly consumption.</li> <li>Target frameworks: <code>net10.0</code> for shipped packages; future modules will follow the same strategy unless noted.</li> <li>MediatR pipeline discipline: behaviors are ordered to avoid surprises and to align with the template.</li> <li>Logging and correlation: consistent scopes and trace identifiers across behaviors, validation, and future adapters.</li> <li>Docs and samples parity: docs reference code that exists; samples are runnable; release notes call out breaking changes.</li> <li>Exit ramps: because everything is opt-in, you can uninstall a package and remove DI registrations to revert to the template baseline.</li> </ul>"},{"location":"#contribution-signals","title":"Contribution signals","text":"<ul> <li>Read the HighLevelDocs entry for the domain you want to touch (start at <code>HighLevelDocs/CLEANARCHITECTURE.EXTENSIONS-MASTER-ROADMAP.md</code> and domain-specific files).</li> <li>For shipped packages, add docs and samples alongside code changes.</li> <li>Follow the docs style guide: concise, imperative, code-first, language-tagged fences, minimal admonitions.</li> <li>Keep Jason Taylor's template untouched; add behaviors, middleware, and adapters via packages.</li> <li>Tests and samples should illustrate the docs you write; keep snippet drift low by referencing sample code.</li> </ul>"},{"location":"#faq-fast-answers","title":"FAQ (fast answers)","text":"<ul> <li>Do I have to fork Jason's template? No. Install packages and register behaviors; the template stays pristine.</li> <li>Can I migrate gradually? Yes. Use Legacy result shims, enable behaviors incrementally, and configure strategies per environment.</li> <li>How do I know pipeline ordering? See Core pipeline docs; we mirror the template order and call it out explicitly.</li> <li>What frameworks are supported? <code>net10.0</code> for shipped packages; others will state compatibility on their pages.</li> <li>Where are tests and samples? <code>tests/</code> and <code>samples/</code> in the solution; each doc page links to the relevant ones.</li> <li>How do I track progress? Watch roadmap.md and release-notes/index.md; design intent lives in <code>HighLevelDocs/</code>.</li> </ul>"},{"location":"#next-steps-for-you","title":"Next steps for you","text":"<ul> <li>If you are evaluating: read Concepts, run the Core pipeline sample, and skim the Validation page.</li> <li>If you are adopting: follow the quickstart, wire Core and Validation, and keep pipeline ordering explicit in your solution.</li> <li>If you are contributing: pick a work-in-progress module, read the matching HighLevelDocs design, and start with docs and sample scaffolding before coding.</li> <li>If you want to keep tabs: watch the repo and the GitHub Pages site for release and roadmap updates.</li> </ul> <p>This homepage stays long on purpose: it gives newcomers the full picture and gives veterans direct links to what matters. Use what you need today, keep your template clean, and help shape what ships next.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>An honest, Jason-Taylor-aligned look at where CleanArchitecture.Extensions is headed. We ship extensions as opt-in NuGet packages that plug into the upstream template without forking it. This roadmap tracks what is ready today, what is being built next, and what is queued behind it. Use it alongside HighLevelDocs/* for the detailed design intent of each module.</p>"},{"location":"roadmap/#status-legend","title":"Status legend","text":"<ul> <li>Shipped \u2013 package available (currently preview), docs + samples live.</li> <li>Now \u2013 active implementation and doc polish.</li> <li>Next \u2013 starts immediately after current work; requirements captured in HighLevelDocs.</li> <li>Exploring \u2013 shaping scope/design; timeline flexible.</li> <li>Later \u2013 anchored idea, sequenced after earlier phases.</li> </ul>"},{"location":"roadmap/#current-release-snapshot","title":"Current release snapshot","text":"<ul> <li>Shipped (preview): CleanArchitecture.Extensions.Core, CleanArchitecture.Extensions.Validation, CleanArchitecture.Extensions.Exceptions (net10.0, SourceLink, snupkg). Docs are live; Core/Validation samples are available; Exceptions sample is queued.</li> <li>Now: Core polish (API/compat tests), Validation polish (samples, rule catalog hardening), documentation sync.</li> <li>Next: Multitenancy Core design \u2192 first implementation spike + sample; roadmap-backed doc updates for Multitenancy and Caching.</li> </ul>"},{"location":"roadmap/#near-term-milestones-090-days","title":"Near-term milestones (0\u201390 days)","text":"<ul> <li>Core/Validation: finalize samples coverage, add missing recipes, keep nav/links aligned with README.</li> <li>Multitenancy Core: lock resolution/enforcement pipeline, DI patterns, and logging/correlation alignment; publish first sample.</li> <li>Caching (planning): finalize abstractions and behaviors; design tenant-safe keying conventions to pair with Multitenancy.</li> <li>Docs hygiene: replace placeholders in Getting Started, Reference, Recipes, Samples, Troubleshooting, and Release Notes with concrete guidance tied to shipped packages.</li> </ul>"},{"location":"roadmap/#domains-and-extensions","title":"Domains and extensions","text":""},{"location":"roadmap/#domain-1-core-architecture-extensions","title":"Domain 1 \u2014 Core Architecture Extensions","text":"<ul> <li>CleanArchitecture.Extensions.Core \u2014 guards, rich Result/Error, logging/correlation/performance behaviors, domain events, time, options. Status: Shipped (preview). Focus: API polish, compatibility tests, and adapter guidance.</li> <li>CleanArchitecture.Extensions.Validation \u2014 FluentValidation behavior, strategies (throw/result/notify), rule catalog, correlation-aware logging. Status: Shipped (preview). Focus: samples + rule coverage.</li> <li>CleanArchitecture.Extensions.Exceptions \u2014 exception translation/wrapping, problem-details alignment, pipeline behavior. Status: Shipped (preview). Focus: docs polish, HTTP adapter/sample wiring, and catalog hardening.</li> <li>CleanArchitecture.Extensions.Caching \u2014 cache abstractions, behaviors, invalidation hooks, tenant-safe keying. Status: Planning. Will align with Multitenancy and Redis adapters.</li> </ul>"},{"location":"roadmap/#domain-2-multitenancy-ecosystem","title":"Domain 2 \u2014 Multitenancy Ecosystem","text":"<ul> <li>Multitenancy Core \u2014 tenant model, resolution providers (host/header/route/claims), middleware, enforcement/validation behaviors. Status: Next. First sample planned.</li> <li>Multitenancy.EFCore \u2014 shared DB/schema-per-tenant/DB-per-tenant filters, DbContext factories, migrations/seeding. Status: Exploring.</li> <li>Multitenancy.AspNetCore \u2014 minimal API/controllers helpers, endpoint filters, provider wiring. Status: Exploring.</li> <li>Multitenancy.Identity \u2014 tenant claim mapping, policy provider, role-per-tenant support. Status: Exploring.</li> <li>Multitenancy.Sharding / Provisioning / Storage / Redis \u2014 sharding strategies, onboarding workflows, tenant-aware storage/cache. Status: Later/Exploring depending on adapter.</li> </ul>"},{"location":"roadmap/#domain-3-enterprise-extensions","title":"Domain 3 \u2014 Enterprise Extensions","text":"<ul> <li>Audit, Settings, FeatureFlags, Notifications, RateLimiting, Localization, Authorization \u2014 cross-cutting packages to add audit trails, runtime config, feature toggles, notification channels, throttling, localization, and permission models. Status: Exploring/Later. Each will align with Core correlation/time and Multitenancy when present.</li> </ul>"},{"location":"roadmap/#domain-4-saas-business-extensions","title":"Domain 4 \u2014 SaaS Business Extensions","text":"<ul> <li>Payments, Documents, UserManagement \u2014 SaaS-focused building blocks (billing, document generation, onboarding/MFA/passwordless). Status: Exploring. Will emit events for Notifications and Provisioning.</li> </ul>"},{"location":"roadmap/#domain-5-infrastructure-adapters","title":"Domain 5 \u2014 Infrastructure Adapters","text":"<ul> <li>Redis, MessageBus (RabbitMQ/ASB/Kafka + outbox), Observability (OTEL), Storage (Blob/S3/local), Search (Elastic/Azure Search) \u2014 adapters to keep Application clean while swapping providers. Status: Planning/Exploring. Will reuse Core logging/correlation and Multitenancy context where relevant.</li> </ul>"},{"location":"roadmap/#domain-6-developer-experience","title":"Domain 6 \u2014 Developer Experience","text":"<ul> <li>CLI, Templates, Testing, SourceLinkAndSymbols, NuGetPackaging \u2014 tooling to scaffold modules, keep packaging consistent, and improve test ergonomics. Status: Exploring/Later. Templates/CLI follow once Multitenancy/Caching patterns stabilize.</li> </ul>"},{"location":"roadmap/#workstream-priorities-and-dependencies","title":"Workstream priorities and dependencies","text":"<ul> <li>Docs-first: every shipped capability must have a filled extension page, sample, and recipe. README links depend on this.</li> <li>Sample-first: new modules land with runnable samples; prioritize pipeline wiring (MediatR, DI) and logs showing correlation/tenant context.</li> <li>Compatibility: keep MediatR signatures and template ordering intact; legacy Result shims remain until migrations are trivial.</li> <li>Tenant-aware design: Caching, Redis, Storage, MessageBus, RateLimiting must consume Multitenancy abstractions to prevent cross-tenant leakage.</li> <li>Observability alignment: adapters should carry correlation IDs from Core; OTEL conventions to follow once Observability ships.</li> </ul>"},{"location":"roadmap/#how-to-engage","title":"How to engage","text":"<ul> <li>Building with shipped packages: start with Core + Validation, run the samples under samples/, and follow the extension pages for wiring and options.</li> <li>Contributing: pick a WIP module, read the matching HighLevelDocs/Domain/CleanArchitecture.Extensions..md, propose doc/sample scaffolds, then code + tests.</li> <li>Tracking progress: watch releases and docs/release-notes/ once populated; this roadmap will be updated as milestones move.</li> </ul>"},{"location":"concepts/architecture-fit/","title":"Architecture Fit","text":"<p>How extensions align with Jason Taylor's Clean Architecture template.</p> <ul> <li>Keep the template untouched: extensions plug in via packages, configuration, middleware/behaviors\u2014not by forking or editing the upstream template.</li> <li>Preserve boundaries: respect domain/application/infrastructure/UI separation and dependency direction.</li> <li>Prefer composition: use pipeline behaviors, decorators, filters, and adapters instead of modifying core layers.</li> <li>Match conventions: mirror naming, folder structure, and coding style from the reference <code>JasonTaylorCleanArchitecture</code> copy.</li> <li>Stay optional: every extension should be opt-in with clear defaults and minimal required configuration.</li> </ul>"},{"location":"concepts/composition/","title":"Composition &amp; Invariants","text":"<p>Principles for combining extensions safely.</p> <ul> <li>Isolation: each extension should have clear dependencies and avoid implicit cross-talk.</li> <li>Pipelines first: prefer mediatr behaviors, filters, and decorators to hook in cross-cutting concerns.</li> <li>Config clarity: document required settings, defaults, and compat matrices; fail fast on invalid configs.</li> <li>Observability: emit structured logs/events for extension lifecycle (init, errors, important decisions).</li> <li>Compatibility: declare supported .NET versions and CleanArchitecture template versions per extension page.</li> <li>Exit strategy: provide guidance for disabling/removing an extension cleanly.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We keep the upstream Jason Taylor template pristine and ship everything as opt-in packages. Contributions must follow that contract and stay in sync with the docs and samples.</p>"},{"location":"contributing/#principles","title":"Principles","text":"<ul> <li>Template-first: mirror Jason Taylor\u2019s conventions (folder layout, naming, MediatR pipeline ordering). Do not modify <code>JasonTaylorCleanArchitecture/</code>.</li> <li>Extension = opt-in: minimal required config, no surprises; keep dependencies light.</li> <li>Docs/samples-first: every behavior change lands with updated docs under <code>docs/</code> and, where applicable, a sample under <code>samples/</code>.</li> <li>Tests-close-to-code: add/adjust tests in <code>tests/</code> for the package you touch.</li> </ul>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Pick the design doc: read the matching <code>HighLevelDocs/Domain*/CleanArchitecture.Extensions.*.md</code> before coding.</li> <li>Branch in this repo; keep changes inside <code>CleanArchitecture.Extensions/</code> solution (src/tests/samples/docs/build).</li> <li>Implement + test: add or update unit/integration tests for your changes.</li> <li>Update docs: extension page, recipes, reference, and roadmap if scope changes. Keep nav links valid.</li> <li>Preview docs locally (optional): <pre><code>python -m venv .venv\n. .venv/Scripts/Activate.ps1\npip install -r docs/requirements.txt\nmkdocs serve\n</code></pre></li> <li>Run relevant samples/tests where applicable and note any manual steps in your PR description.</li> </ol>"},{"location":"contributing/#style-docs","title":"Style (docs)","text":"<ul> <li>Follow the documentation strategy templates (overview \u2192 when to use \u2192 compat \u2192 install \u2192 usage \u2192 troubleshooting \u2192 samples/tests).</li> <li>Use fenced code blocks with language tags (<code>bash</code>, <code>powershell</code>, <code>csharp</code>, <code>json</code>).</li> <li>Prefer snippets from source to avoid drift; keep examples short and runnable.</li> <li>Keep compatibility info current (template version, target frameworks, dependencies).</li> </ul>"},{"location":"extensions/","title":"Extensions Catalog","text":"<p>Pick the extensions you need without touching Jason Taylor's upstream template. Each page follows a common structure: overview, when to use, compatibility, install, usage, troubleshooting, samples/tests.</p>"},{"location":"extensions/#shipped-preview","title":"Shipped (preview)","text":"<ul> <li>CleanArchitecture.Extensions.Core \u2014 foundation primitives (guards, Result/Error, logging/correlation/performance behaviors, domain events, time, options): Core \u00b7 Options \u00b7 Time \u00b7 Domain events \u00b7 Logging abstractions \u00b7 Pipeline behaviors \u00b7 Guard clauses \u00b7 Result primitives</li> <li>CleanArchitecture.Extensions.Validation \u2014 FluentValidation behavior + strategies, rule catalog, correlation-aware logging: Validation</li> <li>CleanArchitecture.Extensions.Exceptions \u2014 exception catalog, base types, redaction, and MediatR wrapping to convert exceptions to Results: Exceptions</li> </ul>"},{"location":"extensions/#in-design-planned-placeholders-until-code-lands","title":"In design / planned (placeholders until code lands)","text":"<ul> <li>Multitenancy Core \u2014 tenant resolution/enforcement primitives: Multitenancy Core</li> <li>Additional modules (Caching, Multitenancy adapters, Enterprise, SaaS, Infrastructure, DX) are tracked in the Roadmap and <code>HighLevelDocs/*</code>.</li> </ul>"},{"location":"extensions/#how-to-use-this-catalog","title":"How to use this catalog","text":"<ul> <li>Start with Core; add Validation when you use FluentValidation in the MediatR pipeline.</li> <li>For upcoming modules, read the placeholder page plus the matching HighLevelDocs file before contributing code.</li> <li>Keep compatibility info (template version, target frameworks, dependencies) current on each page.</li> <li>Link samples and tests: every shipped module should reference a runnable sample under <code>samples/</code> and relevant tests under <code>tests/</code>.</li> </ul>"},{"location":"extensions/core-domain-events/","title":"Core Domain Events","text":"<p>Domain events in Jason Taylor\u2019s Clean Architecture template are simple: <code>BaseEvent</code> is an empty <code>INotification</code>, <code>BaseEntity</code> holds a list of events, and an EF Core <code>DispatchDomainEventsInterceptor</code> publishes them via MediatR on <code>SaveChanges</code>. The Core extension adds richer metadata, a tracker, and an abstraction for dispatch so you can route events beyond EF, attach correlation IDs, and test event flows without EF or MediatR plumbing. This guide explains the template baseline, what Core adds, how to wire it, and real-world patterns for handlers, integration, and testing.</p>"},{"location":"extensions/core-domain-events/#what-the-template-already-covers","title":"What the template already covers","text":"<ul> <li>Types: <code>BaseEvent : INotification</code> (no properties) and <code>BaseEntity</code> keeps <code>List&lt;BaseEvent&gt; DomainEvents</code>.</li> <li>Dispatch: <code>DispatchDomainEventsInterceptor</code> (SaveChanges interceptor) drains <code>DomainEvents</code> from tracked entities and publishes each via <code>IMediator.Publish</code>.</li> <li>Usage: Entities call <code>AddDomainEvent(new TodoItemCreatedEvent(...))</code>. When EF <code>SaveChanges</code> runs, events are published in-process to notification handlers.</li> <li>Gaps: No correlation metadata, no timestamps, no tracking outside EF, and no abstraction to swap the dispatcher (e.g., to an outbox or message bus).</li> </ul>"},{"location":"extensions/core-domain-events/#what-core-adds","title":"What Core adds","text":"<ul> <li>Event base: <code>DomainEvent</code> (record, INotification) with <code>Id</code>, <code>OccurredOnUtc</code>, and optional <code>CorrelationId</code>.</li> <li>Tracking: <code>DomainEventTracker</code> to collect/clear events independent of EF change tracking; useful for aggregates not persisted via EF, or for outbox patterns.</li> <li>Dispatch abstraction: <code>IDomainEventDispatcher</code> defines <code>DispatchAsync(DomainEvent)</code> and <code>DispatchAsync(IEnumerable&lt;DomainEvent&gt;)</code>, letting Infrastructure choose how to publish (MediatR, bus, outbox).</li> <li>Correlation-first: Events can carry <code>CorrelationId</code> so you can tie logs, results, and integration messages together.</li> <li>Testability: In-memory tracker/dispatcher implementations make it easy to assert event emission without a database.</li> </ul>"},{"location":"extensions/core-domain-events/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.DomainEvents</code></p> <ul> <li><code>abstract record DomainEvent(string? correlationId = null)</code> : <code>Guid Id</code>, <code>DateTimeOffset OccurredOnUtc</code>, <code>string? CorrelationId</code>.</li> <li><code>DomainEventTracker</code> : <code>Add(DomainEvent)</code>, <code>HasEvents</code>, <code>Drain()</code>, <code>Clear()</code>, <code>Events</code> (read-only snapshot).</li> <li><code>IDomainEventDispatcher</code> : <code>DispatchAsync(DomainEvent, CancellationToken)</code>, <code>DispatchAsync(IEnumerable&lt;DomainEvent&gt;, CancellationToken)</code>.</li> </ul>"},{"location":"extensions/core-domain-events/#why-use-the-core-approach","title":"Why use the Core approach","text":"<ul> <li>Correlation: Attach <code>CorrelationId</code> from <code>ILogContext</code> or incoming HTTP headers so downstream handlers/logs share the same ID.</li> <li>Flexibility: Use the tracker in non-EF scenarios (Dapper, document DBs, in-memory aggregates) and dispatch via any mechanism (MediatR, message bus, outbox table).</li> <li>Testing: Assert on tracker contents without spinning up EF. Fake dispatchers keep tests fast and deterministic.</li> <li>Consistency: Aligns with Core logging and Result primitives\u2014errors and events can share the same correlation token for observability.</li> </ul>"},{"location":"extensions/core-domain-events/#wiring-in-di-typical-setups","title":"Wiring in DI (typical setups)","text":"<p>MediatR in-process dispatch + EF interceptor: <pre><code>builder.Services.AddCleanArchitectureCore(); // registers DomainEventTracker + MediatRDomainEventDispatcher\n\nbuilder.Services.AddDbContext&lt;ApplicationDbContext&gt;((sp, options) =&gt;\n{\n    options.AddInterceptors(sp.GetRequiredService&lt;DispatchDomainEventsInterceptor&gt;());\n});\n\nbuilder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());\n    // pipeline behaviors go here\n});\n</code></pre> - <code>DispatchDomainEventsInterceptor</code> (shipped in Core) drains <code>IHasDomainEvents</code> aggregates from the EF change tracker, correlates events via <code>ILogContext</code>/<code>CoreExtensionsOptions</code>, and publishes through <code>IDomainEventDispatcher</code>. - If you use an outbox or bus, replace <code>IDomainEventDispatcher</code> with your implementation; the interceptor still gathers and correlates events before dispatch.</p>"},{"location":"extensions/core-domain-events/#sample-backed-walkthrough-domain-events-sample","title":"Sample-backed walkthrough (domain events sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample</code>.</p>"},{"location":"extensions/core-domain-events/#tracker-dispatcher-with-correlation","title":"Tracker + dispatcher with correlation","text":"<p><code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample/src/Infrastructure/Data/Interceptors/DispatchDomainEventsInterceptor.cs</code>: <pre><code>var correlationId = EnsureCorrelationId();\nvar correlatedEvents = _tracker\n    .Drain()\n    .Select(domainEvent =&gt; EnsureCorrelation(domainEvent, correlationId))\n    .ToArray();\n\nawait _dispatcher.DispatchAsync(correlatedEvents, cancellationToken);\n</code></pre> - Domain events raised in aggregates are captured by <code>DomainEventTracker</code>, correlated (using <code>ILogContext</code> or the options factory), and dispatched through the <code>IDomainEventDispatcher</code>. - Events without a correlation ID are cloned via record <code>with</code> expressions so handlers/logs see the request-scoped identifier.</p>"},{"location":"extensions/core-domain-events/#recording-dispatched-events-for-diagnostics","title":"Recording dispatched events for diagnostics","text":"<p><code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample/src/Application/Diagnostics/Queries/GetRecentDomainEvents/GetRecentDomainEventsQuery.cs</code>: <pre><code>public sealed record GetRecentDomainEventsQuery(int Count = 20) : IRequest&lt;IReadOnlyCollection&lt;DomainEventLogEntry&gt;&gt;;\n\npublic Task&lt;IReadOnlyCollection&lt;DomainEventLogEntry&gt;&gt; Handle(GetRecentDomainEventsQuery request, CancellationToken cancellationToken)\n{\n    var take = Math.Clamp(request.Count, 1, 50);\n    var entries = _domainEventLog.ReadRecent(take);\n    return Task.FromResult(entries);\n}\n</code></pre> - The sample decorates the dispatcher with an in-memory <code>IDomainEventLog</code> and exposes recent events at <code>/api/DomainEvents/recent</code>.</p>"},{"location":"extensions/core-domain-events/#creating-events-with-request-correlation","title":"Creating events with request correlation","text":"<p><code>samples/CleanArchitecture.Extensions.Core.DomainEvents.Sample/src/Application/TodoItems/Commands/CreateTodoItem/CreateTodoItem.cs</code>: <pre><code>var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n_logContext.CorrelationId = correlationId;\n\nentity.AddDomainEvent(new TodoItemCreatedEvent(entity, correlationId));\n</code></pre> - Correlation is set by middleware (or generated in the handler) and flows into domain events, making it easy to trace end-to-end alongside the recorded event log entries.</p>"},{"location":"extensions/core-domain-events/#real-world-scenarios","title":"Real-world scenarios","text":""},{"location":"extensions/core-domain-events/#1-correlation-aware-events-from-handlers","title":"1) Correlation-aware events from handlers","text":"<p><pre><code>public sealed class CreateOrderCommandHandler : IRequest&lt;Result&lt;Guid&gt;&gt;\n{\n    private readonly IOrderRepository _orders;\n    private readonly IDomainEventDispatcher _dispatcher;\n    private readonly ILogContext _logContext;\n\n    public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateOrderCommand request, CancellationToken ct)\n    {\n        var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n        var order = Order.Create(request.CustomerId, correlationId); // domain factory sets correlation on events\n\n        await _orders.AddAsync(order, ct);\n        await _dispatcher.DispatchAsync(order.DomainEvents, ct);\n        order.ClearDomainEvents();\n\n        return Result.Success(order.Id, correlationId);\n    }\n}\n</code></pre> - Events and Result share the same correlation ID, making logs and downstream handlers traceable.</p>"},{"location":"extensions/core-domain-events/#2-outbox-friendly-dispatch","title":"2) Outbox-friendly dispatch","text":"<p><pre><code>public sealed class OutboxDomainEventDispatcher : IDomainEventDispatcher\n{\n    private readonly IOutboxWriter _outbox;\n\n    public Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct = default) =&gt;\n        _outbox.AppendAsync(new OutboxMessage(domainEvent), ct);\n\n    public Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; domainEvents, CancellationToken ct = default) =&gt;\n        _outbox.AppendAsync(domainEvents.Select(e =&gt; new OutboxMessage(e)), ct);\n}\n</code></pre> - Swap dispatchers per environment: in-process for dev/tests; outbox for production.</p>"},{"location":"extensions/core-domain-events/#3-aggregating-events-outside-ef","title":"3) Aggregating events outside EF","text":"<p><pre><code>public sealed class InMemoryAggregateStore\n{\n    private readonly DomainEventTracker _tracker;\n\n    public InMemoryAggregateStore(DomainEventTracker tracker) =&gt; _tracker = tracker;\n\n    public void Save(AggregateRoot aggregate)\n    {\n        foreach (var e in aggregate.DomainEvents)\n        {\n            _tracker.Add(e);\n        }\n        aggregate.ClearDomainEvents();\n    }\n}\n</code></pre> - Later, call <code>_dispatcher.DispatchAsync(_tracker.Drain())</code> to publish.</p>"},{"location":"extensions/core-domain-events/#4-mapping-existing-template-events","title":"4) Mapping existing template events","text":"<p>If you have existing <code>BaseEvent</code> types from the template, wrap or replace them: <pre><code>public sealed record TodoItemCreatedEvent(Guid ItemId, string? CorrelationId = null) \n    : DomainEvent(CorrelationId);\n</code></pre> - You can keep handler code; MediatR sees it as <code>INotification</code> like before.</p>"},{"location":"extensions/core-domain-events/#5-logging-event-publication","title":"5) Logging event publication","text":"<p><pre><code>public sealed class LoggingDomainEventDispatcher : IDomainEventDispatcher\n{\n    private readonly IDomainEventDispatcher _inner;\n    private readonly IAppLogger&lt;LoggingDomainEventDispatcher&gt; _logger;\n    private readonly ILogContext _context;\n\n    public LoggingDomainEventDispatcher(IDomainEventDispatcher inner, IAppLogger&lt;LoggingDomainEventDispatcher&gt; logger, ILogContext context)\n    {\n        _inner = inner;\n        _logger = logger;\n        _context = context;\n    }\n\n    public async Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct = default)\n    {\n        _logger.Info(\"Dispatching domain event\", new Dictionary&lt;string, object?&gt;\n        {\n            [\"EventType\"] = domainEvent.GetType().Name,\n            [\"EventId\"] = domainEvent.Id,\n            [\"CorrelationId\"] = domainEvent.CorrelationId ?? _context.CorrelationId\n        });\n        await _inner.DispatchAsync(domainEvent, ct);\n    }\n\n    public async Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; domainEvents, CancellationToken ct = default)\n    {\n        foreach (var e in domainEvents)\n        {\n            await DispatchAsync(e, ct);\n        }\n    }\n}\n</code></pre> - Decorators let you log without changing handler or dispatcher implementations.</p>"},{"location":"extensions/core-domain-events/#patterns-and-guidance","title":"Patterns and guidance","text":"<ul> <li>Set correlation at creation time: Pass <code>ILogContext.CorrelationId</code> into domain event constructors in factories/handlers so it flows everywhere.</li> <li>Drain after dispatch: When using trackers, call <code>Drain()</code> to get a snapshot and clear them, mirroring the EF interceptor behavior.</li> <li>Avoid double dispatch: If you keep the template interceptor, ensure you\u2019re not also manually dispatching the same events. Choose one dispatch path per unit of work.</li> <li>Event ordering: <code>DomainEventTracker</code> preserves insertion order. If ordering matters across aggregates, consider sequencing or timestamp-based ordering in your dispatcher.</li> <li>Exception handling: Decide whether dispatcher exceptions should fail the transaction (typical) or be retried via outbox. The abstraction lets you choose.</li> <li>Background jobs: When handling commands in background workers, you can still use the same behaviors; ensure a correlation ID is set (middleware or behavior).</li> </ul>"},{"location":"extensions/core-domain-events/#testing-domain-events","title":"Testing domain events","text":"<p>Using the tracker + mediator dispatcher: <pre><code>[Fact]\npublic async Task DispatchAsync_Publishes_All_Tracked_Events()\n{\n    var tracker = new DomainEventTracker();\n    var published = new List&lt;DomainEvent&gt;();\n    var dispatcher = new StubDispatcher(published);\n    tracker.Add(new TestEvent(\"corr-1\"));\n    tracker.Add(new TestEvent(\"corr-1\"));\n\n    await dispatcher.DispatchAsync(tracker.Drain());\n\n    published.Should().HaveCount(2);\n    published.All(e =&gt; e.CorrelationId == \"corr-1\").Should().BeTrue();\n}\n\nfile sealed class TestEvent(string? CorrelationId = null) : DomainEvent(CorrelationId);\nfile sealed class StubDispatcher(List&lt;DomainEvent&gt; published) : IDomainEventDispatcher\n{\n    public Task DispatchAsync(DomainEvent domainEvent, CancellationToken ct = default)\n    {\n        published.Add(domainEvent);\n        return Task.CompletedTask;\n    }\n\n    public Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; domainEvents, CancellationToken ct = default)\n    {\n        published.AddRange(domainEvents);\n        return Task.CompletedTask;\n    }\n}\n</code></pre></p>"},{"location":"extensions/core-domain-events/#integration-with-results-and-logging","title":"Integration with Results and logging","text":"<ul> <li>Use the same correlation ID across Results, logs, and events:</li> <li><code>var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");</code></li> <li>Pass to domain events: <code>new OrderSubmittedEvent(orderId, correlationId)</code>.</li> <li>Return <code>Result.Success(orderId, correlationId)</code>.</li> <li>Logging adapters can add <code>CorrelationId</code> to scopes; event dispatchers can log using the same ID, making troubleshooting and tracing straightforward.</li> </ul>"},{"location":"extensions/core-domain-events/#migration-from-template","title":"Migration from template","text":"<ul> <li>Replace <code>BaseEvent</code> with Core <code>DomainEvent</code> to get correlation and timestamps. Existing handlers still work because it\u2019s an <code>INotification</code>.</li> <li>Optionally replace <code>DispatchDomainEventsInterceptor</code> with a version that uses <code>DomainEventTracker</code> + <code>IDomainEventDispatcher</code> if you need more control (outbox, bus).</li> <li>Keep <code>BaseEntity</code> domain event list concept; ensure your entities expose/clear events just like the template.</li> <li>You can mix old and new event types during migration; MediatR can handle both.</li> </ul>"},{"location":"extensions/core-domain-events/#faq","title":"FAQ","text":"<ul> <li>Do I need a tracker if I use EF interceptor? Not strictly. The interceptor can dispatch directly. Use the tracker when you want to buffer events, inspect them, or reuse in non-EF contexts.</li> <li>Can I publish to a message bus? Yes\u2014implement <code>IDomainEventDispatcher</code> to translate events to bus messages. Use correlation IDs for tracing across services.</li> <li>Should events carry state or IDs? Prefer IDs and minimal snapshots. Use handlers to load additional data if needed. Keep payloads lean to avoid duplication and staleness.</li> <li>How do I avoid duplicate publishes? Ensure each event is cleared after dispatch. When using outbox, let the outbox process ensure exactly-once semantics for external delivery.</li> <li>What about transactions? For in-process MediatR handlers, dispatch before commit to keep consistency, or use outbox to decouple. The abstraction lets you choose per use case.</li> </ul>"},{"location":"extensions/core-domain-events/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Introduce <code>DomainEvent</code> for new events; add <code>CorrelationId</code> when available from <code>ILogContext</code>. 2) Register <code>IDomainEventDispatcher</code> (mediator, outbox, or bus) and optionally <code>DomainEventTracker</code>. 3) If using EF, wire an interceptor (or replace the template interceptor) that collects events and dispatches via the dispatcher. 4) Standardize event naming and payloads; keep them immutable and small. 5) Update tests to assert on <code>DomainEventTracker</code> contents or dispatcher invocations. 6) Log dispatches (via decorator) if you need observability of event publication paths.</p>"},{"location":"extensions/core-domain-events/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for correlation/logging that feeds correlation IDs into events.</li> <li>Core logging abstractions for scopes/adapters used by dispatchers.</li> <li>Core result primitives to align correlation IDs across results and events.</li> <li>Core guard clauses for input validation that may precede event emission.</li> <li>Core extension overview for the package-level summary and registration guidance.</li> </ul>"},{"location":"extensions/core-guard-clauses/","title":"Core Guard Clauses","text":"<p>Guard clauses in the Core extension give you a consistent, testable way to enforce invariants without scattering <code>if/throw</code> statements across handlers and entities. They pair with the extension\u2019s <code>Result</code> primitives so you can choose return-based validation (preferred for application flows) or exception-based validation (when you rely on middleware). This page explains how the Clean Architecture template handles validation today, why the extension adds more flexible guards, and how to integrate them with pipelines, Results, and domain logic.</p>"},{"location":"extensions/core-guard-clauses/#what-the-template-already-covers","title":"What the template already covers","text":"<p>Jason Taylor\u2019s template leans on two mechanisms:</p> <ul> <li>FluentValidation + MediatR ValidationBehaviour: Validators throw <code>ValidationException</code> when rules fail. Controllers/middleware translate those exceptions into ProblemDetails responses.</li> <li>Ad hoc checks: Handlers and services sometimes do simple <code>if (string.IsNullOrWhiteSpace(...)) throw ...;</code> for quick guards. There is no common error shape or trace propagation.</li> <li>Result type is minimal: The template\u2019s <code>Result</code> is <code>Succeeded + string[] Errors</code> and is mainly used in Identity flows; it does not pair with guard outcomes elsewhere.</li> </ul> <p>This works for demos but makes it harder to:</p> <ul> <li>Return structured errors without throwing.</li> <li>Accumulate multiple guard failures for richer UX.</li> <li>Keep correlation/trace IDs attached to validation failures.</li> <li>Reuse guard logic in domain entities without bringing FluentValidation into the domain layer.</li> </ul>"},{"location":"extensions/core-guard-clauses/#why-use-core-guard-clauses","title":"Why use Core guard clauses","text":"<p>The Core package introduces a focused guard library that aligns with the template\u2019s MediatR wiring while keeping your domain/application code technology-agnostic:</p> <ul> <li>Strategy-driven: Choose per-call whether to return <code>Result</code> failures (<code>ReturnFailure</code>), throw (<code>Throw</code>), or accumulate errors (<code>Accumulate</code>) into a shared sink.</li> <li>Trace-friendly: Guards accept <code>GuardOptions.TraceId</code>; failures propagate trace IDs into <code>Error</code> instances, staying aligned with correlation behaviors.</li> <li>Result-native: Guards produce <code>Result&lt;T&gt;</code> (or <code>Result</code>) so you can compose with <code>Map/Bind/Combine</code> instead of relying on exceptions.</li> <li>Domain-ready: No FluentValidation dependency; the API is simple enough to use inside aggregates while keeping error metadata consistent with the application layer.</li> <li>Batch-aware: <code>Accumulate</code> lets you gather multiple failures (e.g., CSV import) and report them together.</li> </ul>"},{"location":"extensions/core-guard-clauses/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.Guards</code></p> <p>Guards:</p> <ul> <li><code>AgainstNull&lt;T&gt;(value, parameterName, options?)</code></li> <li><code>AgainstNullOrWhiteSpace(string?, parameterName, options?)</code></li> <li><code>AgainstOutOfRange&lt;T&gt;(value, min, max, parameterName, options?) where T : IComparable&lt;T&gt;</code></li> <li><code>AgainstUndefinedEnum&lt;TEnum&gt;(value, parameterName, options?) where TEnum : struct, Enum</code></li> <li><code>AgainstTooShort(string value, minLength, parameterName, options?)</code></li> <li><code>AgainstTooLong(string value, maxLength, parameterName, options?)</code></li> <li><code>Ensure(bool condition, code, message, options?)</code></li> </ul> <p>Support types:</p> <ul> <li><code>GuardOptions</code> (strategy, error sink, exception factory, trace ID; plus <code>FromOptions(CoreExtensionsOptions, errorSink?)</code>).</li> <li><code>GuardStrategy</code> (<code>ReturnFailure</code>, <code>Throw</code>, <code>Accumulate</code>).</li> </ul> <p>Outputs:</p> <ul> <li><code>Result&lt;T&gt;</code> or <code>Result</code> from the Core Result primitives, carrying <code>Error</code> objects with <code>Code</code>, <code>Message</code>, <code>TraceId</code>.</li> </ul>"},{"location":"extensions/core-guard-clauses/#strategy-modes-explained","title":"Strategy modes explained","text":"<ul> <li>ReturnFailure (default): Guards return <code>Result</code>/<code>Result&lt;T&gt;</code> failures. Handlers can short-circuit or combine errors. No exceptions are thrown.</li> <li>Throw: Guards throw immediately. If you prefer exception-driven flows (e.g., existing middleware for 400s), set <code>GuardOptions.Strategy = GuardStrategy.Throw</code> or configure <code>CoreExtensionsOptions.GuardStrategy</code>.</li> <li>Accumulate: Guard errors are added to an <code>ICollection&lt;Error&gt;</code> sink (provided via <code>GuardOptions.ErrorSink</code>), and a failure <code>Result</code> is returned. Use this for batch operations where you want to report all issues at once.</li> </ul> <p><code>ExceptionFactory</code> lets you shape exceptions when <code>Throw</code> is selected (e.g., custom domain exceptions).</p>"},{"location":"extensions/core-guard-clauses/#comparing-to-template-validation","title":"Comparing to template validation","text":"<ul> <li>FluentValidation Behaviour: Runs after <code>AuthorizationBehaviour</code> and before <code>PerformanceBehaviour</code>. Throws <code>ValidationException</code> on first validation failure batch.</li> <li>Core Guards: Can run inside the handler or domain entity. When configured to return failures, they avoid exceptions and keep control in the handler. You can still use FluentValidation for complex cross-field rules while using guards for fast, local checks.</li> <li>Blended approach: Use guards for early, cheap validations (null/length/range) and FluentValidation for business rules that benefit from rich tooling and localization. Both can coexist because guards do not change pipeline signatures.</li> </ul>"},{"location":"extensions/core-guard-clauses/#installation-refresher","title":"Installation refresher","text":"<p>If you have not yet installed the Core extension:</p> <pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Core\n</code></pre> <p>Register <code>CoreExtensionsOptions</code> in DI so guards can inherit defaults:</p> <pre><code>services.AddCleanArchitectureCore(options =&gt;\n{\n    options.GuardStrategy = GuardStrategy.ReturnFailure;\n});\n</code></pre>"},{"location":"extensions/core-guard-clauses/#quick-start-examples-backed-by-the-guard-sample","title":"Quick-start examples (backed by the guard sample)","text":"<p>A runnable solution that demonstrates each strategy lives at <code>samples/CleanArchitecture.Extensions.Core.Guards.Sample</code>.</p>"},{"location":"extensions/core-guard-clauses/#short-circuit-on-first-failure-returnfailure","title":"Short-circuit on first failure (ReturnFailure)","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Guards.Sample/src/Application/Projects/Commands/CreateProject/CreateProject.cs</code>:</p> <pre><code>var traceId = Guid.NewGuid().ToString(\"N\");\nvar guardOptions = new CoreGuardOptions { TraceId = traceId };\n\nvar name = CoreGuard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name), guardOptions)\n    .Ensure(n =&gt; n.Length &lt;= MaxNameLength, new CoreResults.Error(\"projects.name.length\", $\"Name must be {MaxNameLength} characters or fewer.\", traceId));\n\nvar description = string.IsNullOrWhiteSpace(request.Description)\n    ? CoreResults.Result.Success&lt;string?&gt;(null, traceId)\n    : CoreGuard.AgainstTooLong(request.Description, MaxDescriptionLength, nameof(request.Description), guardOptions)\n        .Map(value =&gt; (string?)value.Trim(), traceId);\n\nvar budget = CoreGuard.Ensure(request.Budget &gt;= 0,\n    \"projects.budget.range\",\n    \"Budget cannot be negative.\",\n    guardOptions);\n\nvar validation = CoreResults.Result.Combine(name, description, budget);\nif (validation.IsFailure)\n{\n    return CoreResults.Result.Failure&lt;int&gt;(validation.Errors, traceId);\n}\n</code></pre> <ul> <li>Guards stay branch-light until all cheap checks run, then short-circuit with a single <code>Result.Combine</code> failure.</li> <li>The handler continues on success to check duplicates and persist, preserving the same <code>traceId</code>.</li> </ul>"},{"location":"extensions/core-guard-clauses/#accumulate-multiple-failures-batch-import","title":"Accumulate multiple failures (batch import)","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Guards.Sample/src/Application/Projects/Commands/ImportProjects/ImportProjects.cs</code>:</p> <pre><code>var sink = new List&lt;CoreResults.Error&gt;();\nvar guardOptions = new CoreGuardOptions\n{\n    Strategy = GuardStrategy.Accumulate,\n    ErrorSink = sink,\n    TraceId = traceId\n};\n\nfor (var index = 0; index &lt; incoming.Count; index++)\n{\n    var project = incoming[index];\n    var beforeCount = sink.Count;\n\n    var nameResult = CoreGuard.AgainstNullOrWhiteSpace(project.Name, nameof(project.Name), guardOptions)\n        .Ensure(n =&gt; n.Length &lt;= MaxNameLength, new CoreResults.Error(\"projects.name.length\", $\"Name must be {MaxNameLength} characters or fewer.\", traceId));\n\n    var budgetResult = CoreGuard.Ensure(project.Budget &gt;= 0, \"projects.budget.range\", \"Budget cannot be negative.\", guardOptions);\n\n    if (nameResult.IsSuccess &amp;&amp; budgetResult.IsSuccess)\n    {\n        projects.Add(new Project(project.Name.Trim(), project.Description, project.Budget));\n    }\n    else\n    {\n        AddRowMetadata(sink, beforeCount, index + 1);\n    }\n}\n\nif (sink.Count &gt; 0)\n{\n    return CoreResults.Result.Failure&lt;IReadOnlyList&lt;int&gt;&gt;(sink, traceId);\n}\n</code></pre> <ul> <li><code>GuardStrategy.Accumulate</code> keeps looping and decorates new errors with a <code>row</code> metadata entry so the client can show all issues at once.</li> <li>Only when the sink is empty do we add the batch to the DbContext and save.</li> </ul>"},{"location":"extensions/core-guard-clauses/#throwing-for-exception-first-pipelines","title":"Throwing for exception-first pipelines","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Guards.Sample/src/Application/Projects/Commands/ArchiveProjectWithThrow/ArchiveProjectWithThrow.cs</code>:</p> <pre><code>var guardOptions = new CoreGuardOptions\n{\n    Strategy = GuardStrategy.Throw,\n    ExceptionFactory = error =&gt; new InvalidOperationException($\"{error.Code}: {error.Message}\")\n};\n\nvar project = await _context.Projects.FirstOrDefaultAsync(p =&gt; p.Id == request.Id, cancellationToken);\n\nCoreGuard.AgainstNull(project, nameof(project), guardOptions);\nCoreGuard.Ensure(!project!.IsArchived, \"projects.archived\", \"Project is already archived.\", guardOptions);\n\nproject.Archive(DateTimeOffset.UtcNow);\nawait _context.SaveChangesAsync(cancellationToken);\n</code></pre> <ul> <li>When <code>Throw</code> is chosen, guards raise exceptions immediately. In the sample API, the endpoint catches and translates them to a 400 response to demonstrate exception-first wiring.</li> </ul>"},{"location":"extensions/core-guard-clauses/#detailed-guard-behaviors","title":"Detailed guard behaviors","text":"<ul> <li>Trace propagation: When <code>TraceId</code> is set in options, every guard-generated error carries it. If omitted, the guard produces errors without a trace; you can still attach a trace later when turning guard results into handler results.</li> <li>Error codes: Each guard uses a stable code:</li> <li><code>guard.null</code></li> <li><code>guard.empty</code></li> <li><code>guard.range</code></li> <li><code>guard.enum</code></li> <li><code>guard.length</code></li> <li>custom code for <code>Ensure</code> (you pass it).     Use these codes for client-side localization or analytics.</li> <li>Messages: Default English messages are provided. If you need localization, wrap guards in a helper that maps codes to localized strings, or set <code>ExceptionFactory</code> to craft localized exceptions when throwing.</li> <li>Range check semantics: <code>AgainstOutOfRange</code> is inclusive (<code>minimum &lt;= value &lt;= maximum</code>). For exclusive checks, call it with adjusted bounds or add an <code>Ensure</code> with your own predicate.</li> <li>Enum checks: <code>AgainstUndefinedEnum</code> defends against undefined numeric casts or new values introduced without handler changes.</li> <li>Length checks: <code>AgainstTooShort</code> and <code>AgainstTooLong</code> operate on <code>string.Length</code>; for grapheme-aware length, add a custom guard using <code>Ensure</code>.</li> </ul>"},{"location":"extensions/core-guard-clauses/#composition-with-result-helpers","title":"Composition with Result helpers","text":"<p>Because guards return Results, you can compose them without <code>if</code> ladders:</p> <pre><code>public Result&lt;CheckoutRequest&gt; Validate(CheckoutRequest input, GuardOptions options)\n{\n    return Guard.AgainstNullOrWhiteSpace(input.CustomerId, \"CustomerId\", options)\n        .Bind(_ =&gt; Guard.AgainstOutOfRange(input.Items.Count, 1, 100, \"Items.Count\", options))\n        .Bind(_ =&gt; Guard.Ensure(input.Currency == \"USD\", \"checkout.currency\", \"Only USD supported\", options))\n        .Map(_ =&gt; input);\n}\n</code></pre> <ul> <li><code>Bind</code> short-circuits on first failure.</li> <li><code>Ensure</code> inserts custom predicate-based checks without new guard methods.</li> <li><code>Map</code> wraps the validated input back into the result, preserving the trace ID.</li> </ul>"},{"location":"extensions/core-guard-clauses/#using-guards-in-domain-entities","title":"Using guards in domain entities","text":"<p>Domain entities should not depend on FluentValidation. Guards give you lightweight checks while keeping errors structured:</p> <pre><code>public sealed class Money\n{\n    public string Currency { get; }\n    public decimal Amount { get; }\n\n    private Money(string currency, decimal amount)\n    {\n        Currency = currency;\n        Amount = amount;\n    }\n\n    public static Result&lt;Money&gt; Create(string currency, decimal amount, GuardOptions options)\n    {\n        return Guard.AgainstNullOrWhiteSpace(currency, nameof(currency), options)\n            .Bind(_ =&gt; Guard.AgainstOutOfRange(amount, 0m, 1_000_000m, nameof(amount), options))\n            .Map(_ =&gt; new Money(currency.Trim().ToUpperInvariant(), amount));\n    }\n}\n</code></pre> <ul> <li>The factory returns <code>Result&lt;Money&gt;</code>; handlers can propagate failures, aggregate them, or translate them into API responses without throwing.</li> </ul>"},{"location":"extensions/core-guard-clauses/#integrating-with-mediatr-pipelines","title":"Integrating with MediatR pipelines","text":"<ul> <li>Ordering: Use guards inside handlers before hitting infrastructure. If you prefer middleware-level handling, set strategy to <code>Throw</code> and let <code>UnhandledExceptionBehaviour</code> or your API middleware translate exceptions.</li> <li>Correlation: Run <code>CorrelationBehavior</code> early so <code>ILogContext.CorrelationId</code> is set. Pass that ID into <code>GuardOptions.TraceId</code> to keep guard errors aligned with logs.</li> <li>PerformanceBehavior: Guards are synchronous and cheap; they do not materially affect elapsed timing unless used in tight loops on large collections (batch validation). In those cases, consider aggregating and emitting a single performance log.</li> </ul>"},{"location":"extensions/core-guard-clauses/#working-with-fluentvalidation","title":"Working with FluentValidation","text":"<ul> <li>Complementary roles: Use guards for fast, mechanical checks (null/length/range) and FluentValidation for richer, cross-field rules or localized error messages.</li> <li>Avoid double work: If FluentValidation already covers a rule, do not duplicate it with guards unless you want early short-circuiting before expensive operations (e.g., DB calls).</li> <li>Shared error shape: You can map <code>ValidationFailure</code> to <code>Error</code> to stay consistent with guard outputs:</li> </ul> <pre><code>var errors = failures.Select(f =&gt;\n    new Error($\"validation.{f.PropertyName.ToLowerInvariant()}\", f.ErrorMessage, traceId));\nreturn Result.Failure&lt;TResponse&gt;(errors, traceId);\n</code></pre>"},{"location":"extensions/core-guard-clauses/#configuration-via-coreextensionsoptions","title":"Configuration via CoreExtensionsOptions","text":"<p><code>GuardOptions.FromOptions(CoreExtensionsOptions options, ICollection&lt;Error&gt;? errorSink = null)</code> lets you centralize defaults:</p> <ul> <li><code>GuardStrategy</code> (default <code>ReturnFailure</code>).</li> <li><code>TraceId</code> default.</li> <li>Injected <code>ErrorSink</code> when you want accumulation.   Set <code>Extensions:Core:GuardStrategy</code> in configuration to change the default behavior across the app, then override per call as needed.</li> </ul>"},{"location":"extensions/core-guard-clauses/#error-accumulation-patterns","title":"Error accumulation patterns","text":"<p>For scenarios where you must present all issues (e.g., admin bulk imports), combine <code>Accumulate</code> with <code>Result.Combine</code>:</p> <pre><code>var sink = new List&lt;Error&gt;();\nvar options = new GuardOptions { Strategy = GuardStrategy.Accumulate, ErrorSink = sink, TraceId = traceId };\n\nGuard.AgainstTooShort(user.FirstName, 2, \"FirstName\", options);\nGuard.AgainstTooShort(user.LastName, 2, \"LastName\", options);\nGuard.Ensure(user.Email.Contains('@'), \"user.email\", \"Email is invalid\", options);\n\nreturn sink.Count == 0\n    ? Result.Success(options.TraceId)\n    : Result.Failure(sink, options.TraceId);\n</code></pre> <ul> <li>You can still return a single <code>Result</code> to the caller while surfacing all errors.</li> </ul>"},{"location":"extensions/core-guard-clauses/#httpapi-translation","title":"HTTP/API translation","text":"<p>Pair guard-produced errors with ProblemDetails:</p> <pre><code>var result = await mediator.Send(command, ct);\nif (result.IsFailure)\n{\n    var problems = result.Errors.Select(e =&gt; new { e.Code, e.Message, e.TraceId, e.Metadata });\n    return Results.Problem(\n        title: \"Validation failed\",\n        statusCode: StatusCodes.Status400BadRequest,\n        detail: \"One or more validation errors occurred.\",\n        extensions: new Dictionary&lt;string, object?&gt;\n        {\n            [\"errors\"] = problems,\n            [\"traceId\"] = result.TraceId\n        });\n}\nreturn Results.Ok(new { result.Value, traceId = result.TraceId });\n</code></pre> <ul> <li>Clients get consistent codes/messages and a trace ID for troubleshooting.</li> </ul>"},{"location":"extensions/core-guard-clauses/#testing-guards","title":"Testing guards","text":"<ul> <li>Deterministic: Guards have no time dependency. You can assert on <code>IsSuccess</code>, <code>Errors.Count</code>, <code>Error.Code</code>, and <code>TraceId</code>.</li> <li>Example:</li> </ul> <pre><code>[Fact]\npublic void AgainstTooShort_ReturnsError_WhenBelowThreshold()\n{\n    var options = new GuardOptions { TraceId = \"unit-1\" };\n    var result = Guard.AgainstTooShort(\"ab\", 3, \"Name\", options);\n\n    result.IsFailure.Should().BeTrue();\n    result.Errors.Single().Code.Should().Be(\"guard.length\");\n    result.TraceId.Should().Be(\"unit-1\");\n}\n</code></pre> <ul> <li>Accumulate mode: Assert that the error sink contains all errors and that the returned <code>Result</code> is failure.</li> </ul>"},{"location":"extensions/core-guard-clauses/#performance-considerations","title":"Performance considerations","text":"<ul> <li>Guards are lightweight and allocation-friendly (simple Error structs, minimal collections). The main cost in accumulation mode is list growth; reuse sinks where appropriate for large batches.</li> <li>For high-frequency hot paths, prefer <code>ReturnFailure</code> to avoid exception costs. Reserve <code>Throw</code> for places where exceptions are part of your existing contract.</li> </ul>"},{"location":"extensions/core-guard-clauses/#extending-guards","title":"Extending guards","text":"<p>You can add custom guards alongside the built-ins by wrapping <code>Ensure</code>:</p> <pre><code>public static class GuardExtras\n{\n    public static Result&lt;T&gt; AgainstWeekend&lt;T&gt;(DateOnly date, string parameterName, GuardOptions? options = null)\n    {\n        var isWeekend = date.DayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday;\n        return Guard.Ensure(!isWeekend, $\"date.{parameterName}.weekend\", $\"{parameterName} cannot fall on a weekend.\", options)\n            .Map(_ =&gt; (T)(object)date); // or return Result.Success(date, options?.TraceId)\n    }\n}\n</code></pre> <p>Keep codes prefixed by the domain area to avoid collisions (<code>inventory.*</code>, <code>billing.*</code>, etc.).</p>"},{"location":"extensions/core-guard-clauses/#adoption-playbook","title":"Adoption playbook","text":"<ol> <li>Configure defaults: Set <code>Extensions:Core:GuardStrategy</code> to <code>ReturnFailure</code> (recommended). Enable a correlation-aware <code>TraceId</code> if you have one.</li> <li>Update new handlers: Use guards at the top of handlers to validate inputs, returning <code>Result&lt;T&gt;</code> on failure.</li> <li>Add accumulation for batch workflows: Introduce <code>Accumulate</code> + sinks where you previously looped over items with ad hoc validation.</li> <li>Bridge to existing exception flows: Where middleware expects exceptions, set strategy to <code>Throw</code> or wrap guard results in exceptions until you migrate clients.</li> <li>Refine codes/messages: Standardize error codes across teams. Document them near your domain services or in a shared constants file.</li> </ol>"},{"location":"extensions/core-guard-clauses/#reference-methods-and-codes","title":"Reference: Methods and codes","text":"<ul> <li><code>AgainstNull</code> \u2192 <code>guard.null</code></li> <li><code>AgainstNullOrWhiteSpace</code> \u2192 <code>guard.empty</code></li> <li><code>AgainstOutOfRange</code> \u2192 <code>guard.range</code></li> <li><code>AgainstUndefinedEnum</code> \u2192 <code>guard.enum</code></li> <li><code>AgainstTooShort</code> \u2192 <code>guard.length</code></li> <li><code>AgainstTooLong</code> \u2192 <code>guard.length</code></li> <li><code>Ensure</code> \u2192 user-supplied code</li> </ul>"},{"location":"extensions/core-guard-clauses/#related-docs","title":"Related docs","text":"<ul> <li>Core extension overview for pipeline behaviors, logging, time, domain events, and options.</li> <li>Core Result Primitives to see how guard outputs compose with results and downstream handlers.</li> <li>Validation extension when you need FluentValidation-driven behaviors in addition to guards.</li> </ul>"},{"location":"extensions/core-logging-abstractions/","title":"Core Logging Abstractions","text":"<p>Logging in Clean Architecture is intentionally minimal in Jason Taylor\u2019s template: it relies on <code>ILogger&lt;T&gt;</code> plus user/context services inside MediatR behaviors. The Core extension adds provider-agnostic logging and context abstractions so you can swap providers, capture correlation, and test without mocking concrete logging frameworks. This page explains the template baseline, what the Core abstractions add, how to wire them, and how to adapt them to providers like Microsoft.Extensions.Logging (MEL) or Serilog. It also shows how correlation and Results fit together so logs, errors, and responses share identifiers.</p>"},{"location":"extensions/core-logging-abstractions/#what-the-template-already-covers","title":"What the template already covers","text":"<ul> <li>Behaviors: <code>LoggingBehaviour&lt;TRequest&gt;</code> (pre-processor) uses <code>ILogger&lt;TRequest&gt;</code>, <code>IUser</code>, and <code>IIdentityService</code> to log the request name, user ID, and user name. <code>PerformanceBehaviour</code> uses <code>ILogger&lt;TRequest&gt;</code> with a <code>Stopwatch</code> to warn on slow requests (&gt;500 ms). <code>UnhandledExceptionBehaviour</code> logs exceptions with <code>ILogger&lt;TRequest&gt;</code>.</li> <li>Context: There is no dedicated log context abstraction. Correlation is not explicitly propagated; any correlation is left to ambient scopes set by the hosting pipeline.</li> <li>Result + errors: The template\u2019s <code>Result</code> has <code>Succeeded</code> and <code>string[] Errors</code>; logs do not attach trace IDs or structured error metadata.</li> <li>Time: Behaviors depend directly on <code>Stopwatch</code>/system time, not an abstraction.</li> </ul> <p>This setup is fine for demos, but teams often need: - Consistent correlation IDs across logs, results, and HTTP responses. - Provider-agnostic logging contracts so Application layer code and behaviors don\u2019t depend on MEL. - In-memory/no-op loggers for tests and quiet scenarios. - Structured properties without coupling to a specific logger\u2019s API.</p>"},{"location":"extensions/core-logging-abstractions/#what-the-core-logging-abstractions-add","title":"What the Core logging abstractions add","text":"<ul> <li>Interfaces, not providers: <code>IAppLogger&lt;T&gt;</code> mirrors common log levels but stays provider-neutral. <code>ILogContext</code> stores correlation ID and exposes <code>PushProperty</code> for scoped properties.</li> <li>Implementations for tests/quiet runs: <code>InMemoryAppLogger&lt;T&gt;</code> captures entries with correlation and properties; <code>NoOpAppLogger&lt;T&gt;</code> discards logs. <code>InMemoryLogContext</code> stores properties in-memory with scoped push/pop; <code>NoOpLogContext</code> is a no-op scope holder.</li> <li>Structured entries: <code>LogEntry</code> record captures <code>Timestamp</code>, <code>Level</code>, <code>Message</code>, <code>CorrelationId</code>, optional <code>Exception</code>, and optional <code>Properties</code>.</li> <li>Integration with behaviors: Core pipeline behaviors depend on these abstractions, letting you plug in your provider with a small adapter.</li> <li>Correlation-first: <code>ILogContext.CorrelationId</code> is the single place for correlation used by behaviors; you can set it from HTTP headers or allow <code>CorrelationBehavior</code> to generate it.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.Logging</code></p> <ul> <li><code>IAppLogger&lt;T&gt;</code> with <code>Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)</code> plus convenience methods <code>Trace/Debug/Info/Warn/Error/Critical</code>.</li> <li><code>ILogContext</code> with <code>string? CorrelationId { get; set; }</code> and <code>IDisposable PushProperty(string name, object? value)</code>.</li> <li>Implementations:</li> <li><code>InMemoryAppLogger&lt;T&gt;</code> (stores entries thread-safely).</li> <li><code>NoOpAppLogger&lt;T&gt;</code> (ignores logs).</li> <li><code>InMemoryLogContext</code> (stores correlation ID + properties; supports scoped push/pop).</li> <li><code>NoOpLogContext</code> (does nothing; safe stub).</li> <li>Supporting types:</li> <li><code>LogEntry</code> record (timestamp, level, message, correlation ID, exception, properties).</li> <li><code>LogLevel</code> enum (Trace, Debug, Information, Warning, Error, Critical, None).</li> </ul>"},{"location":"extensions/core-logging-abstractions/#why-this-matters-for-clean-architecture","title":"Why this matters for Clean Architecture","text":"<ul> <li>Layer isolation: Application layer doesn\u2019t depend on MEL/Serilog; Infrastructure can choose the provider and supply adapters. Tests run without heavy logging dependencies.</li> <li>Correlation consistency: Behaviors ensure correlation IDs reach logs; handlers can propagate the same ID into Results and domain events.</li> <li>Observability readiness: Structured properties enable search and analytics (e.g., request type, elapsed time, tenant) without forcing a specific logging library.</li> <li>Testability: In-memory logger/context make assertions straightforward in unit/integration tests.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#wiring-in-di","title":"Wiring in DI","text":"<p>Minimum registration to get logging working with Core behaviors: <pre><code>services.AddCleanArchitectureCore(options =&gt;\n{\n    options.CorrelationHeaderName = \"X-Correlation-ID\";\n});\n</code></pre> If you need a different provider, replace <code>MelAppLoggerAdapter&lt;T&gt;</code> with your adapter; <code>ILogContext</code> can also be swapped for a provider-specific scope wrapper.</p>"},{"location":"extensions/core-logging-abstractions/#adapting-to-microsoftextensionslogging-mel","title":"Adapting to Microsoft.Extensions.Logging (MEL)","text":"<p>The package now ships <code>MelAppLoggerAdapter&lt;T&gt;</code>, which pushes <code>CorrelationId</code> into an <code>ILogger&lt;T&gt;</code> scope and logs structured properties. Swap it into DI (it\u2019s registered by default via <code>AddCleanArchitectureCore</code>) or replace it with your own adapter if you need custom enrichment.</p>"},{"location":"extensions/core-logging-abstractions/#adapting-to-serilog","title":"Adapting to Serilog","text":"<p><pre><code>public sealed class SerilogAppLogger&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    private readonly ILogger _logger; // Serilog.ILogger\n    private readonly ILogContext _context;\n\n    public SerilogAppLogger(ILogger logger, ILogContext context)\n    {\n        _logger = logger.ForContext(\"SourceContext\", typeof(T).FullName ?? typeof(T).Name);\n        _context = context;\n    }\n\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        var enriched = _logger.ForContext(\"CorrelationId\", _context.CorrelationId);\n        if (properties is { Count: &gt; 0 })\n        {\n            foreach (var kvp in properties)\n            {\n                enriched = enriched.ForContext(kvp.Key, kvp.Value, destructureObjects: true);\n            }\n        }\n\n        enriched.Write(Map(level), exception, message);\n    }\n\n    private Serilog.Events.LogEventLevel Map(LogLevel level) =&gt; level switch\n    {\n        LogLevel.Trace =&gt; Serilog.Events.LogEventLevel.Verbose,\n        LogLevel.Debug =&gt; Serilog.Events.LogEventLevel.Debug,\n        LogLevel.Information =&gt; Serilog.Events.LogEventLevel.Information,\n        LogLevel.Warning =&gt; Serilog.Events.LogEventLevel.Warning,\n        LogLevel.Error =&gt; Serilog.Events.LogEventLevel.Error,\n        LogLevel.Critical =&gt; Serilog.Events.LogEventLevel.Fatal,\n        _ =&gt; Serilog.Events.LogEventLevel.Information\n    };\n}\n</code></pre> Register with a Serilog-backed <code>ILogContext</code> (could wrap <code>LogContext.PushProperty</code> if desired).</p>"},{"location":"extensions/core-logging-abstractions/#sample-backed-walkthrough-logging-sample","title":"Sample-backed walkthrough (logging sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Logging.Sample</code>.</p>"},{"location":"extensions/core-logging-abstractions/#composite-logger-that-records-forwards-to-mel","title":"Composite logger that records + forwards to MEL","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Logging.Sample/src/Application/Common/Logging/CompositeAppLogger.cs</code>: <pre><code>public sealed class CompositeAppLogger&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        var correlationId = _logContext.CorrelationId;\n        using var correlationScope = _logger.BeginScope(new Dictionary&lt;string, object?&gt; { [\"CorrelationId\"] = correlationId });\n\n        IDisposable? propsScope = null;\n        if (properties is { Count: &gt; 0 })\n        {\n            propsScope = _logger.BeginScope(properties);\n        }\n\n        _logger.Log(MapLevel(level), exception, message);\n        propsScope?.Dispose();\n\n        _recorder.Record(new LogEntry(\n            DateTimeOffset.UtcNow,\n            level,\n            message,\n            correlationId,\n            exception,\n            properties));\n    }\n}\n</code></pre> - Logs flow to <code>ILogger&lt;T&gt;</code> scopes with correlation and are also stored in-memory via <code>ILogRecorder</code> for diagnostics.</p>"},{"location":"extensions/core-logging-abstractions/#correlation-middleware-diagnostics-endpoints","title":"Correlation middleware + diagnostics endpoints","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Logging.Sample/src/Web/Infrastructure/CorrelationMiddleware.cs</code> ensures every request has a correlation ID and pushes it into <code>ILogContext</code>.</p> <p><code>samples/CleanArchitecture.Extensions.Core.Logging.Sample/src/Application/Diagnostics/Commands/EmitLogPulse/EmitLogPulseCommand.cs</code> shows emitting structured logs with correlation and optional warning/error entries: <pre><code>var correlationId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n_logContext.CorrelationId = correlationId;\nusing var featureScope = _logContext.PushProperty(\"Feature\", \"LoggingSample\");\n\n_logger.Log(LogLevel.Information, $\"Received log pulse: {request.Message ?? \"(no message)\"}\", properties: properties);\n</code></pre> <code>GET /api/Diagnostics/logs</code> (see <code>.../Endpoints/Diagnostics.cs</code>) returns recent <code>LogEntry</code> items recorded by the in-memory recorder so you can see correlation + structured properties end-to-end.</p>"},{"location":"extensions/core-logging-abstractions/#correlation-flows","title":"Correlation flows","text":"<ul> <li><code>CorrelationBehavior</code> sets <code>ILogContext.CorrelationId</code> early in the pipeline.</li> <li><code>LoggingBehavior</code> uses <code>ILogContext</code> to push <code>CorrelationId</code> into scopes.</li> <li><code>PerformanceBehavior</code> includes <code>CorrelationId</code> in structured properties.</li> <li>Handlers can propagate <code>_logContext.CorrelationId</code> into <code>Result.TraceId</code> or <code>DomainEvent.CorrelationId</code>.</li> <li>HTTP middleware can set <code>ILogContext.CorrelationId</code> from <code>CoreExtensionsOptions.CorrelationHeaderName</code> and echo it back to clients.</li> </ul> <p>Example middleware: <pre><code>public class CorrelationMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogContext _context;\n    private readonly CoreExtensionsOptions _options;\n\n    public CorrelationMiddleware(RequestDelegate next, ILogContext context, IOptions&lt;CoreExtensionsOptions&gt; options)\n    {\n        _next = next;\n        _context = context;\n        _options = options.Value;\n    }\n\n    public async Task Invoke(HttpContext http)\n    {\n        var header = _options.CorrelationHeaderName;\n        var incoming = http.Request.Headers[header].FirstOrDefault();\n        _context.CorrelationId = string.IsNullOrWhiteSpace(incoming) ? _options.CorrelationIdFactory() : incoming;\n        using var scope = _context.PushProperty(\"CorrelationId\", _context.CorrelationId);\n        http.Response.Headers[header] = _context.CorrelationId!;\n        await _next(http);\n    }\n}\n</code></pre></p>"},{"location":"extensions/core-logging-abstractions/#using-inmemoryapplogger-in-tests","title":"Using InMemoryAppLogger in tests","text":"<p><pre><code>[Fact]\npublic async Task LoggingBehavior_WritesStartAndEnd_WithCorrelation()\n{\n    var clock = new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\"));\n    var context = new InMemoryLogContext { CorrelationId = \"corr-123\" };\n    var logger = new InMemoryAppLogger&lt;TestRequest&gt;(context);\n    var options = Microsoft.Extensions.Options.Options.Create(new CoreExtensionsOptions());\n    var behavior = new LoggingBehavior&lt;TestRequest, Unit&gt;(logger, context, clock, options);\n\n    await behavior.Handle(new TestRequest(), _ =&gt; Task.FromResult(Unit.Value), CancellationToken.None);\n\n    logger.Entries.Should().Contain(e =&gt; e.Message.Contains(\"Handling\") &amp;&amp; e.CorrelationId == \"corr-123\");\n    logger.Entries.Should().Contain(e =&gt; e.Message.Contains(\"Handled\") &amp;&amp; e.CorrelationId == \"corr-123\");\n}\n</code></pre> - <code>InMemoryAppLogger</code> captures correlation automatically from <code>ILogContext</code>.</p>"},{"location":"extensions/core-logging-abstractions/#handling-exceptions-and-errors","title":"Handling exceptions and errors","text":"<ul> <li>Behaviors don\u2019t automatically log exceptions; <code>UnhandledExceptionBehaviour</code> (template) still does that with <code>ILogger&lt;T&gt;</code>. You can adapt it to <code>IAppLogger&lt;T&gt;</code> or register a global exception middleware that logs via your adapter.</li> <li>You can log <code>Result</code> failures explicitly in handlers: <pre><code>if (result.IsFailure)\n{\n    _logger.Warn(\"Use case failed\", new Dictionary&lt;string, object?&gt;\n    {\n        [\"Errors\"] = result.Errors.Select(e =&gt; new { e.Code, e.Message, e.TraceId }),\n        [\"CorrelationId\"] = result.TraceId ?? _logContext.CorrelationId\n    });\n    return result;\n}\n</code></pre></li> </ul>"},{"location":"extensions/core-logging-abstractions/#properties-and-scopes","title":"Properties and scopes","text":"<ul> <li><code>ILogContext.PushProperty</code> returns an <code>IDisposable</code> scope; use <code>using</code> statements to ensure pop happens even on exceptions.</li> <li><code>InMemoryLogContext</code> keeps a dictionary of properties; it\u2019s primarily for tests/diagnostics. For production, adapt to your logger\u2019s native scope API (<code>BeginScope</code>, <code>LogContext.PushProperty</code>, etc.).</li> <li><code>NoOpLogContext</code> is safe for scenarios where you don\u2019t care about correlation or scopes (e.g., simple console apps).</li> </ul>"},{"location":"extensions/core-logging-abstractions/#configuration-touchpoints","title":"Configuration touchpoints","text":"<p>Logging abstractions themselves aren\u2019t configured via <code>CoreExtensionsOptions</code>, but they participate in options used by pipeline behaviors: - <code>CoreExtensionsOptions.CorrelationHeaderName</code> and <code>CorrelationIdFactory</code> affect correlation handling. - <code>CoreExtensionsOptions.EnablePerformanceLogging</code> and <code>PerformanceWarningThreshold</code> influence <code>PerformanceBehavior</code> logs. Set these in <code>appsettings</code> under <code>Extensions:Core</code>: <pre><code>{\n  \"Extensions\": {\n    \"Core\": {\n      \"CorrelationHeaderName\": \"X-Correlation-ID\",\n      \"EnablePerformanceLogging\": true,\n      \"PerformanceWarningThreshold\": \"00:00:00.500\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"extensions/core-logging-abstractions/#real-world-patterns","title":"Real-world patterns","text":""},{"location":"extensions/core-logging-abstractions/#enriching-logs-with-usertenant-without-coupling-handlers","title":"Enriching logs with user/tenant without coupling handlers","text":"<p><pre><code>public sealed class UserAwareLoggerAdapter&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    private readonly IAppLogger&lt;T&gt; _inner;\n    private readonly ICurrentUser _currentUser;\n\n    public UserAwareLoggerAdapter(IAppLogger&lt;T&gt; inner, ICurrentUser currentUser)\n    {\n        _inner = inner;\n        _currentUser = currentUser;\n    }\n\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        var enriched = new Dictionary&lt;string, object?&gt;(properties ?? new Dictionary&lt;string, object?&gt;())\n        {\n            [\"UserId\"] = _currentUser.Id,\n            [\"UserName\"] = _currentUser.UserName\n        };\n        _inner.Log(level, message, exception, enriched);\n    }\n}\n</code></pre> - Register <code>UserAwareLoggerAdapter&lt;T&gt;</code> as a decorator over your provider adapter.</p>"},{"location":"extensions/core-logging-abstractions/#logging-domain-events-with-correlation","title":"Logging domain events with correlation","text":"<p><pre><code>public sealed class DomainEventLoggingDispatcher : IDomainEventDispatcher\n{\n    private readonly IMediator _mediator;\n    private readonly IAppLogger&lt;DomainEventLoggingDispatcher&gt; _logger;\n    private readonly ILogContext _context;\n\n    public DomainEventLoggingDispatcher(IMediator mediator, IAppLogger&lt;DomainEventLoggingDispatcher&gt; logger, ILogContext context)\n    {\n        _mediator = mediator;\n        _logger = logger;\n        _context = context;\n    }\n\n    public async Task DispatchAsync(IEnumerable&lt;DomainEvent&gt; events, CancellationToken cancellationToken = default)\n    {\n        foreach (var e in events)\n        {\n            _logger.Info(\"Publishing domain event\", new Dictionary&lt;string, object?&gt;\n            {\n                [\"EventType\"] = e.GetType().Name,\n                [\"CorrelationId\"] = e.CorrelationId ?? _context.CorrelationId\n            });\n            await _mediator.Publish(e, cancellationToken);\n        }\n    }\n}\n</code></pre> - Correlation flows from <code>ILogContext</code> to domain events, keeping observability aligned.</p>"},{"location":"extensions/core-logging-abstractions/#quiet-mode-for-tests-or-local-dev","title":"Quiet mode for tests or local dev","text":"<ul> <li>Use <code>NoOpAppLogger&lt;T&gt;</code> and <code>NoOpLogContext</code> to suppress logs entirely.</li> <li>Switch to <code>InMemoryAppLogger</code> when you want to assert on log emission without external sinks.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#migration-guidance-from-the-template","title":"Migration guidance from the template","text":"<ul> <li>Keep using MEL/Serilog in Infrastructure, but inject adapters for <code>IAppLogger&lt;T&gt;</code> and <code>ILogContext</code>.</li> <li>Replace usages of <code>ILogger&lt;T&gt;</code> in new behaviors with <code>IAppLogger&lt;T&gt;</code> to avoid leaking provider dependencies into Application layer. Existing behaviors from the template can stay until you swap them for Core equivalents.</li> <li>In controllers or middleware, if you rely on <code>ILogger</code>, you can still do so; <code>IAppLogger</code> is primarily for Application layer and behaviors.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#testing-tips","title":"Testing tips","text":"<ul> <li>With <code>InMemoryAppLogger</code>, assert:</li> <li><code>Entries.Count</code> for expected log count.</li> <li><code>Entries.Any(e =&gt; e.Level == LogLevel.Warning &amp;&amp; e.Message.Contains(\"Long running\"))</code>.</li> <li><code>CorrelationId</code> presence matches <code>ILogContext.CorrelationId</code>.</li> <li>Use <code>FrozenClock</code> to make time-based properties deterministic when your adapter adds timestamps.</li> <li>When testing correlation middleware + behaviors end-to-end, set <code>ILogContext.CorrelationId</code> in middleware and ensure behavior logs carry the same value.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#faq","title":"FAQ","text":"<ul> <li>Do I have to abandon <code>ILogger</code>? No. Use adapters so Application code stays on <code>IAppLogger</code>; Infrastructure can still be MEL/Serilog. Existing <code>ILogger</code> usages in Web/Infrastructure remain valid.</li> <li>Where should I store correlation ID? In <code>ILogContext.CorrelationId</code>. Set it from middleware or let <code>CorrelationBehavior</code> generate it. Adapters should read it when creating scopes.</li> <li>Can I add scopes besides correlation? Yes\u2014<code>PushProperty</code> is generic. Add tenant ID, user ID, feature flag states, etc. Ensure sensitive data policies are followed.</li> <li>What about OpenTelemetry? Bridge <code>CorrelationId</code> to trace/span IDs in your adapter or middleware. The Core abstractions avoid a hard dependency on OTEL packages.</li> <li>Do the abstractions log JSON automatically? No. Serialization is handled by your provider. Properties are provided as structured objects; your adapter decides how to render them.</li> </ul>"},{"location":"extensions/core-logging-abstractions/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Register <code>ILogContext</code> and <code>IAppLogger&lt;T&gt;</code> implementations (NoOp/InMemory or provider adapters). 2) Ensure <code>CorrelationBehavior</code> and <code>LoggingBehavior</code> are registered so correlation and lifecycle logs flow. 3) Add middleware (optional) to source correlation IDs from incoming requests. 4) Decorate your logger adapter if you need user/tenant enrichment. 5) For tests, swap <code>IAppLogger&lt;T&gt;</code> with <code>InMemoryAppLogger&lt;T&gt;</code> and assert on <code>LogEntry</code> data. 6) Gradually replace direct <code>ILogger</code> usage in new Application components with <code>IAppLogger</code> to keep the Application layer decoupled from provider specifics.</p>"},{"location":"extensions/core-logging-abstractions/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for correlation/logging/performance behaviors that consume these abstractions.</li> <li>Core result primitives to see how trace IDs in results/errors align with correlation IDs in logs.</li> <li>Core guard clauses for guards that emit errors you might log with correlation.</li> <li>Core extension overview for the big-picture view and registration guidance.</li> </ul>"},{"location":"extensions/core-options/","title":"Core Options","text":"<p>The Core extension exposes a single options class\u2014<code>CoreExtensionsOptions</code>\u2014to configure correlation, guard behavior, and performance logging. While Jason Taylor\u2019s Clean Architecture template wires MediatR behaviors without centralized options, the Core package adds a cohesive configuration surface so you can control cross-cutting behavior from appsettings or DI. This page explains the template baseline, what options exist, how they affect guards, logging, pipeline behaviors, and how to use them in different environments (dev, test, prod).</p>"},{"location":"extensions/core-options/#template-baseline","title":"Template baseline","text":"<ul> <li>Behaviors: Template MediatR behaviors (<code>LoggingBehaviour</code>, <code>AuthorizationBehaviour</code>, <code>ValidationBehaviour</code>, <code>PerformanceBehaviour</code>, <code>UnhandledExceptionBehaviour</code>) are hard-coded\u2014no central options for thresholds or correlation.</li> <li>Correlation: No explicit correlation header or ID factory; logging relies on <code>ILogger&lt;T&gt;</code> scopes populated with user info.</li> <li>Guards: Template doesn\u2019t ship guard options; validation uses FluentValidation with exception throwing.</li> </ul>"},{"location":"extensions/core-options/#what-core-configures","title":"What Core configures","text":"<p><code>CoreExtensionsOptions</code> lives in <code>CleanArchitecture.Extensions.Core.Options</code> and governs: - <code>CorrelationHeaderName</code> (string, default <code>\"X-Correlation-ID\"</code>) - <code>GuardStrategy</code> (enum, default <code>ReturnFailure</code>) - <code>EnablePerformanceLogging</code> (bool, default <code>true</code>) - <code>PerformanceWarningThreshold</code> (TimeSpan, default 500 ms) - <code>CorrelationIdFactory</code> (<code>Func&lt;string&gt;</code>, default GUID \u201cN\u201d) - <code>TraceId</code> (string?, default <code>null</code>)</p>"},{"location":"extensions/core-options/#how-options-are-used-across-core","title":"How options are used across Core","text":"<ul> <li>Correlation behaviors: <code>CorrelationBehavior</code> uses <code>CorrelationIdFactory</code> when <code>ILogContext.CorrelationId</code> is missing. Controllers/middleware can use <code>CorrelationHeaderName</code> to read/write headers.</li> <li>Logging behavior: Uses <code>CorrelationBehavior</code>-set IDs; if none are set, it can seed correlation via <code>IClock.NewGuid()</code>\u2014you can align that with <code>CorrelationIdFactory</code> for consistency.</li> <li>Performance behavior: Respects <code>EnablePerformanceLogging</code> and <code>PerformanceWarningThreshold</code> to toggle logging and control warnings vs. debug logs.</li> <li>Guards: <code>GuardOptions.FromOptions</code> maps <code>GuardStrategy</code> and <code>TraceId</code> into guard calls; you can supply an error sink for accumulation.</li> <li>Results: <code>TraceId</code> can be propagated to Result/Errors for consistent tracing between logs, domain events, and HTTP responses.</li> </ul>"},{"location":"extensions/core-options/#registering-options-in-di","title":"Registering options in DI","text":"<p><pre><code>// Inline defaults for clarity; you can still bind from configuration if you prefer.\nservices.AddCleanArchitectureCore(options =&gt;\n{\n    options.CorrelationHeaderName = \"X-Correlation-ID\";\n    options.GuardStrategy = GuardStrategy.ReturnFailure;\n    options.EnablePerformanceLogging = true;\n    options.PerformanceWarningThreshold = TimeSpan.FromMilliseconds(500);\n});\n</code></pre> If you want to bind from configuration instead, call: <pre><code>services.AddCleanArchitectureCore(opts =&gt;\n    configuration.GetSection(\"Extensions:Core\").Bind(opts));\n</code></pre> You can still override programmatically: <pre><code>services.PostConfigure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.CorrelationIdFactory = () =&gt; $\"svc-{Guid.NewGuid():N}\";\n    options.PerformanceWarningThreshold = TimeSpan.FromMilliseconds(250);\n});\n</code></pre></p>"},{"location":"extensions/core-options/#configuration-via-appsettings-optional","title":"Configuration via appsettings (optional)","text":"<p><pre><code>{\n  \"Extensions\": {\n    \"Core\": {\n      \"CorrelationHeaderName\": \"X-Correlation-ID\",\n      \"GuardStrategy\": \"ReturnFailure\",\n      \"EnablePerformanceLogging\": true,\n      \"PerformanceWarningThreshold\": \"00:00:00.500\",\n      \"TraceId\": null\n    }\n  }\n}\n</code></pre> - Strings like <code>\"ReturnFailure\"</code> bind to <code>GuardStrategy</code>. - TimeSpan format is standard .NET (<code>hh:mm:ss.fff</code>). - <code>CorrelationIdFactory</code> cannot be bound via configuration; set it in code when registering options.</p>"},{"location":"extensions/core-options/#sample-backed-walkthrough-options-sample","title":"Sample-backed walkthrough (options sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Options.Sample</code>.</p>"},{"location":"extensions/core-options/#inspect-current-options-at-runtime","title":"Inspect current options at runtime","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Options.Sample/src/Application/Diagnostics/Queries/GetCoreOptions/GetCoreOptionsQuery.cs</code>: <pre><code>var value = _options.Value;\nvar dto = new CoreOptionsDto(\n    value.CorrelationHeaderName,\n    value.GuardStrategy,\n    value.EnablePerformanceLogging,\n    value.PerformanceWarningThreshold);\n</code></pre> - Exposed via <code>GET /api/Diagnostics/options</code> to see the live values bound from <code>appsettings.json</code> (correlation header, guard strategy, performance threshold).</p>"},{"location":"extensions/core-options/#drive-guard-behavior-from-options","title":"Drive guard behavior from options","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Options.Sample/src/Application/Diagnostics/Commands/EvaluateName/EvaluateNameCommand.cs</code>: <pre><code>var guardOptions = GuardOptions.FromOptions(_options.Value);\n\nvar result = CoreGuard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name), guardOptions)\n    .Ensure(n =&gt; n.Length &lt;= 50, new Error(\"diagnostics.name.length\", \"Name must be 50 characters or fewer.\", guardOptions.TraceId));\n</code></pre> - <code>POST /api/Diagnostics/guard</code> returns a Core <code>Result&lt;string&gt;</code>; switch <code>GuardStrategy</code> in config between <code>ReturnFailure</code> and <code>Throw</code> to see the behavior change without code changes. - Appsettings in the sample set <code>PerformanceWarningThreshold</code> to 750 ms and <code>CorrelationHeaderName</code> to <code>\"X-Correlation-ID\"</code> to show how pipeline behaviors and middleware pick them up.</p>"},{"location":"extensions/core-options/#environment-specific-guidance","title":"Environment-specific guidance","text":"<ul> <li>Development: Keep <code>EnablePerformanceLogging = true</code> and threshold at 500 ms for visibility. Consider human-readable correlation IDs (<code>dev-{Guid}</code>) for quick searches.</li> <li>Production: Standardize <code>CorrelationHeaderName</code> with your API gateway. Keep thresholds aligned with SLOs; raise if noise is high. Ensure correlation IDs are opaque (GUIDs) to avoid leaking info.</li> <li>Tests: Inject <code>TraceId</code> for deterministic assertions. You can turn off performance logging to reduce noise or set a very low threshold to assert warnings in tests.</li> </ul>"},{"location":"extensions/core-options/#using-options-with-guards","title":"Using options with guards","text":"<p><pre><code>var guardOptions = GuardOptions.FromOptions(coreOptions.Value);\nvar result = Guard.AgainstNullOrWhiteSpace(name, nameof(name), guardOptions);\nif (result.IsFailure) return Result.Failure&lt;string&gt;(result.Errors, result.TraceId);\n</code></pre> - <code>GuardStrategy</code> drives return/throw/accumulate. - <code>TraceId</code> flows into errors produced by guards. - For accumulation, pass an <code>ErrorSink</code> into <code>GuardOptions.FromOptions(options, sink)</code>.</p>"},{"location":"extensions/core-options/#using-options-with-pipeline-behaviors","title":"Using options with pipeline behaviors","text":"<p><pre><code>services.AddCleanArchitectureCore(options =&gt;\n    configuration.GetSection(\"Extensions:Core\").Bind(options));\n\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.AddCleanArchitectureCorePipeline();\n    cfg.AddOpenBehavior(typeof(UnhandledExceptionBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(AuthorizationBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(ValidationBehaviour&lt;,&gt;));\n});\n</code></pre> - PerformanceBehavior will skip logging if <code>EnablePerformanceLogging</code> is false. - CorrelationBehavior will use <code>CorrelationIdFactory</code> when no correlation ID is present.</p>"},{"location":"extensions/core-options/#patterns-and-scenarios","title":"Patterns and scenarios","text":""},{"location":"extensions/core-options/#1-matching-gatewayheader-expectations","title":"1) Matching gateway/header expectations","text":"<p>If your API gateway uses <code>X-Request-ID</code>, align it: <pre><code>services.AddCleanArchitectureCore(options =&gt;\n{\n    options.CorrelationHeaderName = \"X-Request-ID\";\n    options.CorrelationIdFactory = () =&gt; Guid.NewGuid().ToString(\"N\");\n});\n</code></pre> Ensure middleware echoes the same header; <code>CorrelationBehavior</code> will reuse IDs set in <code>ILogContext</code>.</p>"},{"location":"extensions/core-options/#2-tightening-performance-thresholds-for-hot-paths","title":"2) Tightening performance thresholds for hot paths","text":"<p><pre><code>services.AddCleanArchitectureCore(options =&gt;\n{\n    options.PerformanceWarningThreshold = TimeSpan.FromMilliseconds(200);\n});\n</code></pre> Use feature-specific options (named options) if some handlers are expected to run longer (e.g., reporting).</p>"},{"location":"extensions/core-options/#3-disabling-performance-logs-for-chatty-background-jobs","title":"3) Disabling performance logs for chatty background jobs","text":"<p><pre><code>services.AddCleanArchitectureCore(options =&gt;\n{\n    options.EnablePerformanceLogging = false;\n});\n</code></pre> This keeps noise down in queues/cron workers that run high-frequency MediatR requests.</p>"},{"location":"extensions/core-options/#4-correlation-id-strategy-per-environment","title":"4) Correlation ID strategy per environment","text":"<ul> <li>Dev: prefix with <code>dev-</code> for quick grep (<code>dev-{Guid}</code>).</li> <li>Staging/prod: opaque GUIDs. Set <code>CorrelationIdFactory</code> accordingly in environment-specific DI modules.</li> </ul>"},{"location":"extensions/core-options/#5-seeding-traceid-for-resultguard-flows","title":"5) Seeding TraceId for result/guard flows","text":"<p>For APIs that already have a trace/correlation token (e.g., from a reverse proxy): <pre><code>services.AddCleanArchitectureCore(options =&gt;\n{\n    options.TraceId = \"injected-from-middleware\"; // or set per-request in middleware using IOptionsSnapshot\n});\n</code></pre> Better: set <code>TraceId</code> per request using <code>IOptionsSnapshot&lt;CoreExtensionsOptions&gt;</code> and a middleware that copies the incoming header value into options for that scope.</p>"},{"location":"extensions/core-options/#per-request-overrides","title":"Per-request overrides","text":"<p>Use <code>IOptionsSnapshot&lt;CoreExtensionsOptions&gt;</code> or a scoped options wrapper to set per-request values (e.g., TraceId) based on incoming HTTP headers: <pre><code>public class CorrelationOptionsMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly IOptionsSnapshot&lt;CoreExtensionsOptions&gt; _options;\n    private readonly ILogContext _context;\n\n    public CorrelationOptionsMiddleware(RequestDelegate next, IOptionsSnapshot&lt;CoreExtensionsOptions&gt; options, ILogContext context)\n    {\n        _next = next;\n        _options = options;\n        _context = context;\n    }\n\n    public async Task Invoke(HttpContext http)\n    {\n        var incoming = http.Request.Headers[_options.Value.CorrelationHeaderName].FirstOrDefault();\n        var correlationId = string.IsNullOrWhiteSpace(incoming) ? _options.Value.CorrelationIdFactory() : incoming;\n        _context.CorrelationId = correlationId;\n        await _next(http);\n    }\n}\n</code></pre> - For <code>TraceId</code>, consider a scoped service that copies <code>_context.CorrelationId</code> into <code>CoreExtensionsOptions.TraceId</code> if you need Results to carry it automatically.</p>"},{"location":"extensions/core-options/#testing-options","title":"Testing options","text":"<ul> <li>Use <code>Options.Create(new CoreExtensionsOptions { ... })</code> for unit tests of behaviors/guards.</li> <li>For performance logs, set <code>EnablePerformanceLogging = true</code> and a low threshold, then assert that <code>InMemoryAppLogger</code> captures warnings.</li> <li>For guard tests, set <code>TraceId</code> and assert it flows into <code>Error.TraceId</code>.</li> </ul>"},{"location":"extensions/core-options/#migration-tips-from-the-template","title":"Migration tips from the template","text":"<ul> <li>Keep template behaviors if desired, but wire <code>CoreExtensionsOptions</code> to control Core behaviors. Template behaviors ignore these options, so ensure you register Core behaviors to benefit from the settings.</li> <li>If you currently hard-code thresholds or headers, move them into <code>Extensions:Core</code> configuration and consume via DI.</li> <li>Replace ad hoc correlation ID generation with <code>CorrelationIdFactory</code> to centralize ID format.</li> </ul>"},{"location":"extensions/core-options/#reference-option-defaults-and-effects","title":"Reference: option defaults and effects","text":"<ul> <li><code>CorrelationHeaderName</code>: Used by middleware/controllers to read/write correlation; behavior uses <code>ILogContext</code> (not header directly).</li> <li><code>CorrelationIdFactory</code>: Used by <code>CorrelationBehavior</code> when <code>ILogContext.CorrelationId</code> is empty.</li> <li><code>GuardStrategy</code>: Default for <code>GuardOptions.FromOptions</code>; controls return vs throw vs accumulate.</li> <li><code>EnablePerformanceLogging</code>: If false, <code>PerformanceBehavior</code> becomes a pass-through.</li> <li><code>PerformanceWarningThreshold</code>: Controls Warn vs Debug logging in <code>PerformanceBehavior</code>.</li> <li><code>TraceId</code>: Applied to guards/results when provided; useful for aligning API trace tokens with internal errors.</li> </ul>"},{"location":"extensions/core-options/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Register <code>AddCleanArchitectureCore(...)</code> (inline options or configuration binding). 2) Decide on correlation header and ID format; update gateway/middleware accordingly. 3) Set <code>GuardStrategy</code> globally; override per-call with <code>GuardOptions</code> when needed. 4) Tune <code>PerformanceWarningThreshold</code> and <code>EnablePerformanceLogging</code> per environment. 5) If you need TraceId propagation, set it per request (middleware + options snapshot) and pass it into Results/Errors.</p>"},{"location":"extensions/core-options/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for correlation/performance logging powered by these options.</li> <li>Core guard clauses for guard behavior controlled via options.</li> <li>Core result primitives to see how TraceId from options flows into results/errors.</li> <li>Core logging abstractions for correlation scopes influenced by header/factory choices.</li> <li>Core extension overview for the big-picture registration instructions.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/","title":"Core Pipeline Behaviors","text":"<p>The Core extension ships MediatR behaviors that drop into Jason Taylor\u2019s Clean Architecture pipeline without breaking existing registrations. This page explains what the template already includes, why the Core behaviors add correlation- and telemetry-friendly enhancements, and how to wire, order, and use them in real projects. Examples show both the pre-processor signature (<code>IRequestPreProcessor&lt;TRequest&gt;</code>) and the standard <code>IPipelineBehavior&lt;TRequest, TResponse&gt;</code> pattern so you can stay compatible with the template\u2019s DI setup.</p>"},{"location":"extensions/core-pipeline-behaviors/#what-the-template-already-covers","title":"What the template already covers","text":"<p>In the template (<code>src/Application/Common/Behaviours</code>), MediatR is wired with: - <code>LoggingBehaviour&lt;TRequest&gt;</code> (<code>IRequestPreProcessor&lt;TRequest&gt;</code>): Logs request name, user ID, and user name using <code>ILogger&lt;TRequest&gt;</code>, <code>IUser</code>, and <code>IIdentityService&gt;</code>. - <code>UnhandledExceptionBehaviour&lt;TRequest, TResponse&gt;</code>: Catches exceptions, logs them, and rethrows. - <code>AuthorizationBehaviour&lt;TRequest, TResponse&gt;</code>: Enforces <code>AuthorizeAttribute</code> roles/policies using <code>IUser</code> and <code>IIdentityService</code>; throws <code>UnauthorizedAccessException</code>/<code>ForbiddenAccessException</code>. - <code>ValidationBehaviour&lt;TRequest, TResponse&gt;</code>: Runs FluentValidation validators; throws <code>ValidationException</code> when failures exist. - <code>PerformanceBehaviour&lt;TRequest, TResponse&gt;</code>: Uses a <code>Stopwatch</code>; logs warnings via <code>ILogger&lt;TRequest&gt;</code> when elapsed time &gt; 500 ms. It does not attach correlation metadata.</p> <p>Registration order in <code>Application.DependencyInjection</code>: pre-processor logging, then unhandled exception, authorization, validation, performance.</p> <p>Gaps the template intentionally leaves open: - No correlation ID propagation across logs and handlers. - No structured logging abstraction\u2014everything is tied to <code>ILogger&lt;T&gt;</code>. - No toggle for performance logging or threshold configuration via options. - No reusable logging scope that flows into other behaviors.</p>"},{"location":"extensions/core-pipeline-behaviors/#what-the-core-behaviors-add","title":"What the Core behaviors add","text":"<p>The Core behaviors preserve template compatibility while adding cross-cutting concerns you need in production: - Correlation-aware: <code>CorrelationBehavior</code> ensures <code>ILogContext.CorrelationId</code> is set (configurable factory) and pushes it into a logging scope. - Structured logging: <code>LoggingPreProcessor&lt;TRequest&gt;</code> emits start events as a pre-processor; <code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> emits handling/handled events in the pipeline. Both use <code>IAppLogger&lt;T&gt;</code> and <code>ILogContext</code> for provider-agnostic structured logs and correlation. - Configurable performance telemetry: <code>PerformanceBehavior</code> measures elapsed time with <code>IClock</code> and warns when <code>CoreExtensionsOptions.PerformanceWarningThreshold</code> is exceeded; it can be globally disabled via <code>EnablePerformanceLogging</code>. - Option-driven defaults: Correlation header/name, ID factory, and performance thresholds live in <code>CoreExtensionsOptions</code>. - Provider-agnostic logging: Behaviors depend on <code>IAppLogger&lt;T&gt;</code> and <code>ILogContext</code>, making it easy to plug in Serilog, MEL, or in-memory loggers for tests.</p>"},{"location":"extensions/core-pipeline-behaviors/#behavior-apis-core","title":"Behavior APIs (Core)","text":"<ul> <li><code>CorrelationBehavior&lt;TRequest, TResponse&gt;</code> (<code>IPipelineBehavior</code>): Ensures correlation ID, pushes scope via <code>ILogContext.PushProperty</code>.</li> <li><code>LoggingPreProcessor&lt;TRequest&gt;</code> (<code>IRequestPreProcessor&lt;TRequest&gt;</code>): Logs request start with correlation + timestamp; sets correlation if missing.</li> <li><code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> (<code>IPipelineBehavior</code>): Logs handling/end with correlation + request type; sets correlation if missing.</li> <li><code>PerformanceBehavior&lt;TRequest, TResponse&gt;</code> (<code>IPipelineBehavior</code>): Times handler execution; warns vs. debug logs; respects <code>EnablePerformanceLogging</code> and <code>PerformanceWarningThreshold</code>.</li> </ul> <p>Dependencies (registered by <code>services.AddCleanArchitectureCore()</code>): - <code>IAppLogger&lt;T&gt;</code> (logging abstraction, now backed by the built-in <code>MelAppLoggerAdapter&lt;T&gt;</code> that bridges to <code>ILogger&lt;T&gt;</code>). - <code>ILogContext</code> (correlation scope). - <code>IClock</code> (time source). - <code>CoreExtensionsOptions</code> (correlation + performance settings).</p>"},{"location":"extensions/core-pipeline-behaviors/#recommended-pipeline-order","title":"Recommended pipeline order","text":"<p>To stay compatible with the template\u2019s semantics while adding correlation: 1) <code>CorrelationBehavior</code> (ensures correlation ID). 2) <code>LoggingPreProcessor</code> registered as <code>IRequestPreProcessor</code> (logs start) and <code>LoggingBehavior</code> registered as <code>IPipelineBehavior</code> (logs handling/end). 3) <code>UnhandledExceptionBehaviour</code> (template). 4) <code>AuthorizationBehaviour</code> (template). 5) <code>ValidationBehaviour</code> (template). 6) <code>PerformanceBehaviour</code> (measures the whole request). 7) Handler.</p> <p>This preserves the template\u2019s order while guaranteeing that correlation and logging scopes exist for subsequent behaviors and for performance logs.</p>"},{"location":"extensions/core-pipeline-behaviors/#wiring-in-di-application-layer","title":"Wiring in DI (Application layer)","text":"<p>Use the built-in helpers to mirror template order while turning on correlation, logging, and performance metrics:</p> <p><pre><code>builder.Services.AddCleanArchitectureCore(options =&gt;\n{\n    options.CorrelationHeaderName = \"X-Correlation-ID\";\n    options.EnablePerformanceLogging = true;\n    options.PerformanceWarningThreshold = TimeSpan.FromMilliseconds(500);\n});\n\nbuilder.Services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());\n    cfg.AddCleanArchitectureCorePipeline(); // Correlation -&gt; Logging pre/post -&gt; Performance\n    cfg.AddOpenBehavior(typeof(UnhandledExceptionBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(AuthorizationBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(ValidationBehaviour&lt;,&gt;));\n});\n</code></pre> - <code>MelAppLoggerAdapter&lt;T&gt;</code> bridges Core logging to <code>ILogger&lt;T&gt;</code> so you can use your existing MEL/Serilog pipeline. - <code>LoggingPreProcessor</code> is registered as a pre-processor (start log) and <code>LoggingBehavior</code> as a pipeline behavior (handling/end log).</p>"},{"location":"extensions/core-pipeline-behaviors/#sample-backed-walkthrough-pipeline-sample","title":"Sample-backed walkthrough (pipeline sample)","text":"<p>The runnable sample at <code>samples/CleanArchitecture.Extensions.Core.Pipeline.Sample</code> exercises the behaviors with real endpoints.</p>"},{"location":"extensions/core-pipeline-behaviors/#correlation-flowing-into-handlers","title":"Correlation flowing into handlers","text":"<p><code>src/Application/Diagnostics/Queries/GetPipelineDiagnostics/GetPipelineDiagnostics.cs</code>: <pre><code>var correlationId = _logContext.CorrelationId ?? _clock.NewGuid().ToString(\"N\");\n\n_logger.Log(LogLevel.Information, $\"Diagnostics requested with correlation {correlationId}\");\n\nreturn Task.FromResult(new PipelineDiagnosticsDto(correlationId, _clock.UtcNow));\n</code></pre> - <code>CorrelationBehavior</code> seeds <code>_logContext.CorrelationId</code>; the handler reuses it and returns it to the caller.</p>"},{"location":"extensions/core-pipeline-behaviors/#performance-warnings-on-slow-commands","title":"Performance warnings on slow commands","text":"<p><code>src/Application/Diagnostics/Commands/SimulateWork/SimulateWork.cs</code>: <pre><code>var delay = Math.Max(0, request.Milliseconds);\n_logger.Log(LogLevel.Information, $\"Simulating {delay} ms of work\");\n\nawait _clock.Delay(TimeSpan.FromMilliseconds(delay), cancellationToken);\n\n_logger.Log(LogLevel.Debug, $\"Completed simulated work after {delay} ms\");\n</code></pre> - With <code>PerformanceWarningThreshold</code> set to 400 ms in DI, <code>POST /api/Diagnostics/simulate?milliseconds=650</code> emits a performance warning from <code>PerformanceBehavior</code> while returning 202 Accepted.</p>"},{"location":"extensions/core-pipeline-behaviors/#minimal-api-endpoints-exposing-the-behaviors","title":"Minimal API endpoints exposing the behaviors","text":"<p><code>src/Web/Endpoints/Diagnostics.cs</code>: <pre><code>public async Task&lt;IResult&gt; GetPipelineDiagnostics(ISender sender) =&gt;\n    TypedResults.Ok(await sender.Send(new GetPipelineDiagnosticsQuery()));\n\npublic async Task&lt;IResult&gt; SimulateWork(ISender sender, int milliseconds = 600)\n{\n    await sender.Send(new SimulateWorkCommand(milliseconds));\n    return TypedResults.Accepted($\"/api/{nameof(Diagnostics)}/simulate?milliseconds={milliseconds}\");\n}\n</code></pre> - <code>LoggingPreProcessor</code> logs start, <code>LoggingBehavior</code> logs handling/end, <code>CorrelationBehavior</code> scopes correlation, and <code>PerformanceBehavior</code> times the simulated work.</p>"},{"location":"extensions/core-pipeline-behaviors/#behavior-by-behavior-deep-dive","title":"Behavior-by-behavior deep dive","text":""},{"location":"extensions/core-pipeline-behaviors/#correlationbehavior","title":"CorrelationBehavior","text":"<ul> <li>Purpose: Ensure every request has a correlation ID flowing through <code>ILogContext</code> and attached to structured logs.</li> <li>How it works: If <code>ILogContext.CorrelationId</code> is empty, it uses <code>CoreExtensionsOptions.CorrelationIdFactory</code> (default GUID) or <code>_clock.NewGuid()</code> to create one. It pushes a property named <code>CorrelationId</code> into the logging scope via <code>ILogContext.PushProperty</code>, then calls <code>next</code>.</li> <li>Interop with web APIs: Controllers or middleware can set <code>ILogContext.CorrelationId</code> from incoming headers (e.g., <code>X-Correlation-ID</code>). The behavior preserves that value rather than overwriting it.</li> <li>Why before logging: Downstream behaviors and handlers can rely on <code>ILogContext.CorrelationId</code> being present for logs, telemetry, and Results.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#loggingbehavior","title":"LoggingBehavior","text":"<ul> <li>Purpose: Emit structured logs at start and end of request handling, carrying correlation ID and request type.</li> <li>Split start/end logging: <code>LoggingPreProcessor&lt;TRequest&gt;</code> runs as the pre-processor for start logs; <code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> runs in the pipeline for handling/finished logs.</li> <li>Scope handling: Uses <code>ILogContext.PushProperty</code> to keep <code>CorrelationId</code> in scope for downstream logging and for the paired end log.</li> <li>Data logged: Request type (full name), correlation ID, start timestamp (from <code>IClock</code>), and lifecycle messages (\u201cStarting\u201d, \u201cHandling\u201d, \u201cHandled\u201d).</li> <li>Compatibility: Replaces the template <code>LoggingBehaviour&lt;TRequest&gt;</code>; you can still enrich logs with user info by adapting <code>IAppLogger&lt;T&gt;</code> to include user claims.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#performancebehavior","title":"PerformanceBehavior","text":"<ul> <li>Purpose: Measure elapsed time for each request and emit warnings above a configurable threshold; otherwise debug-level messages.</li> <li>Config: <code>CoreExtensionsOptions.EnablePerformanceLogging</code> (bool) and <code>PerformanceWarningThreshold</code> (TimeSpan, default 500 ms).</li> <li>Correlation: Includes <code>CorrelationId</code> from <code>ILogContext</code> in logged properties.</li> <li>Clock: Uses <code>IClock</code> to allow deterministic testing with <code>FrozenClock</code>.</li> <li>Behavior: If logging is disabled, it immediately forwards to <code>next</code>. Otherwise, it records start time, invokes <code>next</code>, computes elapsed, and logs either Warn (over threshold) or Debug (under threshold).</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#real-world-usage-patterns","title":"Real-world usage patterns","text":""},{"location":"extensions/core-pipeline-behaviors/#1-correlating-api-requests-end-to-end","title":"1) Correlating API requests end-to-end","text":"<p><pre><code>public class CorrelationMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogContext _logContext;\n    private readonly CoreExtensionsOptions _options;\n\n    public CorrelationMiddleware(RequestDelegate next, ILogContext logContext, IOptions&lt;CoreExtensionsOptions&gt; options)\n    {\n        _next = next;\n        _logContext = logContext;\n        _options = options.Value;\n    }\n\n    public async Task Invoke(HttpContext context)\n    {\n        var header = _options.CorrelationHeaderName;\n        var incoming = context.Request.Headers[header].FirstOrDefault();\n        _logContext.CorrelationId = string.IsNullOrWhiteSpace(incoming)\n            ? _options.CorrelationIdFactory()\n            : incoming;\n\n        using var scope = _logContext.PushProperty(\"CorrelationId\", _logContext.CorrelationId);\n        context.Response.Headers[header] = _logContext.CorrelationId!;\n        await _next(context);\n    }\n}\n</code></pre> - With the middleware setting <code>ILogContext.CorrelationId</code>, <code>CorrelationBehavior</code> will reuse it, ensuring MediatR logs share the same ID.</p>"},{"location":"extensions/core-pipeline-behaviors/#2-swapping-logging-providers-without-touching-handlers","title":"2) Swapping logging providers without touching handlers","text":"<p><pre><code>// Adapter bridging IAppLogger&lt;T&gt; to Microsoft.Extensions.Logging\npublic sealed class MelAppLogger&lt;T&gt; : IAppLogger&lt;T&gt;\n{\n    private readonly ILogger&lt;T&gt; _logger;\n    private readonly ILogContext _context;\n\n    public MelAppLogger(ILogger&lt;T&gt; logger, ILogContext context)\n    {\n        _logger = logger;\n        _context = context;\n    }\n\n    public void Log(LogLevel level, string message, Exception? exception = null, IReadOnlyDictionary&lt;string, object?&gt;? properties = null)\n    {\n        using var scope = _logger.BeginScope(new Dictionary&lt;string, object?&gt;\n        {\n            [\"CorrelationId\"] = _context.CorrelationId\n        });\n        _logger.Log(Map(level), exception, message + \" {@props}\", properties);\n    }\n\n    private Microsoft.Extensions.Logging.LogLevel Map(LogLevel level) =&gt; level switch\n    {\n        LogLevel.Trace =&gt; Microsoft.Extensions.Logging.LogLevel.Trace,\n        LogLevel.Debug =&gt; Microsoft.Extensions.Logging.LogLevel.Debug,\n        LogLevel.Information =&gt; Microsoft.Extensions.Logging.LogLevel.Information,\n        LogLevel.Warning =&gt; Microsoft.Extensions.Logging.LogLevel.Warning,\n        LogLevel.Error =&gt; Microsoft.Extensions.Logging.LogLevel.Error,\n        LogLevel.Critical =&gt; Microsoft.Extensions.Logging.LogLevel.Critical,\n        _ =&gt; Microsoft.Extensions.Logging.LogLevel.None\n    };\n}\n</code></pre> - Behaviors depend on <code>IAppLogger&lt;T&gt;</code>; swapping providers requires only registering a different adapter.</p>"},{"location":"extensions/core-pipeline-behaviors/#3-measuring-command-performance-with-thresholds-per-feature","title":"3) Measuring command performance with thresholds per feature","text":"<p>If some handlers are expected to run longer, you can override options per scope: <pre><code>public class FeaturePerformanceOptions\n{\n    public static CoreExtensionsOptions ForReporting(CoreExtensionsOptions baseOptions) =&gt;\n        new()\n        {\n            CorrelationHeaderName = baseOptions.CorrelationHeaderName,\n            GuardStrategy = baseOptions.GuardStrategy,\n            EnablePerformanceLogging = true,\n            PerformanceWarningThreshold = TimeSpan.FromSeconds(2),\n            CorrelationIdFactory = baseOptions.CorrelationIdFactory\n        };\n}\n</code></pre> Inject a feature-specific options instance where needed (e.g., using named options) if you must raise the threshold for a known long-running report generation command.</p>"},{"location":"extensions/core-pipeline-behaviors/#4-capturing-correlation-in-resulterror-metadata","title":"4) Capturing correlation in Result/Error metadata","text":"<p><pre><code>public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateInvoiceCommand request, CancellationToken ct)\n{\n    var traceId = _logContext.CorrelationId ?? Guid.NewGuid().ToString(\"N\");\n\n    var customer = await _customers.GetAsync(request.CustomerId, ct);\n    if (customer is null)\n    {\n        return Result.Failure&lt;Guid&gt;(new Error(\"invoice.customer-not-found\", \"Customer not found\", traceId));\n    }\n\n    var invoiceId = await _invoices.CreateAsync(request.CustomerId, request.Amount, ct);\n    return Result.Success(invoiceId, traceId);\n}\n</code></pre> - Because <code>CorrelationBehavior</code> set <code>ILogContext.CorrelationId</code>, the handler can propagate the same ID into <code>Result</code>/<code>Error</code> for downstream API responses.</p>"},{"location":"extensions/core-pipeline-behaviors/#5-testing-behaviors-deterministically","title":"5) Testing behaviors deterministically","text":"<p><pre><code>[Fact]\npublic async Task PerformanceBehavior_Warns_When_Over_Threshold()\n{\n    var clock = new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\"));\n    var logger = new InMemoryAppLogger&lt;TestRequest&gt;();\n    var context = new InMemoryLogContext { CorrelationId = \"corr-1\" };\n    var options = Microsoft.Extensions.Options.Options.Create(new CoreExtensionsOptions { EnablePerformanceLogging = true, PerformanceWarningThreshold = TimeSpan.FromMilliseconds(10) });\n    var behavior = new PerformanceBehavior&lt;TestRequest, Unit&gt;(logger, context, options, clock);\n\n    var response = await behavior.Handle(new TestRequest(), _ =&gt; Task.FromResult(Unit.Value), CancellationToken.None);\n\n    logger.Entries.Should().Contain(e =&gt; e.Level == LogLevel.Warning &amp;&amp; e.CorrelationId == \"corr-1\");\n}\n</code></pre> - <code>FrozenClock</code> and <code>InMemoryAppLogger</code> make assertions straightforward.</p>"},{"location":"extensions/core-pipeline-behaviors/#configuration-reference","title":"Configuration reference","text":"<p><code>CoreExtensionsOptions</code> fields relevant to behaviors: - <code>CorrelationHeaderName</code>: The header your APIs use for correlation (helps middleware + controllers align). - <code>CorrelationIdFactory</code>: Func to generate correlation IDs when absent (default GUID \u201cN\u201d). - <code>EnablePerformanceLogging</code>: Toggle performance measurement. - <code>PerformanceWarningThreshold</code>: TimeSpan for warning threshold (default 500 ms). - <code>TraceId</code>: Optional trace ID to apply to guard/result flows (not directly used by behaviors but useful for consistency). <p>Example appsettings: <pre><code>{\n  \"Extensions\": {\n    \"Core\": {\n      \"CorrelationHeaderName\": \"X-Correlation-ID\",\n      \"EnablePerformanceLogging\": true,\n      \"PerformanceWarningThreshold\": \"00:00:00.500\",\n      \"GuardStrategy\": \"ReturnFailure\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"extensions/core-pipeline-behaviors/#ordering-and-coexistence-tips","title":"Ordering and coexistence tips","text":"<ul> <li>Pre-processor vs. pipeline: Keep <code>LoggingPreProcessor</code> registered if you need \u201crequest started\u201d logs before other behaviors. <code>LoggingBehavior</code> still logs \u201cHandled\u201d after downstream behaviors.</li> <li>Validation exceptions: If FluentValidation throws, <code>LoggingBehavior</code> will have already logged \u201cHandling\u201d; <code>UnhandledExceptionBehaviour</code> will log the exception. Consider adding error logs in exception middleware if you need both start/finish markers on failure.</li> <li>Multiple correlation sources: If API middleware sets <code>ILogContext.CorrelationId</code>, <code>CorrelationBehavior</code> will respect it. Avoid regenerating IDs in handlers; rely on the behavior + middleware.</li> <li>Performance scope: If you run background jobs with MediatR, performance logs will still flow; set <code>EnablePerformanceLogging = false</code> for noise-sensitive jobs or adjust thresholds.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#migration-from-template-behaviors","title":"Migration from template behaviors","text":"<ul> <li>Replace <code>LoggingBehaviour&lt;TRequest&gt;</code> with Core <code>LoggingPreProcessor</code> + <code>LoggingBehavior</code> registrations.</li> <li>Keep <code>UnhandledExceptionBehaviour</code>, <code>AuthorizationBehaviour</code>, and <code>ValidationBehaviour</code> as-is; Core behaviors are additive.</li> <li>Remove <code>Stopwatch</code>-based performance behavior from the template if you want correlation-aware performance logging; Core <code>PerformanceBehavior</code> is a drop-in replacement with options.</li> <li>Keep handler code unchanged; behaviors are registered in DI and require no handler modifications.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#faq","title":"FAQ","text":"<ul> <li>Do I need both pre-processor and pipeline registrations? Optional but recommended for parity with the template: <code>LoggingPreProcessor</code> captures the \u201cstarting\u201d log before other behaviors run; <code>LoggingBehavior</code> captures \u201chandled\u201d after all behaviors and the handler.</li> <li>Can I add request payload sampling? Wrap <code>IAppLogger&lt;T&gt;</code> to include sanitized payload summaries; keep PII concerns in mind. The behavior provides request type and correlation ID; payload logging is left to your adapter to avoid allocations and sensitivity issues.</li> <li>What about OpenTelemetry? Adapt <code>IAppLogger&lt;T&gt;</code> or <code>ILogContext</code> to bridge correlation IDs to trace/span IDs. The behaviors themselves do not depend on OTEL packages.</li> <li>Does correlation flow to domain events? If you propagate <code>ILogContext.CorrelationId</code> into <code>DomainEvent.CorrelationId</code> or <code>Result.TraceId</code> inside handlers, you can correlate across pipelines. Core behaviors set the context; you attach it to your domain events manually.</li> </ul>"},{"location":"extensions/core-pipeline-behaviors/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Register <code>CorrelationBehavior</code>, <code>LoggingPreProcessor</code> (pre-processor), <code>LoggingBehavior</code> (pipeline), and <code>PerformanceBehavior</code> in the Application DI layer. 2) Configure <code>CoreExtensionsOptions</code> (header name, correlation ID factory, performance threshold). 3) Provide <code>ILogContext</code> and <code>IAppLogger&lt;T&gt;</code> adapters that forward correlation scopes to your logging provider. 4) Add middleware (optional) to set <code>ILogContext.CorrelationId</code> from incoming headers and echo it back. 5) Validate ordering: ensure correlation precedes logging; ensure performance wraps handler work after validation/authorization. 6) Write a smoke test: send a request through MediatR in-memory, assert correlation ID is present in logs and performance logs respect thresholds.</p>"},{"location":"extensions/core-pipeline-behaviors/#related-docs","title":"Related docs","text":"<ul> <li>Core extension overview for the full package and registration guidance.</li> <li>Core Result Primitives to see how correlation flows into results/errors.</li> <li>Core Guard Clauses for input validation that pairs well with these behaviors.</li> <li>Validation extension if you lean on FluentValidation behaviors alongside Core pipeline behaviors.</li> </ul>"},{"location":"extensions/core-result-primitives/","title":"Core Result Primitives","text":"<p>The Core extension ships a richer <code>Result</code> model than the one inside Jason Taylor\u2019s Clean Architecture template. This page explains what the template provides today, why the extension adds more, how to use the upgraded primitives, and how to adopt them incrementally without fighting the template\u2019s MediatR-centric structure.</p>"},{"location":"extensions/core-result-primitives/#what-the-template-already-covers","title":"What the template already covers","text":"<p>Jason\u2019s template keeps the built-in result type intentionally small so new projects stay approachable: - <code>src/Application/Common/Models/Result.cs</code> exposes <code>bool Succeeded</code> plus <code>string[] Errors</code>, with static <code>Success()</code> and <code>Failure(IEnumerable&lt;string&gt;)</code>. - It is used mainly by the Identity layer (<code>Infrastructure/Identity/IdentityResultExtensions.cs</code> converts <code>IdentityResult</code> to <code>Result</code>; <code>IdentityService.DeleteUserAsync</code> returns it). Commands/queries typically return view models or primitives directly, not <code>Result</code>. - MediatR pipeline behaviors (<code>LoggingBehaviour</code>, <code>UnhandledExceptionBehaviour</code>, <code>AuthorizationBehaviour</code>, <code>ValidationBehaviour</code>, <code>PerformanceBehaviour</code>) assume exceptions for failures (e.g., FluentValidation throws <code>ValidationException</code>), not a rich result envelope. - There is no explicit place for trace/correlation IDs. Logging relies on <code>ILogger&lt;T&gt;</code> scopes populated by <code>IUser</code>/<code>IIdentityService</code> rather than a result metadata contract. - Errors are unstructured strings; you cannot attach error codes, metadata, or machine-readable details without inventing your own type downstream.</p> <p>That minimalism works for demos and small features, but it leaves gaps once you need consistent error shapes, correlation-friendly diagnostics, or functional composition across handlers.</p>"},{"location":"extensions/core-result-primitives/#why-use-the-core-result-primitives","title":"Why use the Core Result primitives","text":"<p>The extension keeps the success/failure semantics but adds the capabilities teams routinely need in production: - Traceability: <code>Result</code> and <code>Error</code> carry an optional <code>TraceId</code> so handlers and web APIs can preserve request/operation identifiers without leaking logging concerns into business code. - Structured errors: <code>Error</code> holds <code>Code</code>, <code>Message</code>, and optional <code>Metadata</code> (key/value) to capture domain facts (e.g., constraints, limits, offending values) in a machine-readable way. - Value payloads: <code>Result&lt;T&gt;</code> wraps successful values, avoiding parallel DTOs for \u201cmaybe failed\u201d responses. - Composition: Helpers like <code>Map</code>, <code>Bind</code>, <code>Tap</code>, <code>Ensure</code>, <code>Recover</code>, and <code>Combine</code> let you chain operations without nested <code>if</code> blocks or exception gymnastics. - Guard synergy: Guard clauses in the same package can emit <code>Result&lt;T&gt;</code> with trace IDs and error codes, giving you a uniform contract from validation through handler to API. - Testability: Deterministic results and errors make it easy to assert flows without depending on logging side effects or exception throwing. - Interop: You can adapt the template\u2019s <code>Result</code> (strings) into the richer <code>Result</code>/<code>Error</code> shape and back, enabling gradual adoption.</p>"},{"location":"extensions/core-result-primitives/#api-surface-at-a-glance","title":"API surface at a glance","text":"<ul> <li>Types: <code>Result</code>, <code>Result&lt;T&gt;</code>, and <code>Error</code> live in <code>CleanArchitecture.Extensions.Core.Results</code>.</li> <li>Creation: <code>Result.Success(traceId?)</code>, <code>Result.Success&lt;T&gt;(value, traceId?)</code>, <code>Result.Failure(error|errors, traceId?)</code>, <code>Result.Failure&lt;T&gt;(...)</code>.</li> <li>Inspection: <code>IsSuccess</code>, <code>IsFailure</code>, <code>Errors</code>, <code>TraceId</code>, <code>Value</code>, <code>ValueOrDefault</code>.</li> <li>Composition: </li> <li><code>Result&lt;T&gt;.Map(Func&lt;T, TResult&gt;)</code> and <code>Bind(Func&lt;T, Result&lt;TResult&gt;&gt;)</code></li> <li><code>Result&lt;T&gt;.Tap(Action&lt;T&gt;)</code> for side effects on success</li> <li><code>Result&lt;T&gt;.Ensure(predicate, error)</code> to enforce additional invariants</li> <li><code>ResultExtensions.Ensure(predicate, error)</code> for non-generic results</li> <li><code>Result.Combine(params Result[])</code> to aggregate multiple checks</li> <li><code>ResultExtensions.Recover(fallback)</code> to supply a fallback value on failure</li> <li><code>ResultExtensions.ToResult()</code> to wrap raw values</li> <li>Errors: <code>Error</code> exposes <code>Code</code>, <code>Message</code>, optional <code>TraceId</code>, <code>Metadata</code>, <code>HasMetadata</code>, and helpers <code>WithTraceId(...)</code>, <code>WithMetadata(key, value)</code>.</li> </ul>"},{"location":"extensions/core-result-primitives/#compatibility-and-migration-from-the-template","title":"Compatibility and migration from the template","text":"<p>You can start with the template\u2019s existing patterns and layer Core Results gradually: - Mapping template \u2192 Core: <code>Result.Success()</code> becomes <code>Result.Success(traceId)</code>; <code>Result.Failure(strings)</code> can be projected to <code>Result.Failure(strings.Select(s =&gt; new Error(\"identity\", s)))</code> or use <code>LegacyResult.Failure(strings).ToResult(traceId)</code>. - Mapping Core \u2192 template: <code>Result.Success(traceId)</code> can return <code>CleanArchitecture.Application.Common.Models.Result.Success()</code> or <code>LegacyResult.FromResult(result)</code>. Failures can flatten via <code>Errors.Select(e =&gt; $\"{e.Code}: {e.Message}\")</code> or rely on the adapter\u2019s default formatter. - Handlers: Keep return types as your feature needs (DTOs, primitives). Introduce <code>Result&lt;T&gt;</code> where you want richer errors without throwing. You can adopt it per handler; nothing requires a big bang change. - Pipelines: Core Results do not change pipeline signatures; they work with the template\u2019s behaviors. Validation that throws still bubbles through <code>UnhandledExceptionBehaviour</code>; you can prefer guard/result composition to avoid exceptions when appropriate.</p>"},{"location":"extensions/core-result-primitives/#real-world-use-cases-backed-by-the-sample","title":"Real-world use cases (backed by the sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Result.Sample</code>. It keeps Jason\u2019s <code>IApplicationDbContext</code> style while exercising Core Results in a <code>Projects</code> feature.</p>"},{"location":"extensions/core-result-primitives/#1-creating-a-project-with-guards-combine","title":"1) Creating a project with guards + <code>Combine</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Application/Projects/Commands/CreateProject/CreateProject.cs</code>:</p> <p><pre><code>public async Task&lt;CoreResults.Result&lt;int&gt;&gt; Handle(CreateProjectCommand request, CancellationToken cancellationToken)\n{\n    var traceId = Guid.NewGuid().ToString(\"N\");\n    var guardOptions = new GuardOptions { TraceId = traceId };\n\n    var name = Guard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name), guardOptions)\n        .Ensure(n =&gt; n.Length &lt;= MaxNameLength, new CoreResults.Error(\"projects.name.length\", $\"Project name must be {MaxNameLength} characters or fewer.\", traceId));\n\n    var description = Guard.Ensure(request.Description is null || request.Description.Length &lt;= MaxDescriptionLength,\n        \"projects.description.length\",\n        $\"Description must be {MaxDescriptionLength} characters or fewer.\",\n        guardOptions);\n\n    var budget = Guard.Ensure(request.Budget &gt;= 0,\n        \"projects.budget.range\",\n        \"Budget cannot be negative.\",\n        guardOptions);\n\n    var validation = CoreResults.Result.Combine(name, description, budget);\n    if (validation.IsFailure)\n    {\n        return CoreResults.Result.Failure&lt;int&gt;(validation.Errors, traceId);\n    }\n\n    var project = new Project(name.Value, request.Description, request.Budget);\n\n    var duplicateName = await _context.Projects\n        .AnyAsync(p =&gt; p.Name == project.Name, cancellationToken);\n\n    if (duplicateName)\n    {\n        var duplicateError = new CoreResults.Error(\"projects.name.duplicate\", \"A project with this name already exists.\", traceId)\n            .WithMetadata(\"name\", project.Name);\n\n        return CoreResults.Result.Failure&lt;int&gt;(duplicateError, traceId);\n    }\n\n    _context.Projects.Add(project);\n    await _context.SaveChangesAsync(cancellationToken);\n\n    return CoreResults.Result.Success(project.Id, traceId);\n}\n</code></pre> - <code>GuardOptions.TraceId</code> seeds correlation on every guard failure and success. - <code>Result.Combine</code> keeps the handler branch-free until all synchronous validations run. - Errors capture metadata (<code>name</code>) before returning <code>Result&lt;int&gt;</code> to the caller.</p>"},{"location":"extensions/core-result-primitives/#2-closing-a-project-with-bind-and-tap","title":"2) Closing a project with <code>Bind</code> and <code>Tap</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Application/Projects/Commands/CloseProject/CloseProject.cs</code>:</p> <p><pre><code>var closeResult = Guard.AgainstNull(project, nameof(project), guardOptions)\n    .Bind(p =&gt; EnsureNotClosed(p, traceId))\n    .Tap(p =&gt; p.Close(DateTimeOffset.UtcNow));\n\nif (closeResult.IsFailure)\n{\n    return CoreResults.Result.Failure(closeResult.Errors, traceId);\n}\n\nawait _context.SaveChangesAsync(cancellationToken);\n\nreturn CoreResults.Result.Success(traceId);\n\nstatic CoreResults.Result&lt;Project&gt; EnsureNotClosed(Project project, string traceId)\n{\n    return project.IsClosed\n        ? CoreResults.Result.Failure&lt;Project&gt;(new CoreResults.Error(\"projects.closed\", \"Project is already closed.\", traceId), traceId)\n        : CoreResults.Result.Success(project, traceId);\n}\n</code></pre> - <code>Bind</code> short-circuits if the entity is missing or already closed. - <code>Tap</code> performs the side effect (marking the project closed) without losing the trace ID.</p>"},{"location":"extensions/core-result-primitives/#3-mapping-results-to-http-responses","title":"3) Mapping results to HTTP responses","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Application/Projects/Queries/GetProjectById/GetProjectById.cs</code> and <code>samples/CleanArchitecture.Extensions.Core.Result.Sample/src/Web/Endpoints/Projects.cs</code>:</p> <p><pre><code>// Query handler\nvar projectResult = Guard.AgainstNull(project, nameof(project), guardOptions);\n\nreturn projectResult.Map(p =&gt; new ProjectSummaryDto\n{\n    Id = p.Id,\n    Name = p.Name,\n    Budget = p.Budget,\n    IsClosed = p.IsClosed,\n    ClosedOn = p.ClosedOn\n}, traceId);\n\n// Minimal API endpoint\npublic async Task&lt;IResult&gt; GetProjectById(ISender sender, int id)\n{\n    var result = await sender.Send(new GetProjectByIdQuery(id));\n\n    return result.Match&lt;IResult&gt;(\n        project =&gt; TypedResults.Ok(new { project, traceId = result.TraceId }),\n        _ =&gt; ToProblemResult(\"Project not found.\", result, StatusCodes.Status404NotFound));\n}\n</code></pre> - <code>Map</code> preserves the guard trace ID when projecting to a DTO. - <code>Match</code> produces consistent HTTP payloads with structured errors + <code>traceId</code>.</p>"},{"location":"extensions/core-result-primitives/#detailed-behavior-notes","title":"Detailed behavior notes","text":"<ul> <li>Trace IDs: If you pass a trace ID into <code>Result.Success</code> or <code>Result.Failure</code>, it will be copied into contained errors (or derived from the first error when not provided). Combine also prefers the first non-empty trace ID it finds.</li> <li>Error metadata: Use <code>WithMetadata</code> to attach machine-readable context (e.g., offending parameter, limit, current balance). Metadata is left untouched unless you clone the error.</li> <li>Value access: <code>Result&lt;T&gt;.Value</code> throws on failure to prevent accidental use; prefer <code>ValueOrDefault</code> when you deliberately ignore failures (rare) or <code>Match</code> for explicit branching.</li> <li>Recover: When you want a fallback without losing errors, <code>Recover</code> converts failure into success with a derived value (and carries the original trace ID). Useful for caching or default projections.</li> <li>Thread safety: Results are immutable; the error list is wrapped in <code>ReadOnlyCollection&lt;Error&gt;</code>. You can safely pass results across tasks without extra locking.</li> </ul>"},{"location":"extensions/core-result-primitives/#usage-patterns-and-guidance","title":"Usage patterns and guidance","text":"<ul> <li>Prefer <code>Result&lt;T&gt;</code> at boundaries: Commands/queries that are exposed to external callers benefit most because you can return rich, predictable errors to API controllers, background jobs, or message handlers.</li> <li>Keep exceptions for truly exceptional cases: Domain validation, guard failures, and expected business rule violations should return <code>Result</code>; infrastructure failures (DB down, unexpected null) can still throw to be caught by <code>UnhandledExceptionBehaviour</code> or global middleware.</li> <li>Name your error codes consistently: Use domain-prefixed codes (<code>billing.credit-limit</code>, <code>cart.empty</code>, <code>user.not-found</code>) so clients and observability tools can filter/search easily.</li> <li>Propagate correlation: When you have a correlation ID in <code>ILogContext</code> or HTTP headers, pass it into your first <code>Result</code> creation so all downstream errors carry it. The pipeline behaviors in Core keep <code>ILogContext</code> hydrated.</li> <li>Compose before persisting: Use <code>Combine</code> to gather errors before calling repositories. This keeps persistence logic free of partial states.</li> <li>Testing: Assert on <code>IsSuccess/IsFailure</code>, <code>Errors.Count</code>, and <code>TraceId</code>. For pipelines, pair <code>InMemoryAppLogger</code> with <code>ILogContext</code> to assert correlation + timing alongside result flows.</li> </ul>"},{"location":"extensions/core-result-primitives/#frequently-asked-questions","title":"Frequently asked questions","text":"<ul> <li>Do I have to return <code>Result</code> from every handler? No. Use it where you want structured errors and correlation in your contract. You can mix <code>Result&lt;T&gt;</code> handlers with plain DTO-returning handlers.</li> <li>Will this break the template\u2019s pipeline behaviors? No. All behaviors keep the same generic signatures. You can register Core behaviors in the same order as the template\u2019s behaviors to preserve semantics.</li> <li>How do I integrate with FluentValidation? You can keep FluentValidation throwing <code>ValidationException</code> (caught by middleware) or map validation failures into <code>Result</code> by projecting <code>ValidationFailure</code> into <code>Error</code> inside handlers/behaviors.</li> <li>Can I log errors automatically? Yes\u2014hook your logger adapter to inspect <code>Result</code> failures and emit logs enriched by <code>TraceId</code> and <code>Metadata</code>. The Core logging abstractions keep this decoupled from MediatR.</li> </ul>"},{"location":"extensions/core-result-primitives/#step-by-step-adoption-plan","title":"Step-by-step adoption plan","text":"<p>1) Add the package and register Core pipeline behaviors (Correlation, Logging, Performance) plus <code>IClock</code>, <code>ILogContext</code>, and logger adapters. 2) Wrap new handlers that benefit from structured errors in <code>Result&lt;T&gt;</code>; start with operations exposed to external clients or sensitive domains (payments, identity). 3) Introduce guards as the first layer in handlers to replace ad-hoc <code>if</code>/throws. Configure <code>GuardStrategy</code> globally via <code>CoreExtensionsOptions</code>. 4) Unify error codes across teams; codify them in a shared static class or constants to avoid drift. 5) Bridge Identity/legacy flows with adapters so you can defer broader refactors while gaining correlation and metadata where you need it.</p>"},{"location":"extensions/core-result-primitives/#reference-type-summaries","title":"Reference: Type summaries","text":"<ul> <li><code>Result</code>: success/failure envelope, trace ID, immutable <code>IReadOnlyList&lt;Error&gt;</code>. Factory methods and <code>Combine</code>.</li> <li><code>Result&lt;T&gt;</code>: extends <code>Result</code> with <code>Value</code>, <code>ValueOrDefault</code>, <code>Map</code>, <code>Bind</code>, <code>Tap</code>, <code>Ensure</code>, <code>Match</code>, and overrides <code>Failure</code> factories to attach trace IDs.</li> <li><code>Error</code>: structured error data with helpers to clone metadata or trace IDs; <code>None</code> sentinel for convenience.</li> <li><code>ResultExtensions</code>: <code>Ensure</code> for non-generic results, <code>ToResult</code> wrappers, and <code>Recover</code>.</li> </ul>"},{"location":"extensions/core-result-primitives/#example-test-asserting-failures-and-metadata","title":"Example test: asserting failures and metadata","text":"<pre><code>[Fact]\npublic void Recover_ReturnsFallbackOnFailure()\n{\n    var error = new Error(\"billing.credit-limit\", \"Insufficient credit\", traceId: \"req-42\");\n    var failed = Result.Failure&lt;int&gt;(error);\n\n    var recovered = failed.Recover(errors =&gt; errors.Count);\n\n    recovered.IsSuccess.Should().BeTrue();\n    recovered.Value.Should().Be(1);\n    recovered.TraceId.Should().Be(\"req-42\");\n}\n</code></pre>"},{"location":"extensions/core-result-primitives/#related-docs","title":"Related docs","text":"<ul> <li>Core extension overview for guard clauses, pipeline behaviors, logging, time, and domain events.</li> <li>Validation extension when you need FluentValidation-first behaviors that complement or replace guard/result flows.</li> </ul>"},{"location":"extensions/core-time/","title":"Core Time Abstractions","text":"<p>Time is a cross-cutting concern in Jason Taylor\u2019s Clean Architecture template. The template uses <code>TimeProvider</code> inside the EF Core <code>AuditableEntityInterceptor</code> to stamp <code>Created</code>/<code>LastModified</code> and uses <code>Stopwatch</code> in <code>PerformanceBehaviour</code> for timing. The Core extension introduces a unified <code>IClock</code> abstraction with system, frozen, and offset implementations, plus GUID generation and async delay, so you can keep tests deterministic, inject time consistently across layers, and align correlation/timing with other Core primitives.</p>"},{"location":"extensions/core-time/#what-the-template-already-covers","title":"What the template already covers","text":"<ul> <li>Auditing: <code>AuditableEntityInterceptor</code> injects <code>TimeProvider</code> to set <code>Created</code>/<code>LastModified</code> timestamps in <code>BaseAuditableEntity</code>.</li> <li>Performance: <code>PerformanceBehaviour</code> (template) uses a <code>Stopwatch</code> directly to time handlers; no configuration or correlation metadata is attached.</li> <li>No clock abstraction: Outside of the interceptor, handlers often call <code>DateTime.UtcNow</code> directly. There\u2019s no interface to mock or offset time across the app.</li> </ul>"},{"location":"extensions/core-time/#what-core-adds","title":"What Core adds","text":"<ul> <li><code>IClock</code> interface: Provides <code>UtcNow</code>, <code>Today</code>, <code>Timestamp</code>, <code>NewGuid()</code>, and async <code>Delay(...)</code>.</li> <li>Implementations: </li> <li><code>SystemClock</code> wraps system time + <code>Stopwatch</code> and GUID generation.</li> <li><code>FrozenClock</code> for deterministic tests; time advances only when you call <code>Advance</code>.</li> <li><code>OffsetClock</code> applies a fixed offset to an inner clock (simulate time zones or \u201ctime travel\u201d for testing).</li> <li>Consistency: Behaviors (logging/performance), guards, results, and correlation flows can share the same clock, improving determinism and observability.</li> <li>Testability: No more scattered <code>DateTime.UtcNow</code>; inject <code>IClock</code> and use <code>FrozenClock</code> in tests to avoid flakiness.</li> </ul>"},{"location":"extensions/core-time/#api-surface","title":"API surface","text":"<p>Namespace: <code>CleanArchitecture.Extensions.Core.Time</code></p> <ul> <li><code>IClock</code></li> <li><code>DateTimeOffset UtcNow { get; }</code></li> <li><code>DateOnly Today { get; }</code></li> <li><code>long Timestamp { get; }</code></li> <li><code>Guid NewGuid();</code></li> <li><code>Task Delay(TimeSpan delay, CancellationToken cancellationToken = default);</code></li> <li>Implementations:</li> <li><code>SystemClock</code></li> <li><code>FrozenClock</code></li> <li><code>OffsetClock</code></li> </ul>"},{"location":"extensions/core-time/#why-this-matters-for-clean-architecture","title":"Why this matters for Clean Architecture","text":"<ul> <li>Layer decoupling: Application/Domain code depends on <code>IClock</code>, not <code>DateTime.UtcNow</code> or <code>TimeProvider</code>. Infrastructure can wrap <code>TimeProvider.System</code> or other sources as needed.</li> <li>Deterministic tests: Use <code>FrozenClock</code> to freeze time and advance manually; assert timestamps, elapsed durations, and GUID flows without relying on real time.</li> <li>Correlation alignment: Behaviors and handlers can share <code>IClock.NewGuid()</code> for correlation IDs if desired, keeping randomness under one abstraction.</li> <li>Simulation: <code>OffsetClock</code> helps simulate different time zones or daylight savings impacts without changing system time.</li> </ul>"},{"location":"extensions/core-time/#wiring-in-di","title":"Wiring in DI","text":"<p><pre><code>services.AddSingleton&lt;IClock, SystemClock&gt;(); // default\n</code></pre> For tests, override with <code>FrozenClock</code> or <code>OffsetClock</code> via DI configuration: <pre><code>services.AddSingleton&lt;IClock&gt;(_ =&gt; new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\")));\n</code></pre></p>"},{"location":"extensions/core-time/#sample-backed-walkthrough-time-sample","title":"Sample-backed walkthrough (time sample)","text":"<p>A runnable solution lives at <code>samples/CleanArchitecture.Extensions.Core.Time.Sample</code>.</p>"},{"location":"extensions/core-time/#snapshot-current-time-with-iclock","title":"Snapshot current time with <code>IClock</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Time.Sample/src/Application/Diagnostics/Queries/GetTimeSnapshot/GetTimeSnapshotQuery.cs</code>: <pre><code>var guid = _clock.NewGuid();\nvar now = _clock.UtcNow;\nvar today = _clock.Today;\n\nvar snapshot = new TimeSnapshotDto(now, today, _clock.Timestamp, guid, null);\n</code></pre> - Exposed via <code>GET /api/Diagnostics/time</code> to show <code>UtcNow</code>, <code>Today</code>, a timestamp, and a GUID sourced from the clock.</p>"},{"location":"extensions/core-time/#delay-without-sleeping-in-tests","title":"Delay without sleeping in tests","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Time.Sample/src/Application/Diagnostics/Commands/SimulateDelay/SimulateDelayCommand.cs</code>: <pre><code>var started = _clock.UtcNow;\nawait _clock.Delay(delay, cancellationToken);\nvar ended = _clock.UtcNow;\nvar observed = ended - started;\n</code></pre> - <code>POST /api/Diagnostics/delay</code> echoes requested/observed delays; with <code>SystemClock</code> it really waits, while tests swap in <code>FrozenClock</code> so time advances instantly.</p>"},{"location":"extensions/core-time/#deterministic-tests-with-frozenclock","title":"Deterministic tests with <code>FrozenClock</code>","text":"<p><code>samples/CleanArchitecture.Extensions.Core.Time.Sample/tests/Application.UnitTests/Diagnostics/TimeDiagnosticsTests.cs</code>: <pre><code>var clock = new FrozenClock(fixedTime);\nvar handler = new GetTimeSnapshotQueryHandler(clock);\nvar result = await handler.Handle(new GetTimeSnapshotQuery(), CancellationToken.None);\n\nresult.UtcNow.ShouldBe(fixedTime);\nresult.EndedAtUtc.ShouldBe(fixedTime.AddMilliseconds(250)); // after simulated delay\n</code></pre> - Demonstrates advancing <code>FrozenClock</code> via <code>Delay</code> without real waits, keeping handler assertions deterministic.</p>"},{"location":"extensions/core-time/#adapting-the-templates-auditing-interceptor","title":"Adapting the template\u2019s auditing interceptor","text":"<p>You can keep the existing <code>AuditableEntityInterceptor</code> but inject <code>IClock</code> to stay consistent: <pre><code>public class AuditableEntityInterceptor : SaveChangesInterceptor\n{\n    private readonly IUser _user;\n    private readonly IClock _clock;\n\n    public AuditableEntityInterceptor(IUser user, IClock clock)\n    {\n        _user = user;\n        _clock = clock;\n    }\n\n    public override InterceptionResult&lt;int&gt; SavingChanges(DbContextEventData eventData, InterceptionResult&lt;int&gt; result)\n    {\n        UpdateEntities(eventData.Context);\n        return base.SavingChanges(eventData, result);\n    }\n\n    public override ValueTask&lt;InterceptionResult&lt;int&gt;&gt; SavingChangesAsync(DbContextEventData eventData, InterceptionResult&lt;int&gt; result, CancellationToken cancellationToken = default)\n    {\n        UpdateEntities(eventData.Context);\n        return base.SavingChangesAsync(eventData, result, cancellationToken);\n    }\n\n    private void UpdateEntities(DbContext? context)\n    {\n        if (context == null) return;\n\n        foreach (var entry in context.ChangeTracker.Entries&lt;BaseAuditableEntity&gt;())\n        {\n            if (entry.State is EntityState.Added or EntityState.Modified || entry.HasChangedOwnedEntities())\n            {\n                var utcNow = _clock.UtcNow;\n                if (entry.State == EntityState.Added)\n                {\n                    entry.Entity.CreatedBy = _user.Id;\n                    entry.Entity.Created = utcNow;\n                }\n                entry.Entity.LastModifiedBy = _user.Id;\n                entry.Entity.LastModified = utcNow;\n            }\n        }\n    }\n}\n</code></pre> - Swap <code>TimeProvider</code> for <code>IClock</code> to keep auditing consistent with the rest of Core.</p>"},{"location":"extensions/core-time/#using-iclock-in-pipeline-behaviors","title":"Using <code>IClock</code> in pipeline behaviors","text":"<p>Core behaviors already depend on <code>IClock</code>: - <code>LoggingBehavior</code> uses <code>UtcNow</code> to timestamp start logs and <code>NewGuid</code> to seed correlation when missing. - <code>PerformanceBehavior</code> uses <code>UtcNow</code> to measure elapsed; configurable thresholds live in <code>CoreExtensionsOptions</code>. - This ensures performance logs and correlation IDs can be deterministic in tests (swap in <code>FrozenClock</code>).</p>"},{"location":"extensions/core-time/#patterns-and-examples","title":"Patterns and examples","text":""},{"location":"extensions/core-time/#1-deterministic-tests-with-frozenclock","title":"1) Deterministic tests with FrozenClock","text":"<p><pre><code>[Fact]\npublic async Task Delay_Advances_FrozenClock()\n{\n    var clock = new FrozenClock(DateTimeOffset.Parse(\"2025-01-01T00:00:00Z\"));\n    await clock.Delay(TimeSpan.FromSeconds(5));\n    clock.UtcNow.Should().Be(DateTimeOffset.Parse(\"2025-01-01T00:00:05Z\"));\n    clock.Timestamp.Should().Be(TimeSpan.FromSeconds(5).Ticks);\n}\n</code></pre> - <code>Delay</code> advances time immediately without sleeping; great for timeout/retry logic tests.</p>"},{"location":"extensions/core-time/#2-time-zone-simulation-with-offsetclock","title":"2) Time zone simulation with OffsetClock","text":"<p><pre><code>var utcClock = new SystemClock();\nvar estClock = new OffsetClock(utcClock, TimeSpan.FromHours(-5));\nvar estNow = estClock.UtcNow; // effectively UTC-5 view\n</code></pre> - Useful when you need to display or test region-specific dates without altering system time.</p>"},{"location":"extensions/core-time/#3-injecting-clock-into-domain-services","title":"3) Injecting clock into domain services","text":"<p><pre><code>public sealed class TokenService\n{\n    private readonly IClock _clock;\n    public TokenService(IClock clock) =&gt; _clock = clock;\n\n    public TokenIssueResult Issue(string subject)\n    {\n        var issuedAt = _clock.UtcNow;\n        var expires = issuedAt.AddMinutes(30);\n        var token = _clock.NewGuid().ToString(\"N\");\n        return new TokenIssueResult(token, issuedAt, expires);\n    }\n}\n</code></pre> - No static <code>DateTime.UtcNow</code>; tests can assert exact timestamps with <code>FrozenClock</code>.</p>"},{"location":"extensions/core-time/#4-combining-with-results-for-expiration","title":"4) Combining with Results for expiration","text":"<p><pre><code>public Result ValidateNotExpired(DateTimeOffset expiresAt, IClock clock)\n{\n    return clock.UtcNow &lt;= expiresAt\n        ? Result.Success()\n        : Result.Failure(new Error(\"token.expired\", \"Token is expired\", traceId: null));\n}\n</code></pre> - Using the clock keeps logic testable and consistent with behaviors.</p>"},{"location":"extensions/core-time/#5-using-timestamp-for-perf-without-stopwatch","title":"5) Using Timestamp for perf without Stopwatch","text":"<p>If you prefer high-resolution ticks: <pre><code>var start = _clock.Timestamp;\n// do work\nvar elapsedTicks = _clock.Timestamp - start;\nvar elapsedMs = elapsedTicks * 1000.0 / Stopwatch.Frequency;\n</code></pre> - <code>SystemClock.Timestamp</code> delegates to <code>Stopwatch.GetTimestamp</code>; tests can override with <code>FrozenClock</code> if you set <code>_timestamp</code> appropriately when advancing.</p>"},{"location":"extensions/core-time/#interop-and-migration-tips","title":"Interop and migration tips","text":"<ul> <li>From <code>DateTime.UtcNow</code>: Inject <code>IClock</code> where you need time. For minimal code churn, add a constructor parameter and assign to a private field; replace calls to <code>DateTime.UtcNow</code> with <code>_clock.UtcNow</code>.</li> <li>From <code>TimeProvider</code>: Create an adapter that implements <code>IClock</code> by delegating to <code>TimeProvider</code>: <pre><code>public sealed class TimeProviderClock : IClock\n{\n    private readonly TimeProvider _provider;\n    public TimeProviderClock(TimeProvider provider) =&gt; _provider = provider;\n\n    public DateTimeOffset UtcNow =&gt; _provider.GetUtcNow();\n    public DateOnly Today =&gt; DateOnly.FromDateTime(_provider.GetUtcNow().UtcDateTime);\n    public long Timestamp =&gt; _provider.GetTimestamp();\n    public Guid NewGuid() =&gt; Guid.NewGuid();\n    public Task Delay(TimeSpan delay, CancellationToken cancellationToken = default) =&gt;\n        _provider.Delay(delay, cancellationToken);\n}\n</code></pre></li> <li>Register <code>TimeProviderClock</code> in Infrastructure if you rely on <code>TimeProvider</code> elsewhere.</li> </ul>"},{"location":"extensions/core-time/#correlation-alignment","title":"Correlation alignment","text":"<ul> <li>If you want correlation IDs to be GUIDs generated by the same source, use <code>IClock.NewGuid()</code> in <code>CorrelationBehavior</code> (as Core does by default). This keeps randomness and time abstractions under one roof.</li> <li>For deterministic correlation in tests, seed <code>FrozenClock</code> and use <code>NewGuid</code> from a predictable GUID source if needed (e.g., inject a GUID factory or extend <code>FrozenClock</code>).</li> </ul>"},{"location":"extensions/core-time/#configuration-touchpoints","title":"Configuration touchpoints","text":"<p>Time itself has no options in <code>CoreExtensionsOptions</code>, but it influences behaviors that have options (<code>PerformanceWarningThreshold</code>, <code>EnablePerformanceLogging</code>, <code>CorrelationIdFactory</code>). Use <code>IClock</code> consistently to avoid divergence between time and correlation behaviors.</p>"},{"location":"extensions/core-time/#testing-guidance","title":"Testing guidance","text":"<ul> <li>Use <code>FrozenClock</code> in unit tests for services/handlers that depend on time.</li> <li>Use <code>OffsetClock</code> to test date boundary conditions (end-of-day, DST transitions).</li> <li>For integration tests of performance logging, pair <code>FrozenClock</code> with <code>InMemoryAppLogger</code> to assert elapsed times and correlation IDs.</li> </ul>"},{"location":"extensions/core-time/#faq","title":"FAQ","text":"<ul> <li>Does <code>FrozenClock</code> auto-advance? Only when you call <code>Advance</code> or <code>Delay</code>. It will not change on its own.</li> <li>Is <code>OffsetClock</code> thread-safe? It delegates to an inner clock; thread safety follows the inner implementation. <code>SystemClock</code> is thread-safe; <code>FrozenClock</code> uses simple fields and is safe for typical test usage.</li> <li>Should domain entities depend on <code>IClock</code>? Prefer passing timestamps into entities from services/handlers to keep entities pure. Factories can receive <code>IClock</code> and pass values to entity constructors.</li> <li>Can I mock <code>IClock</code> manually? Yes\u2014implement a test double or use a mocking framework; the interface is small.</li> </ul>"},{"location":"extensions/core-time/#adoption-checklist","title":"Adoption checklist","text":"<p>1) Register <code>IClock</code> (SystemClock by default) in DI. 2) Swap time usages in Application/Infrastructure to <code>IClock</code> (auditing interceptor, handlers, services). 3) For tests, replace registration with <code>FrozenClock</code> or <code>OffsetClock</code>. 4) Align performance logging and correlation behaviors to use the injected clock (already true for Core behaviors). 5) Consider a <code>TimeProviderClock</code> adapter if your Infrastructure already relies on <code>TimeProvider</code>.</p>"},{"location":"extensions/core-time/#related-docs","title":"Related docs","text":"<ul> <li>Core pipeline behaviors for performance/correlation that depend on <code>IClock</code>.</li> <li>Core logging abstractions where correlation may use <code>IClock.NewGuid()</code>.</li> <li>Core result primitives for aligning trace IDs with correlation/time flows.</li> <li>Core guard clauses and Core domain events to see how time can interplay with validation and event stamping.</li> <li>Core extension overview for the package summary and registration guidance.</li> </ul>"},{"location":"extensions/core/","title":"Extension: Core","text":""},{"location":"extensions/core/#why-this-package-exists","title":"Why this package exists","text":"<p>Jason Taylor\u2019s Clean Architecture template ships a thin set of primitives: a minimal <code>Result</code> (bool + string array), MediatR behaviors for logging/validation/authorization/performance, domain-event plumbing via EF Core interceptors, Microsoft.Extensions.Logging abstractions, and <code>TimeProvider</code> for auditing. Those building blocks are intentionally small so the template stays approachable, but teams often need richer primitives (correlation, error metadata, deterministic time, test-friendly logging) without rewriting the template. The Core extension keeps you aligned with Jason\u2019s wiring while supplying opinionated, dependency-light upgrades:</p> <ul> <li>Rich <code>Result</code>/<code>Error</code> types with trace IDs, metadata, and composition helpers.</li> <li>Guard clauses that return results, throw, or accumulate errors.</li> <li>Pipeline behaviors that preserve the template\u2019s order/signatures while adding correlation scopes and structured logging.</li> <li>Logging abstractions (<code>IAppLogger&lt;T&gt;</code>, <code>ILogContext&gt;</code>) decoupled from any provider, plus in-memory/no-op implementations for tests.</li> <li>Domain event base types and a tracker for dispatch pipelines beyond EF interceptors.</li> <li>Time abstraction (<code>IClock</code>) that wraps <code>TimeProvider</code> concepts and unlocks deterministic clocks.</li> </ul> <p>If you want a deep dive into Results specifically, see Result primitives. The rest of this page orients you to everything in the Core package.</p>"},{"location":"extensions/core/#alignment-with-the-template","title":"Alignment with the template","text":"<ul> <li>Result: In the template (<code>src/Application/Common/Models/Result.cs</code>), success is a boolean with <code>string[] Errors</code>. It is used primarily by the Identity service (<code>IdentityService.ToApplicationResult</code>, <code>DeleteUserAsync</code>). There is no correlation metadata or value payload. Core keeps the pattern (success/failure) but adds trace IDs, error codes/messages/metadata, and generic payloads.</li> <li>Pipeline behaviors: The template wires <code>LoggingBehaviour</code> (pre-processor), <code>UnhandledExceptionBehaviour</code>, <code>AuthorizationBehaviour</code>, <code>ValidationBehaviour</code>, and <code>PerformanceBehaviour</code> in <code>DependencyInjection.cs</code>. Core behaviors mirror these signatures so you can swap without changing registrations, while layering correlation scopes and structured properties.</li> <li>Domain events: Template entities derive from <code>BaseEntity</code> and raise <code>BaseEvent</code> (INotification). EF\u2019s <code>DispatchDomainEventsInterceptor</code> drains events and publishes via MediatR on SaveChanges. Core keeps the MediatR-friendly event shape and supplies a <code>DomainEventTracker</code> plus <code>IDomainEventDispatcher</code> abstraction for alternate dispatch pipelines (e.g., outbox, bus).</li> <li>Time: Template uses <code>TimeProvider</code> inside <code>AuditableEntityInterceptor</code> to stamp <code>Created</code>/<code>LastModified</code>. Core\u2019s <code>IClock</code> wraps similar capabilities (<code>UtcNow</code>, <code>Today</code>, <code>Timestamp</code>, <code>Delay</code>, <code>NewGuid</code>) with test clocks and offsets.</li> <li>Logging: Template relies on <code>ILogger&lt;T&gt;</code>, <code>IUser</code>, and <code>IIdentityService</code> to enrich logs. Core introduces provider-agnostic logging + context abstractions so you can plug in Serilog, MEL, or in-memory loggers without coupling application code to a specific provider.</li> </ul>"},{"location":"extensions/core/#package-contents-what-you-get","title":"Package contents (what you get)","text":""},{"location":"extensions/core/#result-primitives-summary","title":"Result primitives (summary)","text":"<ul> <li><code>Result</code> and <code>Result&lt;T&gt;</code> capture success/failure, <code>TraceId</code>, and <code>IReadOnlyList&lt;Error&gt;</code>.</li> <li><code>Error</code> holds <code>Code</code>, <code>Message</code>, optional <code>Metadata</code>, and helpers to attach trace IDs.</li> <li>Composition helpers: <code>Map</code>, <code>Bind</code>, <code>Tap</code>, <code>Ensure</code>, <code>Recover</code>, <code>Combine</code>, plus convenience conversions (<code>ToResult</code>).</li> <li>All primitives live in <code>CleanArchitecture.Extensions.Core.Results</code> and avoid external dependencies.</li> <li>Deep dive: Result primitives.</li> </ul>"},{"location":"extensions/core/#guard-clauses","title":"Guard clauses","text":"<ul> <li><code>Guard</code> static helpers: null/whitespace, enum, range, min/max length, boolean <code>Ensure</code>.</li> <li><code>GuardOptions</code> lets you pick a strategy per call: <code>ReturnFailure</code> (default), <code>Throw</code>, or <code>Accumulate</code> (push into an <code>ErrorSink</code> collection).</li> <li>Trace IDs propagate from options so guard failures stay correlated with the request.</li> <li><code>GuardStrategy</code> enum documents strategies and can be derived from shared <code>CoreExtensionsOptions</code>.</li> <li>Deep dive: Core Guard Clauses.</li> </ul>"},{"location":"extensions/core/#pipeline-behaviors","title":"Pipeline behaviors","text":"<ul> <li>CorrelationBehavior: Ensures a correlation ID exists (uses <code>CoreExtensionsOptions.CorrelationIdFactory</code> or clock-based GUID), pushes it to <code>ILogContext</code>, and preserves scope for downstream logs.</li> <li>Logging: <code>LoggingPreProcessor&lt;TRequest&gt;</code> logs start-of-request; <code>LoggingBehavior&lt;TRequest, TResponse&gt;</code> logs handling/handled with correlation and request type.</li> <li>PerformanceBehavior: Measures elapsed time via <code>IClock</code>, emits warnings when <code>PerformanceWarningThreshold</code> is exceeded, can be toggled with <code>EnablePerformanceLogging</code>.</li> <li>Ordering guidance (matching the template\u2019s intent): <code>Correlation</code> \u2192 <code>Logging (pre)</code> \u2192 <code>UnhandledException</code> \u2192 <code>Authorization</code> \u2192 <code>Validation</code> \u2192 <code>Performance</code> \u2192 Handler. Insert Core behaviors accordingly to maintain compatibility.</li> <li>Deep dive: Core Pipeline Behaviors.</li> </ul>"},{"location":"extensions/core/#logging-abstractions","title":"Logging abstractions","text":"<ul> <li><code>IAppLogger&lt;T&gt;</code> mirrors <code>ILogger&lt;T&gt;</code> severity levels but keeps the surface minimal; overloads for Trace/Debug/Info/Warn/Error/Critical delegate to <code>Log</code>.</li> <li><code>ILogContext</code> stores <code>CorrelationId</code> and supports <code>PushProperty</code> to enrich structured logs. You can wrap <code>ILogger.BeginScope</code> or Serilog\u2019s <code>LogContext</code> in your adapter.</li> <li>Implementations: <code>NoOpAppLogger&lt;T&gt;</code> for silent runs, <code>InMemoryAppLogger&lt;T&gt;</code> + <code>InMemoryLogContext</code> for tests/diagnostics, <code>NoOpLogContext</code> as a stand-in when scope handling is optional.</li> <li>Deep dive: Core Logging Abstractions.</li> </ul>"},{"location":"extensions/core/#domain-events","title":"Domain events","text":"<ul> <li><code>DomainEvent</code> base record (INotification) with <code>Id</code>, <code>OccurredOnUtc</code>, and optional <code>CorrelationId</code>.</li> <li><code>DomainEventTracker</code> buffers events until dispatched; <code>Drain</code> returns a snapshot and clears, mirroring EF interceptor behavior while enabling non-EF dispatch paths.</li> <li><code>IDomainEventDispatcher</code> abstraction so Infrastructure can publish to MediatR, a message bus, or an outbox without changing Application.</li> <li>Deep dive: Core Domain Events.</li> </ul>"},{"location":"extensions/core/#time","title":"Time","text":"<ul> <li><code>IClock</code> abstraction with <code>UtcNow</code>, <code>Today</code>, <code>Timestamp</code>, <code>NewGuid</code>, and async <code>Delay</code>.</li> <li>Implementations: <code>SystemClock</code> (live), <code>FrozenClock</code> (manually advance for tests), <code>OffsetClock</code> (apply fixed offset to an inner clock). Aligns with <code>TimeProvider</code> semantics but adds GUID generation for correlation and deterministic tests.</li> <li>Deep dive: Core Time.</li> </ul>"},{"location":"extensions/core/#options","title":"Options","text":"<ul> <li><code>CoreExtensionsOptions</code> gathers cross-cutting defaults: correlation header name, guard strategy, performance logging toggle/threshold, correlation ID factory, and a default <code>TraceId</code> to flow into guards/results.</li> <li><code>GuardOptions.FromOptions</code> lets you hydrate guard config from shared options while providing per-call sinks.</li> <li>Deep dive: Core Options.</li> </ul>"},{"location":"extensions/core/#install","title":"Install","text":"<pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Core\n</code></pre>"},{"location":"extensions/core/#integration-guide-application-layer","title":"Integration guide (Application layer)","text":"<ol> <li>Register Core + options in one call:</li> </ol> <pre><code>services.AddCleanArchitectureCore(options =&gt;\n{\n    options.CorrelationHeaderName = \"X-Correlation-ID\";\n    options.GuardStrategy = GuardStrategy.ReturnFailure;\n    options.EnablePerformanceLogging = true;\n    options.PerformanceWarningThreshold = TimeSpan.FromMilliseconds(500);\n});\n</code></pre> <ol> <li>Wire pipeline behaviors with the helper (keep template order):</li> </ol> <pre><code>services.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCorePipeline(); // Correlation -&gt; Logging pre/post -&gt; Performance\n    cfg.AddOpenBehavior(typeof(UnhandledExceptionBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(AuthorizationBehaviour&lt;,&gt;));\n    cfg.AddOpenBehavior(typeof(ValidationBehaviour&lt;,&gt;));\n});\n</code></pre> <ol> <li>Adopt Results + guards in handlers: return <code>Result&lt;T&gt;</code> from commands/queries; compose with guards and validation.</li> </ol> <pre><code>var nameResult = Guard.AgainstNullOrWhiteSpace(request.Name, nameof(request.Name),\n    GuardOptions.FromOptions(options.Value));\nif (nameResult.IsFailure) return Result.Failure&lt;string&gt;(nameResult.Errors, nameResult.TraceId);\n\nvar created = await _repository.CreateAsync(nameResult.Value, cancellationToken);\nreturn Result.Success(created.Id, nameResult.TraceId);\n</code></pre>"},{"location":"extensions/core/#compatibility-notes","title":"Compatibility notes","text":"<ul> <li>Drop-in for template behaviors: Signatures are compatible with <code>cfg.AddOpenBehavior</code> and <code>AddOpenRequestPreProcessor</code> in the template DI (<code>LoggingPreProcessor</code> for pre-processing, <code>LoggingBehavior</code> for pipeline). Swap registrations without changing handlers.</li> <li>Interop with existing Result: You can map template <code>Result</code> to/from Core\u2019s <code>Result</code> by projecting errors into <code>Error</code> codes/messages and vice versa (e.g., <code>Result.Success().Errors</code> \u2192 <code>Result.Success(traceId)</code>).</li> <li>EF interceptors: <code>DomainEventTracker</code> can complement <code>DispatchDomainEventsInterceptor</code>; use the tracker when you need to buffer events outside DbContext lifetime or forward to a bus/outbox.</li> <li>Time/Auditing: Replace <code>TimeProvider</code> injections with <code>IClock</code> adapters that internally call <code>TimeProvider.System</code> if you need 1:1 behavior.</li> </ul>"},{"location":"extensions/core/#configuration-reference","title":"Configuration reference","text":"<p>Configure inline (as above) for clarity in samples. If you prefer configuration binding, call <code>services.AddCleanArchitectureCore(opts =&gt; configuration.GetSection(\"Extensions:Core\").Bind(opts));</code>.</p>"},{"location":"extensions/core/#troubleshooting-adoption-tips","title":"Troubleshooting &amp; adoption tips","text":"<ul> <li>Missing correlation ID in logs: ensure <code>ILogContext</code> is scoped, <code>CorrelationBehavior</code> runs before logging, and your logger adapter copies <code>ILogContext.CorrelationId</code> into scopes/enrichers.</li> <li>Performance logs silent: confirm <code>EnablePerformanceLogging</code> is true and behavior is registered; ensure <code>IClock</code> returns consistent <code>UtcNow</code>.</li> <li>Guard exceptions unexpected: switch strategy to <code>ReturnFailure</code> or <code>Accumulate</code>; when throwing, set <code>ExceptionFactory</code> to shape domain-specific exceptions.</li> <li>Too many <code>Result</code>-wrapped signatures: keep simple commands/queries returning primitives until you need rich errors; adopt Core Results incrementally via adapters.</li> </ul>"},{"location":"extensions/core/#what-to-read-next","title":"What to read next","text":"<ul> <li>Deep dive on results, composition patterns, and real-world handlers: Result primitives.</li> <li>For validation-focused behaviors and FluentValidation hand-offs, see Validation extension.</li> <li>Multitenancy-specific pipeline glue lives in Multitenancy Core; it composes with the Core behaviors described here.</li> </ul>"},{"location":"extensions/exceptions/","title":"Extension: Exceptions","text":""},{"location":"extensions/exceptions/#overview","title":"Overview","text":"<p>Exception catalog, base exception types, redaction helpers, and a MediatR pipeline behavior that standardize how Clean Architecture solutions translate and log failures. Exceptions resolve to stable codes and severities, can be converted into <code>Result</code>/<code>Result&lt;T&gt;</code> (and the template\u2019s static <code>Result.Failure(IEnumerable&lt;string&gt;)</code>), and flow correlation/trace IDs into logs and error metadata.</p>"},{"location":"extensions/exceptions/#when-to-use","title":"When to use","text":"<ul> <li>You want predictable error codes/messages for handlers, APIs, background jobs, and tests instead of ad-hoc exceptions.</li> <li>You need to convert exceptions into <code>Result</code>/<code>Result&lt;T&gt;</code> without changing handler signatures.</li> <li>You rely on Jason Taylor\u2019s template <code>Result</code> shape and want compatibility without forking.</li> <li>You want centralized redaction and retry/transient classification guidance.</li> </ul>"},{"location":"extensions/exceptions/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target frameworks: <code>net10.0</code>.</li> <li>Dependencies: MediatR <code>14.0.0</code>, Microsoft.Extensions.Options <code>10.0.0</code>, CleanArchitecture.Extensions.Core.</li> <li>Template fit: register <code>ExceptionWrappingBehavior&lt;,&gt;</code> near the top of the MediatR pipeline (after correlation/logging, before authorization/validation/performance). It replaces the template\u2019s <code>UnhandledExceptionBehaviour&lt;,&gt;</code> while keeping handler signatures intact.</li> </ul>"},{"location":"extensions/exceptions/#install","title":"Install","text":"<pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Exceptions\n</code></pre>"},{"location":"extensions/exceptions/#usage","title":"Usage","text":""},{"location":"extensions/exceptions/#register-catalog-and-behavior","title":"Register catalog and behavior","text":"<pre><code>using CleanArchitecture.Extensions.Exceptions;\nusing CleanArchitecture.Extensions.Exceptions.Options;\nusing CleanArchitecture.Extensions.Exceptions.Catalog;\nusing CleanArchitecture.Extensions.Exceptions.BaseTypes;\nusing MediatR;\n\nservices.AddCleanArchitectureExceptions(options =&gt;\n{\n    options.ConvertToResult = true; // maps to Result/Result&lt;T&gt;/template Result\n    options.IncludeExceptionDetails = false; // prefer catalog messages in prod\n    options.RedactSensitiveData = true;\n    options.RethrowCancellationExceptions = true; // OperationCanceledException is bypassed by default\n    options.EnvironmentName = builder.Environment.EnvironmentName; // auto-enable details/stack in chosen environments\n    options.IncludeStackTrace = false; // set true or use IncludeStackTraceEnvironments for dev-only stack traces\n    options.StatusCodeOverrides[\"ERR.DOMAIN.GENERIC\"] = HttpStatusCode.UnprocessableEntity;\n});\n\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureExceptionsPipeline();\n});\n\n// Optional: catalog overrides\nservices.Configure&lt;ExceptionCatalogOptions&gt;(catalog =&gt;\n{\n    catalog.Descriptors.Add(new ExceptionDescriptor(\n        typeof(CustomDomainException),\n        \"ERR.DOMAIN.CUSTOM\",\n        \"Custom domain failure\",\n        ExceptionSeverity.Error));\n});\n</code></pre>"},{"location":"extensions/exceptions/#base-exceptions-and-codes","title":"Base exceptions and codes","text":"<ul> <li><code>NotFoundException</code> (<code>ERR.NOT_FOUND</code>, 404)</li> <li><code>ConflictException</code> (<code>ERR.CONFLICT</code>, 409)</li> <li><code>ForbiddenException</code>/<code>ForbiddenAccessException</code> (<code>ERR.SECURITY.FORBIDDEN</code>, 403)</li> <li><code>UnauthorizedException</code> (<code>ERR.SECURITY.UNAUTHORIZED</code>, 401)</li> <li><code>DomainException</code> (<code>ERR.DOMAIN.GENERIC</code>)</li> <li><code>ConcurrencyException</code> (<code>ERR.CONCURRENCY</code>, transient, 409)</li> <li><code>TransientException</code> (<code>ERR.TRANSIENT</code>, transient, 503)</li> <li>Validation + cancellation fallbacks (<code>ERR.VALIDATION</code>, <code>ERR.CANCELLED</code>) plus a generic <code>ERR.UNKNOWN</code></li> </ul>"},{"location":"extensions/exceptions/#result-conversion-and-logging","title":"Result conversion and logging","text":"<ul> <li>When <code>ConvertToResult</code> is <code>true</code>, exceptions map to <code>Result</code>/<code>Result&lt;T&gt;</code> errors (or the template <code>Result.Failure(IEnumerable&lt;string&gt;)</code> when the response type matches the template shape).</li> <li>Trace/correlation IDs flow into <code>Error.TraceId</code> using <code>ExceptionHandlingOptions.TraceId</code>, <code>ILogContext</code>, or <code>CoreExtensionsOptions.TraceId</code>.</li> <li><code>IncludeExceptionDetails</code> toggles whether raw exception messages flow to errors/logs; use <code>EnvironmentName</code> + <code>IncludeExceptionDetailsEnvironments</code> to enable details in Dev only. Redaction applies when <code>RedactSensitiveData</code> is enabled.</li> <li><code>IncludeStackTrace</code>/<code>IncludeStackTraceEnvironments</code> control whether stack traces are logged when details are enabled.</li> <li><code>RethrowExceptionTypes</code> defaults to cancellation + validation exceptions; add your own to bypass wrapping.</li> <li><code>StatusCodeOverrides</code> lets you remap catalog codes (e.g., <code>ERR.DOMAIN.GENERIC</code> -&gt; 422) without changing descriptors.</li> </ul>"},{"location":"extensions/exceptions/#customize-the-catalog-and-transient-classification","title":"Customize the catalog and transient classification","text":"<pre><code>using CleanArchitecture.Extensions.Exceptions.BaseTypes;\nusing CleanArchitecture.Extensions.Exceptions.Catalog;\nusing CleanArchitecture.Extensions.Exceptions.Options;\nusing System.Net;\n\nservices.Configure&lt;ExceptionCatalogOptions&gt;(options =&gt;\n{\n    options.Descriptors.Add(new ExceptionDescriptor(\n        typeof(HttpRequestException),\n        ExceptionCodes.Transient,\n        \"Downstream HTTP request failed.\",\n        ExceptionSeverity.Warning,\n        isTransient: true,\n        statusCode: HttpStatusCode.BadGateway));\n});\n\nvar isTransient = ExceptionClassifier.IsTransient(exception, catalog);\n</code></pre>"},{"location":"extensions/exceptions/#redaction-defaults","title":"Redaction defaults","text":"<p><code>ExceptionRedactor</code> scrubs bearer tokens, passwords, secrets, cookies, and basic email/token patterns from messages and metadata when <code>RedactSensitiveData</code> is enabled. Override by supplying your own redactor instance to the behavior if you need stricter rules.</p>"},{"location":"extensions/exceptions/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Exceptions still rethrow: ensure the type isn\u2019t listed in <code>ExceptionHandlingOptions.RethrowExceptionTypes</code> and that <code>RethrowCancellationExceptions</code> isn\u2019t forcing a bypass.</li> <li>Generic messages: set the exception message on your application/domain exceptions; catalog defaults are used when messages are empty. Enable <code>IncludeExceptionDetails</code> for debugging.</li> <li>No Result conversion: return types must be <code>Result</code>, <code>Result&lt;T&gt;</code>, or the template <code>Result</code> with a static <code>Failure(IEnumerable&lt;string&gt;)</code> method; otherwise the behavior will rethrow after logging.</li> </ul>"},{"location":"extensions/exceptions/#samples-tests","title":"Samples &amp; Tests","text":"<ul> <li>Tests: <code>tests/CleanArchitecture.Extensions.Exceptions.Tests</code>.</li> <li>Samples: follow the pipeline samples under <code>samples/CleanArchitecture.Extensions.Core.*</code> until a dedicated Exceptions sample lands.</li> </ul>"},{"location":"extensions/multitenancy-core/","title":"Extension: Multitenancy Core","text":""},{"location":"extensions/multitenancy-core/#overview","title":"Overview","text":"<p>Tenant context and resolution primitives for Clean Architecture solutions.</p>"},{"location":"extensions/multitenancy-core/#when-to-use","title":"When to use","text":"<ul> <li>You need per-tenant isolation (data access, caching, authorization).</li> <li>You want pluggable tenant resolution strategies (host/header/route/claims).</li> </ul>"},{"location":"extensions/multitenancy-core/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target .NET: TBD</li> <li>CleanArchitecture template: TBD</li> <li>Dependencies: TBD</li> </ul>"},{"location":"extensions/multitenancy-core/#install","title":"Install","text":"<p>`\bash</p>"},{"location":"extensions/multitenancy-core/#replace-with-actual-package-name-when-published","title":"replace with actual package name when published","text":"<p>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Multitenancy `</p>"},{"location":"extensions/multitenancy-core/#usage","title":"Usage","text":"<ul> <li>Register tenant resolution middleware/providers.</li> <li>Flow TenantId through application services and persistence.</li> <li>Add behaviors/filters to enforce tenant scope.</li> </ul>"},{"location":"extensions/multitenancy-core/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure a tenant resolution strategy is configured; fallbacks should be explicit.</li> <li>Log resolved tenant identifiers and resolution source for diagnostics.</li> </ul>"},{"location":"extensions/multitenancy-core/#samples-tests","title":"Samples &amp; Tests","text":"<ul> <li>Link to runnable sample (add when available).</li> <li>Link to related tests once published.</li> </ul>"},{"location":"extensions/validation/","title":"Extension: Validation","text":""},{"location":"extensions/validation/#overview","title":"Overview","text":"<p>Validation pipeline and helpers built on FluentValidation for Clean Architecture solutions. Ships a configurable MediatR behaviour, a template-shaped <code>ValidationException</code>, rule helpers, and a base validator that applies common conventions. Designed to be drop-in compatible with Jason Taylor\u2019s template while enabling Result-based short-circuiting when desired.</p>"},{"location":"extensions/validation/#when-to-use","title":"When to use","text":"<ul> <li>You follow the template\u2019s MediatR pipeline and want richer control over how validation failures surface (throw vs Result vs notify).</li> <li>You need shared validator conventions and basic rule helpers for identifiers, paging, and email without re-writing boilerplate.</li> <li>You want compatibility with existing <code>ValidationException</code> handling (dictionary of property -&gt; messages) but also want to map failures to <code>Result</code>.</li> </ul>"},{"location":"extensions/validation/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target frameworks: <code>net10.0</code>.</li> <li>Dependencies: FluentValidation <code>12.1.1</code>, MediatR <code>14.0.0</code>.</li> <li>Template fit: register the behavior in Application after Authorization and before Performance, same signature as the template\u2019s <code>ValidationBehaviour&lt;,&gt;</code>.</li> </ul>"},{"location":"extensions/validation/#install","title":"Install","text":"<pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Validation\n</code></pre>"},{"location":"extensions/validation/#usage","title":"Usage","text":""},{"location":"extensions/validation/#wire-up-validators-and-behaviour-di","title":"Wire up validators and behaviour (DI)","text":"<pre><code>using CleanArchitecture.Extensions.Validation;\nusing CleanArchitecture.Extensions.Validation.Options;\nusing FluentValidation;\nusing MediatR;\n\nservices.AddCleanArchitectureValidation(options =&gt;\n{\n    options.Strategy = ValidationStrategy.Throw; // default to template behavior\n    options.MaxFailures = 50;\n    options.IncludeAttemptedValue = false;\n});\n\nservices.AddValidatorsFromAssemblyContaining&lt;Startup&gt;(); // or your Application assembly marker\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Startup&gt;();\n    cfg.AddCleanArchitectureValidationPipeline(); // place after Authorization, before Performance\n});\n</code></pre>"},{"location":"extensions/validation/#strategies","title":"Strategies","text":"<ul> <li><code>Throw</code> (default): matches template; throws <code>ValidationException</code> with <code>Dictionary&lt;string,string[]&gt;</code>.</li> <li><code>ReturnResult</code>: short-circuits with <code>Result.Failure</code>/<code>Result&lt;T&gt;.Failure</code> when handlers return <code>Result</code>. Also understands the template\u2019s <code>Result</code> shape (Succeeded + Errors) by invoking its static <code>Failure(IEnumerable&lt;string&gt;)</code> method.</li> <li><code>Notify</code>: publishes via <code>IValidationNotificationPublisher</code> then either throws or returns <code>Result</code> based on <code>NotifyBehavior</code>.</li> </ul> <p>Key options: <code>MaxFailures</code>, <code>IncludePropertyName</code>, <code>IncludeAttemptedValue</code>, <code>IncludePlaceholderValues</code>, <code>DefaultErrorCode</code>, <code>TraceId</code>, <code>ErrorCodeSelector</code>, <code>MessageFormatter</code>.</p>"},{"location":"extensions/validation/#error-model","title":"Error model","text":"<ul> <li><code>ValidationError</code> maps FluentValidation failures to Core <code>Error</code>, carrying code, message, property, attempted value (opt-in), severity, and metadata.</li> <li><code>ValidationException</code> is provided for compatibility with the template\u2019s shape and can be thrown by the behavior.</li> </ul>"},{"location":"extensions/validation/#base-validator-rules","title":"Base validator + rules","text":"<ul> <li><code>AbstractValidatorBase&lt;T&gt;</code> sets rule-level cascade to fail fast per chain.</li> <li><code>Rules/CommonRules</code> helpers:</li> <li><code>NotEmptyTrimmed</code></li> <li><code>EmailAddressBasic</code></li> <li><code>OptionalEmailAddress</code></li> <li><code>PositiveId</code></li> <li><code>PageNumber</code></li> <li><code>PageSize</code></li> <li><code>PhoneE164</code></li> <li><code>UrlAbsoluteHttpHttps</code></li> <li><code>CultureCode</code></li> <li><code>SortExpression</code> (whitelist allowed fields)</li> <li>Tenant-aware rules (planned with the Multitenancy module)</li> </ul>"},{"location":"extensions/validation/#result-short-circuit-example","title":"Result short-circuit example","text":"<pre><code>var options = new ValidationOptions { Strategy = ValidationStrategy.ReturnResult };\nvar behavior = new ValidationBehaviour&lt;CreateTodo, Result&lt;TodoVm&gt;&gt;(validators, options);\n// When validation fails, the behaviour returns Result&lt;T&gt;.Failure(errors) instead of throwing.\n</code></pre>"},{"location":"extensions/validation/#roadmap","title":"Roadmap","text":"<ul> <li>ASP.NET Core adapters (MVC/endpoint filters) for global model validation outside MediatR.</li> <li>Standalone validator provider for background jobs/message handlers using the same strategies/options.</li> <li>Tenant-aware rule helpers once multitenancy ships.</li> <li>Profiling/metrics hooks (timing + counters) once the Observability module is available.</li> </ul>"},{"location":"extensions/validation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Behavior throws when handler return type is not <code>Result</code>/<code>Result&lt;T&gt;</code> and strategy is <code>ReturnResult</code>/<code>Notify</code> with <code>ReturnResult</code>; switch to <code>Throw</code> or update handler return types.</li> <li>Missing correlation/trace IDs: set <code>ValidationOptions.TraceId</code> from your pipeline or leave null to let downstream behaviors apply correlation.</li> </ul>"},{"location":"extensions/validation/#samples-tests","title":"Samples &amp; Tests","text":"<ul> <li>See <code>tests/CleanArchitecture.Extensions.Validation.Tests</code> for strategy coverage and rule helper usage.</li> </ul>"},{"location":"getting-started/adoption-playbooks/","title":"Adoption playbooks (from README Appendix B)","text":""},{"location":"getting-started/adoption-playbooks/#appendix-b-scenario-matrices-and-play-patterns","title":"Appendix B \u2014 scenario matrices and play-patterns","text":""},{"location":"getting-started/adoption-playbooks/#telemetry-first-adoption","title":"Telemetry-first adoption","text":"<p>Start with Core correlation, logging, and performance behaviors to light up request tracing in development. Layer Observability (when available) to export OTEL traces without touching handlers. Pair with Validation to surface meaningful errors early. This pattern suits teams that need better diagnostics before expanding functionality.</p> <p>How to get started:</p> <ul> <li>Identify which extensions are already available (Core and Validation today) and wire them following the quickstart.</li> <li>Read the matching HighLevelDocs entries for upcoming modules to understand required seams in your code.</li> <li>Sketch pipeline ordering and configuration toggles so adoption is a config change, not a refactor.</li> <li>Run the samples closest to your scenario and adapt them into your solution structure.</li> <li>Track the docs site and release notes for module-specific guidance as packages ship.</li> </ul> <p>Success signals to look for:</p> <ul> <li>Logs and traces include correlation IDs and, when applicable, tenant identifiers.</li> <li>Validation errors are predictable and localized to the entry points where they belong.</li> <li>Pipeline ordering is explicit and documented in your solution.</li> <li>Teams can add or remove an extension via NuGet plus configuration without code churn.</li> <li>Samples and docs in this repo stay aligned with what you have in production.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#migration-from-template-result","title":"Migration from template Result","text":"<p>Use Core's LegacyResult shims to bridge from the template's bool+errors shape to the richer Result model. Migrate handlers incrementally while keeping controllers untouched. Add Validation with ReturnResult strategy to avoid exceptions where you want explicit outcomes. This keeps production stable while you modernize internals.</p> <p>How to get started:</p> <ul> <li>Identify which extensions are already available (Core and Validation today) and wire them following the quickstart.</li> <li>Read the matching HighLevelDocs entries for upcoming modules to understand required seams in your code.</li> <li>Sketch pipeline ordering and configuration toggles so adoption is a config change, not a refactor.</li> <li>Run the samples closest to your scenario and adapt them into your solution structure.</li> <li>Track the docs site and release notes for module-specific guidance as packages ship.</li> </ul> <p>Success signals to look for:</p> <ul> <li>Logs and traces include correlation IDs and, when applicable, tenant identifiers.</li> <li>Validation errors are predictable and localized to the entry points where they belong.</li> <li>Pipeline ordering is explicit and documented in your solution.</li> <li>Teams can add or remove an extension via NuGet plus configuration without code churn.</li> <li>Samples and docs in this repo stay aligned with what you have in production.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#saas-with-tenant-isolation","title":"SaaS with tenant isolation","text":"<p>Adopt multitenancy core for tenant resolution and enforcement once it lands. Pair it with EFCore and AspNetCore adapters to enforce tenant boundaries in data and HTTP layers. Add RateLimiting and Caching using tenant-aware strategies. When billing arrives, connect Payments and Provisioning to automate onboarding and subscription state.</p> <p>How to get started:</p> <ul> <li>Identify which extensions are already available (Core and Validation today) and wire them following the quickstart.</li> <li>Read the matching HighLevelDocs entries for upcoming modules to understand required seams in your code.</li> <li>Sketch pipeline ordering and configuration toggles so adoption is a config change, not a refactor.</li> <li>Run the samples closest to your scenario and adapt them into your solution structure.</li> <li>Track the docs site and release notes for module-specific guidance as packages ship.</li> </ul> <p>Success signals to look for:</p> <ul> <li>Logs and traces include correlation IDs and, when applicable, tenant identifiers.</li> <li>Validation errors are predictable and localized to the entry points where they belong.</li> <li>Pipeline ordering is explicit and documented in your solution.</li> <li>Teams can add or remove an extension via NuGet plus configuration without code churn.</li> <li>Samples and docs in this repo stay aligned with what you have in production.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#event-driven-integration","title":"Event-driven integration","text":"<p>Lean on Core domain events today and plan for MessageBus and Outbox patterns to publish integration events with correlation IDs and tenant context. Observability will carry traces across process boundaries. Notifications can react to events for user-facing messages. This pattern is suited for teams integrating with other services via asynchronous pipelines.</p> <p>How to get started:</p> <ul> <li>Identify which extensions are already available (Core and Validation today) and wire them following the quickstart.</li> <li>Read the matching HighLevelDocs entries for upcoming modules to understand required seams in your code.</li> <li>Sketch pipeline ordering and configuration toggles so adoption is a config change, not a refactor.</li> <li>Run the samples closest to your scenario and adapt them into your solution structure.</li> <li>Track the docs site and release notes for module-specific guidance as packages ship.</li> </ul> <p>Success signals to look for:</p> <ul> <li>Logs and traces include correlation IDs and, when applicable, tenant identifiers.</li> <li>Validation errors are predictable and localized to the entry points where they belong.</li> <li>Pipeline ordering is explicit and documented in your solution.</li> <li>Teams can add or remove an extension via NuGet plus configuration without code churn.</li> <li>Samples and docs in this repo stay aligned with what you have in production.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#compliance-and-audit-readiness","title":"Compliance and audit readiness","text":"<p>Plan for Audit to capture who did what and when, using Core's time and correlation primitives. Pair with Authorization and Settings to enforce policies and runtime overrides. Localization will help surface user-facing messages in the right language, and FeatureFlags can gate risky changes. Samples will include audit trails for commands and data changes.</p> <p>How to get started:</p> <ul> <li>Identify which extensions are already available (Core and Validation today) and wire them following the quickstart.</li> <li>Read the matching HighLevelDocs entries for upcoming modules to understand required seams in your code.</li> <li>Sketch pipeline ordering and configuration toggles so adoption is a config change, not a refactor.</li> <li>Run the samples closest to your scenario and adapt them into your solution structure.</li> <li>Track the docs site and release notes for module-specific guidance as packages ship.</li> </ul> <p>Success signals to look for:</p> <ul> <li>Logs and traces include correlation IDs and, when applicable, tenant identifiers.</li> <li>Validation errors are predictable and localized to the entry points where they belong.</li> <li>Pipeline ordering is explicit and documented in your solution.</li> <li>Teams can add or remove an extension via NuGet plus configuration without code churn.</li> <li>Samples and docs in this repo stay aligned with what you have in production.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#developer-experience-at-scale","title":"Developer experience at scale","text":"<p>Templates and CLI will let teams scaffold new services with extensions pre-wired. Testing utilities will standardize handler tests with deterministic clocks and fake loggers. NuGetPackaging and SourceLinkAndSymbols keep packages consistent. This path is for organizations standardizing on Clean Architecture and needing reproducible setups across squads.</p> <p>How to get started:</p> <ul> <li>Identify which extensions are already available (Core and Validation today) and wire them following the quickstart.</li> <li>Read the matching HighLevelDocs entries for upcoming modules to understand required seams in your code.</li> <li>Sketch pipeline ordering and configuration toggles so adoption is a config change, not a refactor.</li> <li>Run the samples closest to your scenario and adapt them into your solution structure.</li> <li>Track the docs site and release notes for module-specific guidance as packages ship.</li> </ul> <p>Success signals to look for:</p> <ul> <li>Logs and traces include correlation IDs and, when applicable, tenant identifiers.</li> <li>Validation errors are predictable and localized to the entry points where they belong.</li> <li>Pipeline ordering is explicit and documented in your solution.</li> <li>Teams can add or remove an extension via NuGet plus configuration without code churn.</li> <li>Samples and docs in this repo stay aligned with what you have in production.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#inspiration-and-gratitude","title":"Inspiration and gratitude","text":"<p>This project exists because of Jason Taylor's Clean Architecture template. The template gives teams a clear starting point; this repository gives them an ecosystem to grow without forking. If you are new here, start by reading Jason's repository: https://github.com/jasontaylordev/CleanArchitecture. Then come back and plug in only what you need.</p>"},{"location":"getting-started/adoption-playbooks/#next-steps-for-readers","title":"Next steps for readers","text":"<ul> <li>If you want to build with what exists today: install Core and Validation, run the samples, read the Core and Validation docs, and wire the behaviors into your pipeline.</li> <li>If you want to contribute: pick a work-in-progress module, read its HighLevelDocs design, and start with docs and sample scaffolding before coding.</li> <li>If you want to keep tabs: watch the repo and the GitHub Pages site for release notes and roadmap updates.</li> </ul> <p>This README is intentionally comprehensive and long-form to capture newcomers at first glance and give veterans the depth they need. The links above take you directly to the working docs, samples, and design plans. Use what you need today, and help shape what ships next.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install the shipping extensions (Core and Validation), wire them into a Jason Taylor Clean Architecture solution, and set up optional local tooling for docs. This page is practical and mirrors the README; copy/paste is encouraged.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET SDK <code>8.x</code> or <code>10.x</code> (building/running extensions, samples, and tests).</li> <li>Git (if you are cloning this repo).</li> <li>A solution created from Jason Taylor's template (<code>dotnet new clean-architecture</code> or install the template first).</li> <li>Optional for docs work: Python 3.10+ if you plan to build/serve the MkDocs site locally.</li> </ul>"},{"location":"getting-started/installation/#install-core","title":"Install Core","text":"<p>Add the package to your Application project (adjust project path/name as needed):</p> <pre><code>dotnet add src/YourProject.Application/YourProject.Application.csproj package CleanArchitecture.Extensions.Core --version 0.1.1-preview.1\n</code></pre> <p>Register pipeline behaviors (order mirrors the template: Correlation \u2192 Logging pre-processor \u2192 UnhandledException \u2192 Authorization \u2192 Validation \u2192 Performance \u2192 Handler):</p> <pre><code>services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(CorrelationBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(PerformanceBehavior&lt;,&gt;));\n</code></pre> <p>Optional configuration (see extensions/core-options.md):</p> <pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.CorrelationIdHeader = \"X-Correlation-ID\";\n    options.PerformanceThresholdMilliseconds = 250;\n    options.DefaultGuardStrategy = GuardStrategy.ReturnResult;\n});\n</code></pre>"},{"location":"getting-started/installation/#install-validation-if-you-use-fluentvalidation","title":"Install Validation (if you use FluentValidation)","text":"<p>Add the package:</p> <pre><code>dotnet add src/YourProject.Application/YourProject.Application.csproj package CleanArchitecture.Extensions.Validation --version 0.1.1-preview.1\n</code></pre> <p>Register validators and the behavior:</p> <pre><code>services.AddValidatorsFromAssemblyContaining&lt;CreateOrderValidator&gt;();\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(ValidationBehaviour&lt;,&gt;));\n</code></pre> <p>Configure behavior strategy (see extensions/validation.md):</p> <pre><code>services.Configure&lt;ValidationOptions&gt;(options =&gt;\n{\n    options.Strategy = ValidationStrategy.ReturnResult; // Throw | ReturnResult | Notify\n    options.IncludePropertyName = true;\n    options.LogValidationFailures = true;\n    options.SeverityLogLevels[Severity.Error] = LogLevel.Warning;\n});\n</code></pre>"},{"location":"getting-started/installation/#restore-build-and-run","title":"Restore, build, and run","text":"<ul> <li>Restore packages: <code>dotnet restore</code></li> <li>Build: <code>dotnet build</code></li> <li>Run your API (or the project that triggers MediatR):\\   <code>dotnet run --project src/YourProject.Api/YourProject.Api.csproj</code></li> <li>Trigger a request and check logs for correlation IDs, performance warnings, and validation results.</li> </ul> <p>If you want a known-good baseline, run a sample from this repo:</p> <pre><code>dotnet run --project samples/CleanArchitecture.Extensions.Core.Pipeline.Sample/CleanArchitecture.Extensions.Core.Pipeline.Sample.csproj\n</code></pre>"},{"location":"getting-started/installation/#uninstall-or-rollback","title":"Uninstall or rollback","text":"<p>Because everything is opt-in, you can remove an extension cleanly:</p> <pre><code>dotnet remove src/YourProject.Application/YourProject.Application.csproj package CleanArchitecture.Extensions.Core\ndotnet remove src/YourProject.Application/YourProject.Application.csproj package CleanArchitecture.Extensions.Validation\n</code></pre> <p>Then remove the corresponding DI registrations and option bindings. Your solution returns to the baseline template behavior.</p>"},{"location":"getting-started/installation/#local-docs-tooling-optional","title":"Local docs tooling (optional)","text":"<p>If you want to build or serve the docs site locally:</p> <pre><code>python -m venv .venv\n. .venv/Scripts/Activate.ps1\npip install -r docs/requirements.txt\nmkdocs serve\n</code></pre> <p>Visit the local URL printed by MkDocs (default http://127.0.0.1:8000/) to preview changes.</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Package not found: ensure you are on .NET 8 or 10 and that your NuGet sources can reach the <code>CleanArchitecture.Extensions.*</code> preview packages.</li> <li>Correlation ID missing: confirm <code>CorrelationBehavior</code> is registered before logging/performance behaviors and that your logging provider includes scopes.</li> <li>Validation not firing: ensure validators are in the assembly you scan with <code>AddValidatorsFromAssemblyContaining&lt;...&gt;</code> and that <code>ValidationBehaviour</code> is registered.</li> <li>Too many performance warnings: adjust <code>PerformanceThresholdMilliseconds</code> or filter specific requests in logging configuration.</li> <li>Legacy Result migration: use <code>LegacyResult</code>/<code>LegacyResult&lt;T&gt;</code> from Core to bridge the template's result shape while you migrate handlers.</li> </ul>"},{"location":"getting-started/installation/#where-to-go-next","title":"Where to go next","text":"<ul> <li>Quickstart (step-by-step wiring with expected output): quickstart.md</li> <li>Core deep dives: extensions/core.md \u00b7 core-result-primitives \u00b7 core-pipeline-behaviors</li> <li>Validation deep dive: extensions/validation.md</li> <li>Concepts: architecture fit \u00b7 composition &amp; invariants</li> <li>Recipes and samples: recipes/authentication.md \u00b7 recipes/caching.md \u00b7 samples/index.md</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Install the first two extensions (Core and Validation), wire them into a Jason Taylor Clean Architecture solution, and verify behavior in minutes. This page is copy/paste friendly and mirrors the README while keeping you in the docs site.</p>"},{"location":"getting-started/quickstart/#what-you-will-accomplish","title":"What you will accomplish","text":"<ul> <li>Start from Jason Taylor's Clean Architecture template (no forking).</li> <li>Add <code>CleanArchitecture.Extensions.Core</code> for correlation/logging/performance, Result primitives, guards, domain events, time abstractions, and options.</li> <li>Add <code>CleanArchitecture.Extensions.Validation</code> for FluentValidation in the MediatR pipeline with configurable strategies.</li> <li>Wire behaviors in the right order, configure options, and run a sample to see everything working.</li> <li>Know where to go next (docs, samples, recipes, roadmap).</li> </ul>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET SDK <code>8.x</code> or <code>10.x</code> installed.</li> <li>A solution created from Jason Taylor's template (<code>dotnet new clean-architecture -n ...</code> or install the template first).</li> <li>An Application project that already uses MediatR and (optionally) FluentValidation.</li> <li>PowerShell or Bash available for running commands.</li> </ul>"},{"location":"getting-started/quickstart/#step-0-open-or-create-the-solution","title":"Step 0 \u2014 open or create the solution","text":"<ul> <li>If new: <code>dotnet new clean-architecture -n YourCompany.YourProduct</code></li> <li>If existing: open your current template-based solution and continue.</li> </ul> <p>Keep the upstream template untouched. Everything below is additive and reversible via package removal and DI registration changes.</p>"},{"location":"getting-started/quickstart/#step-1-add-core","title":"Step 1 \u2014 add Core","text":"<p>Install the package in your Application project (adjust path/name to your project):</p> <pre><code>dotnet add src/YourProject.Application/YourProject.Application.csproj package CleanArchitecture.Extensions.Core --version 0.1.1-preview.1\n</code></pre> <p>Register pipeline behaviors (order matches the template: Correlation \u2192 Logging pre-processor \u2192 UnhandledException \u2192 Authorization \u2192 Validation \u2192 Performance \u2192 Handler):</p> <pre><code>services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(CorrelationBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(PerformanceBehavior&lt;,&gt;));\n</code></pre> <p>Optional: configure Core defaults (see extensions/core-options.md):</p> <pre><code>services.Configure&lt;CoreExtensionsOptions&gt;(options =&gt;\n{\n    options.CorrelationIdHeader = \"X-Correlation-ID\";\n    options.PerformanceThresholdMilliseconds = 250;\n    options.DefaultGuardStrategy = GuardStrategy.ReturnResult;\n});\n</code></pre> <p>What this enables immediately:</p> <ul> <li>Correlation IDs flow through pipeline logs.</li> <li>Logging behavior emits structured start/finish entries.</li> <li>Performance warnings appear when handlers exceed the threshold.</li> <li>Result/Result, guard clauses, domain events, and time abstractions become available in Application code."},{"location":"getting-started/quickstart/#step-2-add-validation-if-you-use-fluentvalidation","title":"Step 2 \u2014 add Validation (if you use FluentValidation)","text":"<p>Install the package:</p> <pre><code>dotnet add src/YourProject.Application/YourProject.Application.csproj package CleanArchitecture.Extensions.Validation --version 0.1.1-preview.1\n</code></pre> <p>Register validators and the pipeline behavior:</p> <pre><code>services.AddValidatorsFromAssemblyContaining&lt;CreateOrderValidator&gt;();\nservices.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(ValidationBehaviour&lt;,&gt;));\n</code></pre> <p>Configure strategy and logging (see extensions/validation.md):</p> <pre><code>services.Configure&lt;ValidationOptions&gt;(options =&gt;\n{\n    options.Strategy = ValidationStrategy.ReturnResult; // Throw | ReturnResult | Notify\n    options.IncludePropertyName = true;\n    options.LogValidationFailures = true;\n    options.SeverityLogLevels[Severity.Error] = LogLevel.Warning;\n});\n</code></pre> <p>What this enables immediately:</p> <ul> <li>Validators run early in the pipeline, with correlation-aware logging.</li> <li>You choose how failures surface: exception, Result, or notification publisher.</li> <li>Reusable rule catalog (<code>CommonRules</code>) for trimmed strings, email/phone, pagination, culture codes, and sort expressions.</li> </ul>"},{"location":"getting-started/quickstart/#step-3-run-and-verify","title":"Step 3 \u2014 run and verify","text":"<p>Run your Application project or a sample handler to exercise the pipeline:</p> <pre><code>dotnet run --project src/YourProject.Api/YourProject.Api.csproj\n</code></pre> <p>Trigger a request that hits MediatR. Check for:</p> <ul> <li>Correlation IDs present in logs.</li> <li>PerformanceBehavior warnings when you simulate slow handlers.</li> <li>Validation failures logged with property names when strategy is <code>ReturnResult</code> or <code>Notify</code>.</li> </ul> <p>If you prefer to see a known-good sample first, run one of the bundled samples:</p> <pre><code>dotnet run --project samples/CleanArchitecture.Extensions.Core.Pipeline.Sample/CleanArchitecture.Extensions.Core.Pipeline.Sample.csproj\n</code></pre> <p>Expected output (trimmed for clarity):</p> <pre><code>info: CorrelationBehavior[0] Request Starting CorrelationId=...\ninfo: LoggingBehavior[0] Handling Ping\nwarn: PerformanceBehavior[0] Long Running Request: Ping (310ms) CorrelationId=...\ninfo: LoggingBehavior[0] Handled Ping\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-adjust-for-your-environment","title":"Step 4 \u2014 adjust for your environment","text":"<ul> <li>Ordering: keep behaviors in the recommended order; add Authorization/Exception behaviors where your template already expects them.</li> <li>Strategy: choose <code>ValidationStrategy.Throw</code> for controller-friendly exceptions or <code>ReturnResult</code> for explicit handler outcomes.</li> <li>Guard style: set <code>GuardStrategy.Throw</code> or <code>GuardStrategy.ReturnResult</code> based on how you want to surface invariants.</li> <li>Correlation header: align <code>CoreExtensionsOptions.CorrelationIdHeader</code> with your gateway/load balancer conventions.</li> <li>Performance threshold: tune <code>PerformanceThresholdMilliseconds</code> per environment.</li> </ul>"},{"location":"getting-started/quickstart/#troubleshooting-fast-fixes","title":"Troubleshooting (fast fixes)","text":"<ul> <li>No correlation ID in logs: ensure <code>CorrelationBehavior</code> is registered before logging/performance behaviors and your logger includes scopes.</li> <li>Validation not firing: confirm validators are in the same assembly you scan with <code>AddValidatorsFromAssemblyContaining&lt;...&gt;</code> and that <code>ValidationBehaviour</code> is registered.</li> <li>Unexpected exceptions: if you prefer results, switch <code>ValidationOptions.Strategy</code> to <code>ReturnResult</code>; for guards, use <code>GuardStrategy.ReturnResult</code>.</li> <li>Package restore issues: verify you are on .NET 8 or 10 and that your NuGet feed has access to <code>CleanArchitecture.Extensions.*</code> preview packages.</li> <li>Slow handler warnings everywhere: raise <code>PerformanceThresholdMilliseconds</code> or filter specific requests in your logging configuration.</li> </ul>"},{"location":"getting-started/quickstart/#where-to-go-next","title":"Where to go next","text":"<ul> <li>Deep dives: Core \u00b7 Result primitives \u00b7 Pipeline behaviors \u00b7 Validation</li> <li>Concepts: Architecture fit \u00b7 Composition &amp; invariants</li> <li>Recipes: Authentication \u00b7 Caching</li> <li>Samples: Samples index (run any with <code>dotnet run --project &lt;path&gt;.csproj</code>)</li> <li>Roadmap and releases: Roadmap \u00b7 Release notes</li> </ul>"},{"location":"getting-started/quickstart/#quick-faq","title":"Quick FAQ","text":"<ul> <li>Do I need to fork the template? No. Install packages and register behaviors; the template stays pristine.</li> <li>Can I remove the extensions later? Yes. Uninstall the package and remove DI registrations to revert to baseline behavior.</li> <li>What frameworks are supported? Shipped packages target <code>net8.0</code> and <code>net10.0</code>.</li> <li>How do I migrate from the template's Result? Use <code>LegacyResult</code>/<code>LegacyResult&lt;T&gt;</code> in Core and move handlers over gradually.</li> <li>Is there a Minimal API/MVC adapter? Planned for Validation; watch the roadmap for adapter releases.</li> </ul>"},{"location":"getting-started/quickstart/#one-liner-recap","title":"One-liner recap","text":"<p>Install Core, wire correlation/logging/performance behaviors, optionally add Validation with your preferred strategy, run a sample to verify correlation and validation logs, then move to the deep dives and recipes as you adopt more capabilities.</p>"},{"location":"recipes/authentication/","title":"Recipe: Authentication","text":""},{"location":"recipes/authentication/#goal","title":"Goal","text":"<p>Wire authentication with extension-friendly hooks.</p>"},{"location":"recipes/authentication/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Auth provider chosen (e.g., JWT, IdentityServer) \u2014 placeholder until packages land.</li> </ul>"},{"location":"recipes/authentication/#steps","title":"Steps","text":"<ol> <li>Add the relevant authentication adapter package (TBD).</li> <li>Configure authentication in Program.cs (or equivalent) with provided helpers.</li> <li>Add middleware/filters for tenant-aware auth if needed.</li> </ol>"},{"location":"recipes/authentication/#verify","title":"Verify","text":"<ul> <li>Hitting a protected endpoint returns 200 with valid token; 401 otherwise.</li> </ul>"},{"location":"recipes/authentication/#pitfalls","title":"Pitfalls","text":"<ul> <li>Misaligned schemes between API and client; ensure defaults match.</li> <li>Ensure tenant resolution occurs before authz when multitenancy is enabled.</li> </ul>"},{"location":"recipes/caching/","title":"Recipe: Caching","text":""},{"location":"recipes/caching/#goal","title":"Goal","text":"<p>Add caching with clear cache key conventions and opt-in behaviors.</p>"},{"location":"recipes/caching/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Choose cache store (in-memory, distributed) \u2014 adapters TBD.</li> </ul>"},{"location":"recipes/caching/#steps","title":"Steps","text":"<ol> <li>Add the cache adapter package (TBD).</li> <li>Register cache services and behaviors.</li> <li>Apply caching to queries/handlers where appropriate; define cache durations and invalidation rules.</li> </ol>"},{"location":"recipes/caching/#verify","title":"Verify","text":"<ul> <li>First call hits data source; subsequent call hits cache (check logs/metrics).</li> </ul>"},{"location":"recipes/caching/#pitfalls","title":"Pitfalls","text":"<ul> <li>Cache stampede: add locking or jitter where needed.</li> <li>Tenant-aware caching: ensure keys include tenant context when multitenancy is enabled.</li> </ul>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>Configuration keys and environment variables for extensions.</p> <ul> <li>This section will expand per extension as packages ship.</li> <li>Include defaults, required values, and sample \u0007ppsettings snippets.</li> </ul>"},{"location":"reference/configuration/#placeholder-keys","title":"Placeholder keys","text":"<ul> <li>Extensions::Enabled <li>Extensions::Options (TBD per extension)"},{"location":"release-notes/","title":"Release Notes","text":"<p>Changelog for CleanArchitecture.Extensions (latest-only for now).</p> <ul> <li>Add a section per release once packages ship.</li> <li>Call out breaking changes and migration steps.</li> </ul>"},{"location":"roadmap/package-blueprints/","title":"Package blueprints (from README Appendix A)","text":""},{"location":"roadmap/package-blueprints/#appendix-a-package-by-package-blueprint-long-form","title":"Appendix A \u2014 package-by-package blueprint (long form)","text":""},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionscore","title":"CleanArchitecture.Extensions.Core (shipped \u2014 Core Architecture)","text":"<p>What we are building: CleanArchitecture.Extensions.Core is focused on Rich Result types, guard clauses, correlation-aware pipeline behaviors, logging abstractions, domain events, and deterministic time abstractions that mirror Jason Taylor's template without changing handler signatures. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Developers need drop-in behaviors for correlation, logging, and performance, plus expressive Result shapes to replace bool+errors without rewriting controllers. They also need guard clauses, domain events, and clocks to keep tests deterministic and handlers slim. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Plugs directly into MediatR pipelines and can be adopted incrementally using LegacyResult shims. Works with any logger through IAppLogger/ILogContext and feeds trace identifiers to downstream modules. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain1-CoreArchitectureExtensions/CleanArchitecture.Extensions.Core.md</li> <li>Planned docs entry: docs/extensions/core.md</li> <li>Sample plan: Samples already available for pipeline, logging, results, guards, time, options, and domain events.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Core would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Core will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsvalidation","title":"CleanArchitecture.Extensions.Validation (shipped \u2014 Core Architecture)","text":"<p>What we are building: CleanArchitecture.Extensions.Validation is focused on FluentValidation-powered MediatR behavior with switchable strategies (throw, return Result, notify) and shared rule catalog for email, phone, pagination, culture, and sort expressions. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Teams want predictable validation errors with correlation IDs, consistent logging, and the ability to avoid exceptions in background jobs while keeping the template's MediatR signature. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Aligns with Core's Result and logging abstractions, uses DI scanning from the template, and will later add minimal API filters and tenant-aware rules. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain1-CoreArchitectureExtensions/CleanArchitecture.Extensions.Validation.md</li> <li>Planned docs entry: docs/extensions/validation.md</li> <li>Sample plan: Sample ideas include validation in the pipeline plus notification publishers; shipped samples will accompany the package.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Validation would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Validation will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsexceptions","title":"CleanArchitecture.Extensions.Exceptions (shipped \u2014 Core Architecture)","text":"<p>What we shipped: CleanArchitecture.Extensions.Exceptions delivers an exception catalog with stable codes/statuses, base exception types, redaction helpers, retry classification, and a MediatR pipeline behavior that wraps unhandled exceptions into <code>Result</code>/<code>Result&lt;T&gt;</code> (including the template <code>Result</code> shape) while flowing correlation/trace IDs into logs and metadata. The goal is to keep handlers and domain logic free of transport concerns while giving API/background jobs consistent problem mappings.</p> <p>Why it matters for Clean Architecture teams: Teams get consistent problem details without leaking infrastructure exceptions, plus deterministic error codes for clients, retries, and observability. Handlers stay unchanged, yet callers can opt into Result-based flows or continue throwing when desired. Catalog defaults align with the template\u2019s missing <code>NotFoundException</code> and security exceptions so adopters regain parity without forking.</p> <p>How it integrates: Sits after correlation/logging behaviors and before validation/performance in the pipeline; adapters can plug into ASP.NET Core middleware for HTTP mapping. Correlation IDs, logging scopes, and Result metadata from Core are reused so diagnostics stay consistent. Optional <code>RethrowExceptionTypes</code> keeps validation/cancellation flowing through existing middleware when needed.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain1-CoreArchitectureExtensions/CleanArchitecture.Extensions.Exceptions.md</li> <li>Docs entry: docs/extensions/exceptions.md</li> <li>Tests: tests/CleanArchitecture.Extensions.Exceptions.Tests</li> <li>Sample plan: Samples will demonstrate HTTP/background exception translation and Result mapping.</li> </ul> <p>Adoption guidance: Register <code>ExceptionWrappingBehavior&lt;,&gt;</code> near the top of the pipeline, configure <code>ExceptionHandlingOptions</code> (result conversion, redaction, trace IDs, rethrow list), and override catalog descriptors when you need domain-specific codes/statuses. SourceLink, XML docs, and symbols ship with the package.</p> <p>Interoperability patterns: Compatibility notes will call out pipeline ordering, multitenancy interplay (tenant-aware metadata), and observability hooks once those modules land. For teams migrating from the baseline template, the behavior already understands the template <code>Result</code> static <code>Failure(IEnumerable&lt;string&gt;)</code> method to avoid controller rewrites.</p> <p>Monitoring and reliability: Redaction is on by default to keep secrets out of logs, and transient/concurrency descriptors are marked for retry policies. Guidance will continue to cover defaults vs production hardening, including how to combine with HTTP adapters and OTEL once Observability ships.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionscaching","title":"CleanArchitecture.Extensions.Caching (work in progress \u2014 Core Architecture)","text":"<p>What we are building: CleanArchitecture.Extensions.Caching is focused on Cache abstractions with memory and distributed providers plus pipeline behaviors for caching queries and invalidating on commands. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Teams that need deterministic cache keys, tenant-aware scoping, and cache busting tied to domain events without sprinkling cache logic across handlers. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will layer on Core's logging, correlation, and Result primitives, with adapters for Redis and other stores arriving via Domain 5. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain1-CoreArchitectureExtensions/CleanArchitecture.Extensions.Caching.md</li> <li>Planned docs entry: docs/extensions/caching.md (planned)</li> <li>Sample plan: Samples will include query caching with eviction on command success and cache-hit telemetry.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Caching would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Caching will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancy","title":"CleanArchitecture.Extensions.Multitenancy (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy is focused on Tenant info model, current tenant provider, header/host/route/claim/composite resolution, middleware, attributes, and enforcement/validation behaviors. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: SaaS teams need tenant resolution at HTTP edges, enforcement in MediatR, and tenant metadata flowing into logging and caching to avoid cross-tenant leakage. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will provide ICurrentTenant abstraction consumed by EFCore, Identity, caching, storage, and messaging adapters. Pipeline behaviors will align with validation and authorization ordering. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.md</li> <li>Planned docs entry: docs/extensions/multitenancy-core.md</li> <li>Sample plan: Planned samples include header-based and route-based tenant resolution with enforcement behaviors in action.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyefcore","title":"CleanArchitecture.Extensions.Multitenancy.EFCore (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy.EFCore is focused on EF Core helpers for shared database, schema-per-tenant, and database-per-tenant strategies with global query filters and tenant-aware DbContext factories. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Projects need to enforce tenant isolation in EF, manage migrations per tenant, and seed data safely while switching strategies over time. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will hook into the multitenancy core for tenant context, reuse Core logging and trace IDs, and ship interceptors/filters to add tenant predicates automatically. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.EFCore.md</li> <li>Planned docs entry: docs/extensions/multitenancy-efcore.md (planned)</li> <li>Sample plan: Samples will show global filters, schema migrations, and seeding scripts for new tenants.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy.EFCore would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy.EFCore will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyaspnetcore","title":"CleanArchitecture.Extensions.Multitenancy.AspNetCore (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy.AspNetCore is focused on AspNetCore helpers for route/host/header tenant providers, minimal API filters, endpoint metadata, and middleware that sets tenant context early. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: APIs that must reject requests without tenant context and supply consistent error responses; apps that map tenants to routes or hosts and need helpers to stay DRY. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will align with the template's middleware pipeline, flow tenant info into ILogContext, and compose with Validation and Authorization behaviors. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.AspNetCore.md</li> <li>Planned docs entry: docs/extensions/multitenancy-aspnetcore.md (planned)</li> <li>Sample plan: Samples will demonstrate minimal API and controller setups with tenant filters and friendly error messages.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy.AspNetCore would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy.AspNetCore will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyidentity","title":"CleanArchitecture.Extensions.Multitenancy.Identity (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy.Identity is focused on Tenant-aware Identity extensions including tenant claim mapping, ITenantUser abstractions, policy provider, and per-tenant role handling. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Authentication flows where users belong to specific tenants, login isolation is required, and tokens must carry tenant claims reliably. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will integrate with ASP.NET Core Identity, multitenancy core, and Authorization policies while remaining optional for non-Identity auth stacks. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.Identity.md</li> <li>Planned docs entry: docs/extensions/multitenancy-identity.md (planned)</li> <li>Sample plan: Samples will cover login flows that populate tenant claims and authorize tenant-scoped resources.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy.Identity would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy.Identity will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancysharding","title":"CleanArchitecture.Extensions.Multitenancy.Sharding (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy.Sharding is focused on Shard resolution strategies (hash, range, geo) and connection managers for large datasets that need partitioning alongside tenant isolation. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Data-intensive systems that must route requests to the right shard while keeping tenant context intact; operators who need to rebalance shards safely. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will align with multitenancy core for tenant identification, with caching and message bus adapters to keep shard context consistent end to end. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.Sharding.md</li> <li>Planned docs entry: docs/extensions/multitenancy-sharding.md (planned)</li> <li>Sample plan: Samples will show shard selection strategies and metrics for shard performance.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy.Sharding would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy.Sharding will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyprovisioning","title":"CleanArchitecture.Extensions.Multitenancy.Provisioning (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy.Provisioning is focused on Tenant onboarding workflows, provisioning events, schema creation, and per-tenant seed orchestration. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Automating tenant creation, initializing schemas, and notifying other systems (billing, notifications) as tenants onboard or offboard. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will emit events that other modules (Notifications, Audit) can subscribe to, and will use storage/EF adapters to create per-tenant artifacts. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.Provisioning.md</li> <li>Planned docs entry: docs/extensions/multitenancy-provisioning.md (planned)</li> <li>Sample plan: Samples will walk through end-to-end tenant provisioning from HTTP request to seeded data.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy.Provisioning would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy.Provisioning will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancystorage","title":"CleanArchitecture.Extensions.Multitenancy.Storage (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy.Storage is focused on Tenant-aware blob and file storage abstractions with folder strategies and consistent keying. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Products that need to segregate files per tenant on shared storage accounts, enforce folder naming, and migrate existing assets safely. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will leverage ICurrentTenant from multitenancy core and storage adapters from Domain 5 to keep physical storage aligned with tenant context. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.Storage.md</li> <li>Planned docs entry: docs/extensions/multitenancy-storage.md (planned)</li> <li>Sample plan: Samples will include upload/download flows that automatically scope paths by tenant.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy.Storage would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy.Storage will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyredis","title":"CleanArchitecture.Extensions.Multitenancy.Redis (work in progress \u2014 Multitenancy)","text":"<p>What we are building: CleanArchitecture.Extensions.Multitenancy.Redis is focused on Tenant-safe Redis usage with key prefixing conventions and helpers for cache isolation. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Distributed caches shared across tenants that require strict key isolation and predictable eviction strategies. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will sit on top of the Caching module and coordinate with multitenancy core to derive tenant-aware cache keys. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.Redis.md</li> <li>Planned docs entry: docs/extensions/multitenancy-redis.md (planned)</li> <li>Sample plan: Samples will show cache gets/sets with tenant prefixes and metrics for cache hits by tenant.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Multitenancy.Redis would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Multitenancy.Redis will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsaudit","title":"CleanArchitecture.Extensions.Audit (work in progress \u2014 Enterprise)","text":"<p>What we are building: CleanArchitecture.Extensions.Audit is focused on Audit events, entity diffs, command audit behaviors, and multiple audit stores (SQL, file, bus). This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Teams that need compliance-ready audit logs tied to correlation IDs and entity changes, with storage choices based on environment. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will depend on Core for time and correlation, integrate with multitenancy for tenant markers, and expose behaviors that plug into MediatR. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain3-EnterpriseExtensions/CleanArchitecture.Extensions.Audit.md</li> <li>Planned docs entry: docs/extensions/audit.md (planned)</li> <li>Sample plan: Samples will illustrate audit events for commands and entity diffs with storage providers swapped in/out.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Audit would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Audit will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionssettings","title":"CleanArchitecture.Extensions.Settings (work in progress \u2014 Enterprise)","text":"<p>What we are building: CleanArchitecture.Extensions.Settings is focused on Runtime settings with key-value and JSON providers, typed accessors, and optional tenant overrides without redeployments. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Operations teams adjusting thresholds, toggles, or URLs at runtime; product teams enabling tenant-specific overrides without code changes. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will align with Options pattern, integrate with FeatureFlags and Authorization, and support database/file-backed providers. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain3-EnterpriseExtensions/CleanArchitecture.Extensions.Settings.md</li> <li>Planned docs entry: docs/extensions/settings.md (planned)</li> <li>Sample plan: Samples will include dynamic configuration reload and tenant override examples.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Settings would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Settings will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsfeatureflags","title":"CleanArchitecture.Extensions.FeatureFlags (work in progress \u2014 Enterprise)","text":"<p>What we are building: CleanArchitecture.Extensions.FeatureFlags is focused on Feature definitions, providers (memory/db), tenant/user overrides, evaluation behavior, and feature attributes for handlers and endpoints. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Progressive rollout of features, canary releases per tenant, and experimentation without long-lived branches. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will integrate with Settings and Authorization, use correlation IDs for observability, and expose MediatR behaviors for feature checks. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain3-EnterpriseExtensions/CleanArchitecture.Extensions.FeatureFlags.md</li> <li>Planned docs entry: docs/extensions/feature-flags.md (planned)</li> <li>Sample plan: Samples will demonstrate feature evaluation in commands and minimal APIs with toggle switches.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.FeatureFlags would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.FeatureFlags will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsnotifications","title":"CleanArchitecture.Extensions.Notifications (work in progress \u2014 Enterprise)","text":"<p>What we are building: CleanArchitecture.Extensions.Notifications is focused on Unified notification pipeline with providers for email, SMS, push, and template management. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Send templated messages in response to domain events or application commands; switch providers without changing handler logic. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will plug into Core logging and multitenancy for tenant-specific channels, and expose a NotificationBehavior for MediatR when needed. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain3-EnterpriseExtensions/CleanArchitecture.Extensions.Notifications.md</li> <li>Planned docs entry: docs/extensions/notifications.md (planned)</li> <li>Sample plan: Samples will show email and SMS dispatch using a template engine and mock providers for tests.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Notifications would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Notifications will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsratelimiting","title":"CleanArchitecture.Extensions.RateLimiting (work in progress \u2014 Enterprise)","text":"<p>What we are building: CleanArchitecture.Extensions.RateLimiting is focused on Configurable rate limits for commands, queries, and APIs with tenant/IP/user scopes and friendly failure surfaces. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Protect APIs from abuse, enforce tenant-specific quotas, and return consistent error payloads when limits are exceeded. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will offer minimal API filters, middleware, and MediatR behaviors; will integrate with Observability for metrics and with Multitenancy for tenant-aware limits. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain3-EnterpriseExtensions/CleanArchitecture.Extensions.RateLimiting.md</li> <li>Planned docs entry: docs/extensions/rate-limiting.md (planned)</li> <li>Sample plan: Samples will cover per-tenant and per-IP throttling with metrics emitted for dashboards.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.RateLimiting would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.RateLimiting will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionslocalization","title":"CleanArchitecture.Extensions.Localization (work in progress \u2014 Enterprise)","text":"<p>What we are building: CleanArchitecture.Extensions.Localization is focused on Resource providers, fallback rules, and dynamic translation helpers with optional tenant scoping. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Applications targeting multiple locales needing resource lookups that can be overridden per tenant or environment without code changes. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will align with Validation and Exceptions to localize messages and with multitenancy for per-tenant resource sets. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain3-EnterpriseExtensions/CleanArchitecture.Extensions.Localization.md</li> <li>Planned docs entry: docs/extensions/localization.md (planned)</li> <li>Sample plan: Samples will demonstrate localized validation errors and exception messages across cultures.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Localization would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Localization will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsauthorization","title":"CleanArchitecture.Extensions.Authorization (work in progress \u2014 Enterprise)","text":"<p>What we are building: CleanArchitecture.Extensions.Authorization is focused on Permission model, policy providers, role-per-tenant support, and decision engine for commands/queries and HTTP endpoints. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Permission-aware handlers that need to evaluate complex policies, sometimes per tenant, and return consistent failure responses. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will integrate with Identity when present, reuse multitenancy context, and expose behaviors to run before Validation/Performance. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain3-EnterpriseExtensions/CleanArchitecture.Extensions.Authorization.md</li> <li>Planned docs entry: docs/extensions/authorization.md (planned)</li> <li>Sample plan: Samples will cover permission checks in handlers and minimal APIs with policy wiring.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Authorization would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Authorization will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionspayments","title":"CleanArchitecture.Extensions.Payments (work in progress \u2014 SaaS)","text":"<p>What we are building: CleanArchitecture.Extensions.Payments is focused on Payments and subscriptions (starting with Stripe), webhook processing, billing events, and subscription lifecycle helpers. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: SaaS products billing tenants, handling upgrades/downgrades, and reacting to webhooks without scattering billing logic across handlers. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will publish billing events that Notifications and Provisioning can consume, and will include adapters for multitenant billing contexts. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain4-SaaSBusinessExtensions/CleanArchitecture.Extensions.Payments.md</li> <li>Planned docs entry: docs/extensions/payments.md (planned)</li> <li>Sample plan: Samples will mock Stripe flows, webhook verification, and subscription state transitions.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Payments would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Payments will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsdocuments","title":"CleanArchitecture.Extensions.Documents (work in progress \u2014 SaaS)","text":"<p>What we are building: CleanArchitecture.Extensions.Documents is focused on Document generation for PDF/Excel with template-driven rendering and storage-friendly outputs. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Exporting invoices, reports, and data extracts while keeping generation out of handlers and aligned with storage abstractions. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will work with Storage adapters to persist artifacts, with Notifications to deliver links, and with Settings for template configuration. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain4-SaaSBusinessExtensions/CleanArchitecture.Extensions.Documents.md</li> <li>Planned docs entry: docs/extensions/documents.md (planned)</li> <li>Sample plan: Samples will include report generation with template engines and storage uploads.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Documents would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Documents will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsusermanagement","title":"CleanArchitecture.Extensions.UserManagement (work in progress \u2014 SaaS)","text":"<p>What we are building: CleanArchitecture.Extensions.UserManagement is focused on User onboarding, invitations, MFA abstraction, and passwordless flows tuned for multitenant applications. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Invite flows, role assignment per tenant, and MFA enforcement without embedding provider specifics into Application handlers. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will align with Identity and Authorization modules, expose events for Notifications, and respect multitenancy context. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain4-SaaSBusinessExtensions/CleanArchitecture.Extensions.UserManagement.md</li> <li>Planned docs entry: docs/extensions/user-management.md (planned)</li> <li>Sample plan: Samples will demonstrate invitation acceptance, MFA setup, and passwordless login with mock providers.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.UserManagement would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.UserManagement will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsredis","title":"CleanArchitecture.Extensions.Redis (work in progress \u2014 Infrastructure)","text":"<p>What we are building: CleanArchitecture.Extensions.Redis is focused on Redis adapters for the caching abstraction with multi-tenant key strategies and optional pub/sub helpers. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Projects standardizing on Redis who want consistent key naming, instrumentation, and tenant-safe operations. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will wrap the Caching module APIs and align with Multitenancy.Redis for key prefixes and eviction rules. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain5-InfrastructureAdapters/CleanArchitecture.Extensions.Redis.md</li> <li>Planned docs entry: docs/extensions/redis.md (planned)</li> <li>Sample plan: Samples will show Redis-backed caching with health checks and diagnostics.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Redis would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Redis will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmessagebus","title":"CleanArchitecture.Extensions.MessageBus (work in progress \u2014 Infrastructure)","text":"<p>What we are building: CleanArchitecture.Extensions.MessageBus is focused on Message bus adapters for RabbitMQ, Azure Service Bus, and Kafka, with outbox patterns and integration event pipelines. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Handlers publishing integration events that must carry correlation and tenant metadata; consumers needing retry/resiliency guidance. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will align with Core correlation/logging, integrate with Observability for tracing, and expose message handlers that mimic MediatR behaviors. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain5-InfrastructureAdapters/CleanArchitecture.Extensions.MessageBus.md</li> <li>Planned docs entry: docs/extensions/message-bus.md (planned)</li> <li>Sample plan: Samples will include outbox/inbox flows and multi-transport adapters.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.MessageBus would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.MessageBus will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsobservability","title":"CleanArchitecture.Extensions.Observability (work in progress \u2014 Infrastructure)","text":"<p>What we are building: CleanArchitecture.Extensions.Observability is focused on OpenTelemetry tracing, logging enrichers, and metrics that honor correlation IDs and tenant context set by Core and Multitenancy. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Teams instrumenting handlers, message processing, and HTTP endpoints who want OTEL export with minimal wiring and consistent metadata. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will wrap Core logging abstractions, integrate with message bus adapters, and emit metrics that RateLimiting and Caching can use. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain5-InfrastructureAdapters/CleanArchitecture.Extensions.Observability.md</li> <li>Planned docs entry: docs/extensions/observability.md (planned)</li> <li>Sample plan: Samples will show trace propagation through MediatR, message buses, and HTTP requests.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Observability would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Observability will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsstorage","title":"CleanArchitecture.Extensions.Storage (work in progress \u2014 Infrastructure)","text":"<p>What we are building: CleanArchitecture.Extensions.Storage is focused on Storage adapters for Azure Blob, AWS S3, and local storage with consistent abstractions and retry guidance. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Projects needing to swap storage providers without touching Application code, with optional tenant folder strategies from Multitenancy.Storage. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will expose a storage abstraction consumed by Documents, UserManagement, and Multitenancy.Storage while using Core logging for diagnostics. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain5-InfrastructureAdapters/CleanArchitecture.Extensions.Storage.md</li> <li>Planned docs entry: docs/extensions/storage.md (planned)</li> <li>Sample plan: Samples will demonstrate uploads/downloads with different providers and integration with tenant folder strategies.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Storage would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Storage will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionssearch","title":"CleanArchitecture.Extensions.Search (work in progress \u2014 Infrastructure)","text":"<p>What we are building: CleanArchitecture.Extensions.Search is focused on Search adapters for ElasticSearch, Azure Search, and full-text providers with clean query interfaces. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Applications implementing search without committing to a provider, needing multi-tenant index strategies and consistent analyzers. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will align with Observability and Multitenancy to propagate correlation and tenant metadata; may include pipelines for indexing domain events. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain5-InfrastructureAdapters/CleanArchitecture.Extensions.Search.md</li> <li>Planned docs entry: docs/extensions/search.md (planned)</li> <li>Sample plan: Samples will show indexing and querying with interchangeable providers and tenant-aware indexes.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Search would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Search will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionscli","title":"CleanArchitecture.Extensions.CLI (work in progress \u2014 Developer Experience)","text":"<p>What we are building: CleanArchitecture.Extensions.CLI is focused on CLI for scaffolding modules, wiring extensions into projects, and generating CQRS artifacts with consistent conventions. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Developers who want <code>caext new module</code> or <code>caext add multitenancy</code> commands to wire packages and samples quickly. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will rely on Templates and NuGetPackaging conventions, and will include commands to fetch latest docs or snippets. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain6-DeveloperExperience/CleanArchitecture.Extensions.CLI.md</li> <li>Planned docs entry: docs/extensions/cli.md (planned)</li> <li>Sample plan: Samples will be command transcripts and generated projects showing the CLI output.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.CLI would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.CLI will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionstemplates","title":"CleanArchitecture.Extensions.Templates (work in progress \u2014 Developer Experience)","text":"<p>What we are building: CleanArchitecture.Extensions.Templates is focused on Template variants layered on Jason's base: multitenant, audit-ready, SaaS, and microservices-friendly starters. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Teams that want prewired solutions with extensions included, ensuring composition rules are respected without manual steps. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will track the upstream template closely, integrate with CLI commands, and include sample data and scripts per variant. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain6-DeveloperExperience/CleanArchitecture.Extensions.Templates.md</li> <li>Planned docs entry: docs/extensions/templates.md (planned)</li> <li>Sample plan: Templates will include runnable starter solutions; docs will show what is wired where.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Templates would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Templates will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionstesting","title":"CleanArchitecture.Extensions.Testing (work in progress \u2014 Developer Experience)","text":"<p>What we are building: CleanArchitecture.Extensions.Testing is focused on Testing utilities for CQRS handlers, tenant-aware contexts, and pipeline behaviors with fakes and fixtures. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Developers wanting to assert Results, domain events, and tenant-aware behaviors without verbose setup code. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will reuse Core abstractions (clock, logger, results) and plug into multitenancy/testing helpers for tenant context. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain6-DeveloperExperience/CleanArchitecture.Extensions.Testing.md</li> <li>Planned docs entry: docs/extensions/testing.md (planned)</li> <li>Sample plan: Samples will include test fixtures for handlers and pipeline behaviors with deterministic clocks.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.Testing would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.Testing will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionssourcelinkandsymbols","title":"CleanArchitecture.Extensions.SourceLinkAndSymbols (work in progress \u2014 Developer Experience)","text":"<p>What we are building: CleanArchitecture.Extensions.SourceLinkAndSymbols is focused on Build-time helpers to ensure NuGet packages ship with SourceLink and snupkg symbols consistently across modules. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Package maintainers ensuring debugger-friendly distributions without copy/pasting configuration across projects. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will be consumed by the build pipeline and referenced by new modules via props/targets files. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain6-DeveloperExperience/CleanArchitecture.Extensions.SourceLinkAndSymbols.md</li> <li>Planned docs entry: docs/extensions/sourcelink-and-symbols.md (planned)</li> <li>Sample plan: Samples will demonstrate stepping into package source from a consumer project.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.SourceLinkAndSymbols would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.SourceLinkAndSymbols will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsnugetpackaging","title":"CleanArchitecture.Extensions.NuGetPackaging (work in progress \u2014 Developer Experience)","text":"<p>What we are building: CleanArchitecture.Extensions.NuGetPackaging is focused on Packaging conventions, semantic versioning guidance, and CI tasks for publishing extensions with consistent metadata. This extension exists to keep the Clean Architecture layers honest while reducing the friction that teams feel when wiring cross-cutting concerns by hand. The goal is to let you add capability without bending the original template or leaking infrastructure details into Application and Domain code.</p> <p>Why it matters for Clean Architecture teams: Maintainers who need repeatable packaging with version bumps, changelog updates, and artifact signing across the ecosystem. The package narrative lives in the roadmap because we want contributors to see the intended surface area before a single line of code is written. When this lands, expect to see configuration defaults that match the template, clear points to hook into MediatR or middleware, and a way to back out gracefully if you choose not to adopt it.</p> <p>How it will integrate: Will be consumed by build scripts and CLI templates, ensuring every module ships with the same quality gates. We will reuse correlation IDs, logging scopes, and Result metadata from Core wherever possible so diagnostics stay consistent. Each adapter or behavior will be optional; you choose how deep you want to go based on your deployment and compliance needs.</p> <p>Documentation and design trail:</p> <ul> <li>Design notes: HighLevelDocs/Domain6-DeveloperExperience/CleanArchitecture.Extensions.NuGetPackaging.md</li> <li>Planned docs entry: docs/extensions/nuget-packaging.md (planned)</li> <li>Sample plan: Samples will include CI snippets and local packaging walkthroughs.</li> </ul> <p>Adoption guidance: Expect a phased rollout: design doc review, doc stubs under <code>docs/extensions/</code>, sample scaffolding under <code>samples/</code>, then code with tests. Early adopters can start by reading the HighLevelDocs entry and sketching how CleanArchitecture.Extensions.NuGetPackaging would plug into their pipelines. We will ship SourceLink, XML docs, symbols, and a README with concrete install/usage guidance just like Core and Validation.</p> <p>Interoperability patterns: CleanArchitecture.Extensions.NuGetPackaging will be deliberate about compatibility with other extensions. We will highlight safe ordering in the MediatR pipeline, how to mix with multitenancy (when applicable), and what to do when pairing with Observability or Caching. For teams migrating from the baseline template, we will document shims or adapters so you do not have to rewrite working code to adopt this module.</p> <p>Monitoring and reliability: Behaviors and adapters will emit correlation-aware logs and, when relevant, metrics that feed Observability once it ships. Failure modes will be documented with mitigations and configuration toggles. Expect guidance on defaults vs production hardening, plus testing tips using fakes or in-memory providers.</p>"},{"location":"samples/","title":"Samples","text":"<p>Runnable samples to demonstrate extensions in real projects.</p> <ul> <li>Located under samples/ in the repo.</li> <li>Each sample should include setup instructions and expected output.</li> <li>Use scripts to reset/run samples for consistent results.</li> </ul>"},{"location":"samples/#planned-samples","title":"Planned samples","text":"<ul> <li>Minimal API with one extension enabled.</li> <li>Multitenant API with tenant resolution strategies.</li> <li>Observability-enabled API (metrics/tracing/logging) once adapters are added.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and fixes (expand as features land).</p> <ul> <li>Extension fails to start: enable debug logs and check config keys.</li> <li>Tenant not resolved: verify provider order (host/header/route/claims) and add logging for resolution steps.</li> <li>Caching mismatches: confirm cache keys include tenant/user when required.</li> </ul>"}]}