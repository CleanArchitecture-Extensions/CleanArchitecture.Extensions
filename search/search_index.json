{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CleanArchitecture.Extensions","text":"<p>CleanArchitecture.Extensions is a small set of opt-in NuGet packages that plug into Jason Taylor's Clean Architecture template without forking it.</p>"},{"location":"#what-ships-today","title":"What ships today","text":"<ul> <li><code>CleanArchitecture.Extensions.Caching</code></li> <li><code>CleanArchitecture.Extensions.Multitenancy</code></li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Caching:</p> <pre><code>dotnet add package CleanArchitecture.Extensions.Caching\n</code></pre> <pre><code>services.AddCleanArchitectureCaching();\nservices.AddMediatR(cfg =&gt; cfg.AddCleanArchitectureCachingPipeline());\n</code></pre> <p>Multitenancy:</p> <pre><code>dotnet add package CleanArchitecture.Extensions.Multitenancy\n</code></pre> <pre><code>services.AddCleanArchitectureMultitenancy();\nservices.AddMediatR(cfg =&gt; cfg.AddCleanArchitectureMultitenancyPipeline());\n</code></pre> <p>No other template changes required.</p>"},{"location":"#where-to-go-next","title":"Where to go next","text":"<ul> <li>Caching docs: extensions/caching.md</li> <li>Multitenancy docs: extensions/multitenancy-core.md</li> <li>Extensions catalog: extensions/index.md</li> <li>Roadmap: roadmap.md</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#shipped-preview","title":"Shipped (preview)","text":"<ul> <li>CleanArchitecture.Extensions.Caching \u2014 cache abstractions, adapters, and query caching behavior.</li> <li>Multitenancy Core \u2014 tenant model, resolution providers, enforcement behavior.</li> </ul>"},{"location":"roadmap/#next","title":"Next","text":"<ul> <li>Multitenancy adapters \u2014 EFCore, AspNetCore, Identity (planned).</li> <li>Caching adapters \u2014 Redis and other distributed stores (planned).</li> </ul>"},{"location":"concepts/architecture-fit/","title":"Architecture Fit","text":"<p>How extensions align with Jason Taylor's Clean Architecture template.</p> <ul> <li>Keep the template untouched: extensions plug in via packages, configuration, middleware/behaviors\u2014not by forking or editing the upstream template.</li> <li>Preserve boundaries: respect domain/application/infrastructure/UI separation and dependency direction.</li> <li>Prefer composition: use pipeline behaviors, decorators, filters, and adapters instead of modifying core layers.</li> <li>Match conventions: mirror naming, folder structure, and coding style from the reference <code>JasonTaylorCleanArchitecture</code> copy.</li> <li>Stay optional: every extension should be opt-in with clear defaults and minimal required configuration.</li> </ul>"},{"location":"concepts/composition/","title":"Composition &amp; Invariants","text":"<p>Principles for combining extensions safely.</p> <ul> <li>Isolation: each extension should have clear dependencies and avoid implicit cross-talk.</li> <li>Pipelines first: prefer mediatr behaviors, filters, and decorators to hook in cross-cutting concerns.</li> <li>Config clarity: document required settings, defaults, and compat matrices; fail fast on invalid configs.</li> <li>Observability: emit structured logs/events for extension lifecycle (init, errors, important decisions).</li> <li>Compatibility: declare supported .NET versions and CleanArchitecture template versions per extension page.</li> <li>Exit strategy: provide guidance for disabling/removing an extension cleanly.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We keep the upstream Jason Taylor template pristine and ship everything as opt-in packages. Contributions must follow that contract and stay in sync with the docs and samples.</p>"},{"location":"contributing/#principles","title":"Principles","text":"<ul> <li>Template-first: mirror Jason Taylor\u2019s conventions (folder layout, naming, MediatR pipeline ordering). Do not modify <code>JasonTaylorCleanArchitecture/</code>.</li> <li>Extension = opt-in: minimal required config, no surprises; keep dependencies light.</li> <li>Docs/samples-first: every behavior change lands with updated docs under <code>docs/</code> and, where applicable, a sample under <code>samples/</code>.</li> <li>Tests-close-to-code: add/adjust tests in <code>tests/</code> for the package you touch.</li> </ul>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Pick the design doc: read the matching <code>HighLevelDocs/Domain*/CleanArchitecture.Extensions.*.md</code> before coding.</li> <li>Branch in this repo; keep changes inside <code>CleanArchitecture.Extensions/</code> solution (src/tests/samples/docs/build).</li> <li>Implement + test: add or update unit/integration tests for your changes.</li> <li>Update docs: extension page, recipes, reference, and roadmap if scope changes. Keep nav links valid.</li> <li>Preview docs locally (optional): <pre><code>python -m venv .venv\n. .venv/Scripts/Activate.ps1\npip install -r docs/requirements.txt\nmkdocs serve\n</code></pre></li> <li>Run relevant samples/tests where applicable and note any manual steps in your PR description.</li> </ol>"},{"location":"contributing/#style-docs","title":"Style (docs)","text":"<ul> <li>Follow the documentation strategy templates (overview \u2192 when to use \u2192 compat \u2192 install \u2192 usage \u2192 troubleshooting \u2192 samples/tests).</li> <li>Use fenced code blocks with language tags (<code>bash</code>, <code>powershell</code>, <code>csharp</code>, <code>json</code>).</li> <li>Prefer snippets from source to avoid drift; keep examples short and runnable.</li> <li>Keep compatibility info current (template version, target frameworks, dependencies).</li> </ul>"},{"location":"extensions/","title":"Extensions Catalog","text":"<p>A small catalog of opt-in extensions designed to plug into Jason Taylor's Clean Architecture template without forking it.</p>"},{"location":"extensions/#shipped","title":"Shipped","text":"<ul> <li>CleanArchitecture.Extensions.Caching \u2014 cache abstractions plus query caching behavior: Caching</li> <li>CleanArchitecture.Extensions.Multitenancy \u2014 tenant resolution and enforcement primitives: Multitenancy Core</li> </ul>"},{"location":"extensions/#planned","title":"Planned","text":"<ul> <li>Additional modules and adapters (EFCore, Identity, Redis, Storage, Sharding).</li> </ul>"},{"location":"extensions/caching/","title":"Extension: Caching","text":""},{"location":"extensions/caching/#overview","title":"Overview","text":"<p>Cache abstractions, key conventions, and a MediatR query caching behavior for Clean Architecture applications. Ships memory and distributed adapters, deterministic key generation, and options for stampede protection and TTL tuning without leaking infrastructure into handlers.</p>"},{"location":"extensions/caching/#when-to-use","title":"When to use","text":"<ul> <li>You want query read-through caching without embedding cache calls in handlers.</li> <li>You need deterministic, namespace/tenant-aware cache keys and provider-agnostic entry options.</li> <li>You plan to start with in-memory caching for dev/test and swap to distributed stores (Redis via <code>IDistributedCache</code>) later.</li> </ul>"},{"location":"extensions/caching/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target frameworks: <code>net10.0</code>.</li> <li>Dependencies: MediatR <code>13.1.0</code>, <code>Microsoft.Extensions.Caching.Abstractions</code>, <code>Microsoft.Extensions.Caching.Memory</code> (defaults); distributed adapter uses <code>IDistributedCache</code> (MemoryDistributedCache by default).</li> <li>Pipeline fit: register <code>QueryCachingBehavior&lt;,&gt;</code> after authorization and request checks, and before performance logging to avoid skewing timing warnings.</li> </ul>"},{"location":"extensions/caching/#install","title":"Install","text":"<pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"extensions/caching/#usage","title":"Usage","text":""},{"location":"extensions/caching/#register-caching-and-pipeline-behavior","title":"Register caching and pipeline behavior","text":"<pre><code>using CleanArchitecture.Extensions.Caching;\nusing CleanArchitecture.Extensions.Caching.Options;\nusing MediatR;\n\nservices.AddCleanArchitectureCaching(options =&gt;\n{\n    options.DefaultNamespace = \"MyApp\";\n    options.MaxEntrySizeBytes = 256 * 1024; // optional\n}, queryOptions =&gt;\n{\n    queryOptions.DefaultTtl = TimeSpan.FromMinutes(5);\n    // Default predicate caches types whose names end with \"Query\"; override to use a marker instead:\n    // queryOptions.CachePredicate = req =&gt; req is IQueryMarker;\n});\n\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCachingPipeline(); // place after request checks\n});\n</code></pre>"},{"location":"extensions/caching/#configure-cache-keys-and-ttls","title":"Configure cache keys and TTLs","text":"<ul> <li>Keys follow <code>{namespace}:{tenant?}:{resource}:{hash}</code> via <code>ICacheKeyFactory</code> and <code>ICacheScope</code>. Override <code>ResourceNameSelector</code>/<code>HashFactory</code> in <code>QueryCachingBehaviorOptions</code> for custom resource naming or hashing (e.g., when parameters should be normalized).</li> <li>Default TTL comes from <code>QueryCachingBehaviorOptions.DefaultTtl</code>; override per request type with <code>TtlByRequestType[typeof(MyQuery)] = TimeSpan.FromSeconds(30);</code>.</li> <li><code>CachePredicate</code> controls which requests are cacheable. By default it caches request types whose names end with \"Query\"; override to use markers or explicit type checks. <code>ResponseCachePredicate</code> can skip caching for responses you do not want stored.</li> </ul>"},{"location":"extensions/caching/#choose-an-adapter","title":"Choose an adapter","text":"<ul> <li>Memory (default): registered as <code>ICache</code> by <code>AddCleanArchitectureCaching</code>, uses <code>MemoryCacheAdapter</code> with stampede locking and jitter.</li> <li>Distributed: resolve <code>DistributedCacheAdapter</code> or replace <code>ICache</code> registration:</li> </ul> <pre><code>services.AddCleanArchitectureCaching();\nservices.AddStackExchangeRedisCache(opts =&gt; opts.Configuration = \"...\"); // or other IDistributedCache\nservices.AddSingleton&lt;ICache, DistributedCacheAdapter&gt;(); // override default\n</code></pre>"},{"location":"extensions/caching/#entry-options-and-stampede-settings","title":"Entry options and stampede settings","text":"<ul> <li><code>CachingOptions.DefaultEntryOptions</code> sets absolute/sliding expiration, priority, and size hints.</li> <li><code>CachingOptions.StampedePolicy</code> controls locking timeout and jitter for both adapters.</li> <li><code>CacheEntryOptions</code> can be passed per call or mapped by request type inside the behavior.</li> </ul>"},{"location":"extensions/caching/#response-aware-caching","title":"Response-aware caching","text":"<p>Use <code>QueryCachingBehaviorOptions.ResponseCachePredicate</code> to skip caching responses you want to exclude (for example, error payloads or partial results).</p>"},{"location":"extensions/caching/#key-components","title":"Key components","text":"<ul> <li><code>ICache</code>, <code>CacheEntryOptions</code>, <code>CacheStampedePolicy</code>, <code>CacheKey</code>, <code>ICacheKeyFactory</code>, <code>ICacheScope</code>, <code>ICacheSerializer</code>.</li> <li><code>MemoryCacheAdapter</code>, <code>DistributedCacheAdapter</code> (for <code>IDistributedCache</code>).</li> <li><code>QueryCachingBehavior&lt;TRequest,TResponse&gt;</code> with configurable TTLs, hash selection, predicate, and response filtering.</li> </ul>"},{"location":"extensions/caching/#pipeline-ordering","title":"Pipeline ordering","text":"<ul> <li>Recommended: Authorization \u2192 Request checks \u2192 QueryCachingBehavior \u2192 Performance/Logging \u2192 Handlers (align with the template order you already use).</li> <li>Place caching after request checks to avoid caching invalid requests and before performance logging to exclude cache hits from handler timing warnings.</li> </ul>"},{"location":"extensions/caching/#invalidation-guidance","title":"Invalidation guidance","text":"<ul> <li>Cache-aside pattern: explicit <code>ICache.Remove</code> or <code>ICache.RemoveAsync</code> on command success or domain event handlers.</li> <li>Include versioning and tenant segments in keys to avoid collisions; adjust namespace when making breaking DTO changes.</li> </ul>"},{"location":"extensions/caching/#backlog-next-iteration","title":"Backlog / Next Iteration","text":"<ul> <li>Add PII/classification guardrails so sensitive payloads can be blocked or redirected to encrypted storage.</li> <li>Provide an optional encrypting serializer wrapper for distributed caches with guidance for key management.</li> <li>Expose instrumentation hooks (hits, misses, latency) without forcing a specific metrics provider.</li> <li>Document and/or implement schema-versioned key strategies to support DTO shape changes safely.</li> </ul>"},{"location":"extensions/caching/#testing","title":"Testing","text":"<ul> <li>Use the default memory adapter for Application tests; distributed adapter can use <code>MemoryDistributedCache</code> for deterministic runs.</li> </ul>"},{"location":"extensions/multitenancy-core/","title":"Extension: Multitenancy Core","text":""},{"location":"extensions/multitenancy-core/#overview","title":"Overview","text":"<p>Host-agnostic multitenancy primitives for Clean Architecture solutions. The core package defines tenant identity, resolution pipeline, current-tenant access, validation hooks, and MediatR behaviors without requiring ASP.NET Core or EF Core. You bring the host adapter that populates a <code>TenantResolutionContext</code>.</p>"},{"location":"extensions/multitenancy-core/#when-to-use","title":"When to use","text":"<ul> <li>You need per-tenant isolation (data access, caching, authorization, logging).</li> <li>You want pluggable tenant resolution strategies (host/header/route/claims).</li> <li>You want pipeline-level tenant enforcement without sprinkling tenant checks across handlers.</li> </ul>"},{"location":"extensions/multitenancy-core/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target frameworks: <code>net10.0</code>.</li> <li>Dependencies: MediatR <code>13.1.0</code>, Microsoft.Extensions.* (<code>DependencyInjection</code>, <code>Logging</code>, <code>Options</code>).</li> <li>Host adapter required: build <code>TenantResolutionContext</code> in your web/API/worker host.</li> </ul>"},{"location":"extensions/multitenancy-core/#install","title":"Install","text":"<pre><code>dotnet add src/Application/Application.csproj package CleanArchitecture.Extensions.Multitenancy\ndotnet add src/Infrastructure/Infrastructure.csproj package CleanArchitecture.Extensions.Multitenancy\n</code></pre>"},{"location":"extensions/multitenancy-core/#quickstart","title":"Quickstart","text":""},{"location":"extensions/multitenancy-core/#register-services","title":"Register services","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nservices.AddCleanArchitectureMultitenancy(options =&gt;\n{\n    options.HeaderNames = new[] { \"X-Tenant-ID\" };\n    options.RouteParameterName = \"tenantId\";\n    options.QueryParameterName = \"tenantId\";\n    options.ClaimType = \"tenant_id\";\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/#resolve-and-set-tenant-context-host-adapter","title":"Resolve and set tenant context (host adapter)","text":"<p>Minimal ASP.NET Core middleware example:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantResolutionMiddleware\n{\n    private readonly RequestDelegate _next;\n\n    public TenantResolutionMiddleware(RequestDelegate next) =&gt; _next = next;\n\n    public async Task InvokeAsync(HttpContext httpContext, ITenantResolver resolver, ITenantAccessor accessor)\n    {\n        var context = new TenantResolutionContext\n        {\n            Host = httpContext.Request.Host.Host,\n            CorrelationId = httpContext.TraceIdentifier\n        };\n\n        foreach (var header in httpContext.Request.Headers)\n        {\n            context.Headers[header.Key] = header.Value.ToString();\n        }\n\n        foreach (var route in httpContext.Request.RouteValues)\n        {\n            if (route.Value is not null)\n            {\n                context.RouteValues[route.Key] = route.Value.ToString()!;\n            }\n        }\n\n        foreach (var query in httpContext.Request.Query)\n        {\n            context.Query[query.Key] = query.Value.ToString();\n        }\n\n        if (httpContext.User?.Identity?.IsAuthenticated == true)\n        {\n            foreach (var claim in httpContext.User.Claims)\n            {\n                context.Claims[claim.Type] = claim.Value;\n            }\n        }\n\n        var tenantContext = await resolver.ResolveAsync(context, httpContext.RequestAborted);\n        using (accessor.BeginScope(tenantContext))\n        {\n            await _next(httpContext);\n        }\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/#add-pipeline-behaviors","title":"Add pipeline behaviors","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.Behaviors;\nusing MediatR;\n\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureMultitenancyPipeline();\n    cfg.AddOpenBehavior(typeof(TenantScopedCacheBehavior&lt;,&gt;)); // optional\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/#how-it-works","title":"How it works","text":"<pre><code>sequenceDiagram\n  participant Host\n  participant Resolver\n  participant Providers\n  participant Accessor\n  Host-&gt;&gt;Resolver: TenantResolutionContext\n  Resolver-&gt;&gt;Providers: evaluate providers in order\n  Providers--&gt;&gt;Resolver: TenantResolutionResult\n  Resolver--&gt;&gt;Accessor: TenantContext (validated)\n  Accessor--&gt;&gt;Host: AsyncLocal current tenant\n</code></pre> <ul> <li>Providers return <code>TenantResolutionResult</code> with candidates and confidence.</li> <li>The resolver validates against cache/store if configured.</li> <li>MediatR behaviors enforce tenant requirements and enrich logging scope.</li> </ul>"},{"location":"extensions/multitenancy-core/#key-components","title":"Key components","text":"<ul> <li><code>TenantInfo</code>, <code>TenantContext</code>, <code>TenantResolutionContext</code>, <code>TenantResolutionResult</code>.</li> <li>Providers: route, host, header, query string, claim, default, custom delegate.</li> <li>Behaviors: validation, enforcement, correlation, cache scope warning.</li> <li><code>ITenantInfoStore</code>, <code>ITenantInfoCache</code>, <code>ITenantContextSerializer</code>.</li> </ul>"},{"location":"extensions/multitenancy-core/#security-and-operational-notes","title":"Security and operational notes","text":"<ul> <li>Enable validation (<code>TenantValidationMode.Cache</code> or <code>Repository</code>) to prevent spoofed tenant IDs.</li> <li>Use <code>RequireMatchAcrossSources</code> to enforce consensus across header/route/host claims.</li> <li>Configure <code>HostTenantSelector</code> if subdomain parsing rules differ.</li> <li>Background jobs should always restore tenant context via <code>ITenantAccessor.BeginScope</code>.</li> </ul>"},{"location":"extensions/multitenancy-core/#deep-dive-pages","title":"Deep dive pages","text":"<ul> <li>Resolution pipeline: <code>multitenancy-core/resolution-pipeline.md</code></li> <li>Requirements and behaviors: <code>multitenancy-core/requirements-and-behaviors.md</code></li> <li>Validation and stores: <code>multitenancy-core/validation-and-stores.md</code></li> <li>Context propagation: <code>multitenancy-core/context-propagation.md</code></li> <li>Caching integration: <code>multitenancy-core/caching-integration.md</code></li> <li>Options reference: <code>../reference/multitenancy-options.md</code></li> <li>Troubleshooting: <code>../troubleshooting/multitenancy.md</code></li> </ul>"},{"location":"extensions/multitenancy-core/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Tenant not resolved: confirm provider order and ensure <code>TenantResolutionContext</code> is populated.</li> <li>Validation warnings: register <code>ITenantInfoStore</code>/<code>ITenantInfoCache</code> when using cache/repository validation.</li> <li>Ambiguous candidates: ensure headers/queries contain only one tenant ID.</li> </ul>"},{"location":"extensions/multitenancy-core/#roadmap-planned-adapters","title":"Roadmap (planned adapters)","text":"<ul> <li>Multitenancy.AspNetCore</li> <li>Multitenancy.EFCore</li> <li>Multitenancy.Identity</li> <li>Multitenancy.Provisioning</li> <li>Multitenancy.Redis</li> <li>Multitenancy.Sharding</li> <li>Multitenancy.Storage</li> </ul>"},{"location":"extensions/multitenancy-core/caching-integration/","title":"Multitenancy Core: Caching integration","text":"<p>Use the caching integration to ensure cache keys include tenant context.</p>"},{"location":"extensions/multitenancy-core/caching-integration/#setup","title":"Setup","text":"<p>1) Register caching services. 2) Replace the cache scope with <code>TenantCacheScope</code>. 3) (Optional) add <code>TenantScopedCacheBehavior</code> to warn about mismatches.</p> <pre><code>using CleanArchitecture.Extensions.Caching;\nusing CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Behaviors;\nusing MediatR;\n\nservices.AddCleanArchitectureCaching();\nservices.AddCleanArchitectureMultitenancyCaching();\n\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddOpenBehavior(typeof(TenantScopedCacheBehavior&lt;,&gt;));\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/caching-integration/#what-changes","title":"What changes","text":"<ul> <li><code>TenantCacheScope</code> replaces <code>ICacheScope</code> and includes <code>TenantId</code> in generated keys.</li> <li>Cache key shape remains <code>{namespace}:{tenant}:{resource}:{hash}</code> as defined by the caching module.</li> </ul>"},{"location":"extensions/multitenancy-core/caching-integration/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you see \"Cache scope tenant mismatch\" warnings, ensure <code>ITenantAccessor</code> is set before caching behaviors run.</li> <li><code>AddCleanArchitectureMultitenancyCaching</code> throws if caching services are not registered first.</li> </ul>"},{"location":"extensions/multitenancy-core/context-propagation/","title":"Multitenancy Core: Context propagation","text":"<p>Tenant context is stored in <code>AsyncLocal</code> via <code>CurrentTenantAccessor</code>. This page shows how to set and propagate tenant context safely.</p>"},{"location":"extensions/multitenancy-core/context-propagation/#beginscope-for-background-work","title":"BeginScope for background work","text":"<p>Use <code>ITenantAccessor.BeginScope</code> to ensure the previous context is restored:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantJob\n{\n    private readonly ITenantAccessor _accessor;\n\n    public TenantJob(ITenantAccessor accessor)\n    {\n        _accessor = accessor;\n    }\n\n    public Task ExecuteAsync(string tenantId, CancellationToken cancellationToken)\n    {\n        var tenant = new TenantInfo(tenantId);\n        var resolution = TenantResolutionResult.Resolved(tenantId, TenantResolutionSource.Custom);\n        using var scope = _accessor.BeginScope(new TenantContext(tenant, resolution));\n\n        // perform tenant-bound work\n        return Task.CompletedTask;\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/context-propagation/#serialize-context-for-jobs-and-messages","title":"Serialize context for jobs and messages","text":"<p><code>ITenantContextSerializer</code> lets you store the full context in job metadata or message headers:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantMessagePublisher\n{\n    private readonly ITenantContextSerializer _serializer;\n    private readonly ICurrentTenant _currentTenant;\n\n    public TenantMessagePublisher(ITenantContextSerializer serializer, ICurrentTenant currentTenant)\n    {\n        _serializer = serializer;\n        _currentTenant = currentTenant;\n    }\n\n    public string CreateHeader()\n    {\n        var context = _currentTenant.Context;\n        return context is null ? string.Empty : _serializer.Serialize(context);\n    }\n}\n</code></pre> <p>On the consumer side:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class TenantMessageHandler\n{\n    private readonly ITenantAccessor _accessor;\n    private readonly ITenantContextSerializer _serializer;\n\n    public TenantMessageHandler(ITenantAccessor accessor, ITenantContextSerializer serializer)\n    {\n        _accessor = accessor;\n        _serializer = serializer;\n    }\n\n    public Task HandleAsync(string header)\n    {\n        var context = string.IsNullOrWhiteSpace(header) ? null : _serializer.Deserialize(header);\n        using var scope = _accessor.BeginScope(context);\n\n        // handle message\n        return Task.CompletedTask;\n    }\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/context-propagation/#asynclocal-guidance","title":"AsyncLocal guidance","text":"<ul> <li>Always wrap work in <code>BeginScope</code> so contexts are restored.</li> <li>Avoid storing <code>TenantContext</code> in static fields.</li> <li>Restore context in background workers and message handlers explicitly.</li> </ul>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/","title":"Multitenancy Core: Requirements and behaviors","text":"<p>This page documents how tenant requirements are expressed and how pipeline behaviors enforce them.</p>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#tenant-requirements","title":"Tenant requirements","text":"<p>A request or endpoint can declare its requirement in two ways:</p> <p>1) Implement <code>ITenantRequirement</code> on the request type. 2) Apply <code>RequiresTenantAttribute</code> or <code>AllowHostRequestsAttribute</code> on the request or endpoint.</p> <p>Example request-level requirement:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\nusing MediatR;\n\npublic sealed record GetBillingSummaryQuery() : IRequest&lt;string&gt;, ITenantRequirement\n{\n    public TenantRequirementMode Requirement =&gt; TenantRequirementMode.Required;\n}\n</code></pre> <p>Optional host-level request:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing MediatR;\n\n[AllowHostRequests]\npublic sealed record GetHealthQuery() : IRequest&lt;string&gt;;\n</code></pre> <p>If no requirement is specified, the system falls back to: - <code>MultitenancyOptions.RequireTenantByDefault</code> (default true) - <code>MultitenancyOptions.AllowAnonymous</code></p>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#pipeline-behaviors","title":"Pipeline behaviors","text":"<p>The core package includes the following MediatR behaviors:</p> <ul> <li><code>TenantValidationBehavior</code> - validates tenant metadata against cache/store.</li> <li><code>TenantEnforcementBehavior</code> - enforces resolution and tenant lifecycle checks.</li> <li><code>TenantCorrelationBehavior</code> - adds tenant ID to logging scope and activity baggage.</li> <li><code>TenantScopedCacheBehavior</code> - warns when cache scope is missing tenant context.</li> </ul> <p>Register them using the extension method:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Behaviors;\nusing MediatR;\n\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n\n    // Template behaviors...\n    // cfg.AddOpenBehavior(typeof(AuthorizationBehaviour&lt;,&gt;));\n    // cfg.AddOpenBehavior(typeof(ValidationBehaviour&lt;,&gt;));\n\n    cfg.AddCleanArchitectureMultitenancyPipeline();\n    cfg.AddOpenBehavior(typeof(TenantScopedCacheBehavior&lt;,&gt;)); // optional\n});\n</code></pre> <p>Place the call near your other request checks so tenant enforcement happens before the handler executes.</p>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#enforcement-rules","title":"Enforcement rules","text":"<p><code>TenantEnforcementBehavior</code> throws when:</p> <ul> <li>No tenant is resolved (<code>TenantNotResolvedException</code>).</li> <li>Tenant is not validated (<code>TenantNotFoundException</code>).</li> <li>Tenant is suspended (<code>TenantSuspendedException</code>).</li> <li>Tenant is inactive, soft-deleted, pending provisioning, deleted, or expired (<code>TenantInactiveException</code>).</li> </ul> <p>If you need to bypass enforcement for specific endpoints, apply <code>AllowHostRequestsAttribute</code> or return <code>TenantRequirementMode.Optional</code>.</p>"},{"location":"extensions/multitenancy-core/requirements-and-behaviors/#optional-map-exceptions-to-http-responses","title":"Optional: map exceptions to HTTP responses","text":"<p>In ASP.NET Core, map tenant exceptions to HTTP status codes:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Exceptions;\nusing Microsoft.AspNetCore.Diagnostics;\nusing Microsoft.AspNetCore.Http;\n\napp.UseExceptionHandler(handler =&gt;\n{\n    handler.Run(async context =&gt;\n    {\n        var feature = context.Features.Get&lt;IExceptionHandlerFeature&gt;();\n        var status = feature?.Error switch\n        {\n            TenantNotResolvedException =&gt; StatusCodes.Status400BadRequest,\n            TenantNotFoundException =&gt; StatusCodes.Status404NotFound,\n            TenantSuspendedException =&gt; StatusCodes.Status403Forbidden,\n            TenantInactiveException =&gt; StatusCodes.Status403Forbidden,\n            _ =&gt; StatusCodes.Status500InternalServerError\n        };\n\n        context.Response.StatusCode = status;\n        await context.Response.WriteAsync(\"Tenant error.\");\n    });\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/resolution-pipeline/","title":"Multitenancy Core: Resolution pipeline","text":"<p>This page explains how tenant resolution works and how to customize provider order and consensus rules.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#resolution-inputs","title":"Resolution inputs","text":"<p>Tenant resolution is driven by <code>TenantResolutionContext</code>, which is populated by your host:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\n\nvar context = new TenantResolutionContext\n{\n    Host = httpContext.Request.Host.Host,\n    CorrelationId = httpContext.TraceIdentifier\n};\n\nforeach (var header in httpContext.Request.Headers)\n{\n    context.Headers[header.Key] = header.Value.ToString();\n}\n\nforeach (var route in httpContext.Request.RouteValues)\n{\n    if (route.Value is not null)\n    {\n        context.RouteValues[route.Key] = route.Value.ToString()!;\n    }\n}\n\nforeach (var query in httpContext.Request.Query)\n{\n    context.Query[query.Key] = query.Value.ToString();\n}\n\nforeach (var claim in httpContext.User.Claims)\n{\n    context.Claims[claim.Type] = claim.Value;\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#built-in-providers","title":"Built-in providers","text":"<p>The core package registers the following providers by default:</p> <ul> <li><code>RouteTenantProvider</code> - uses <code>RouteParameterName</code> and returns high confidence.</li> <li><code>HostTenantProvider</code> - uses <code>HostTenantSelector</code> (defaults to first subdomain).</li> <li><code>HeaderTenantProvider</code> - scans <code>HeaderNames</code>.</li> <li><code>QueryTenantProvider</code> - uses <code>QueryParameterName</code>.</li> <li><code>ClaimTenantProvider</code> - uses <code>ClaimType</code>.</li> <li><code>DefaultTenantProvider</code> - uses <code>FallbackTenant</code> / <code>FallbackTenantId</code>.</li> </ul> <p>Header/query/claim values can contain multiple candidates separated by <code>,</code> or <code>;</code>. Multiple candidates are treated as ambiguous and will not resolve a tenant.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#ordering-and-consensus","title":"Ordering and consensus","text":"<p>Resolution order is driven by <code>MultitenancyOptions.ResolutionOrder</code>:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nservices.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.ResolutionOrder = new List&lt;TenantResolutionSource&gt;\n    {\n        TenantResolutionSource.Route,\n        TenantResolutionSource.Host,\n        TenantResolutionSource.Header,\n        TenantResolutionSource.QueryString,\n        TenantResolutionSource.Claim,\n        TenantResolutionSource.Default\n    };\n});\n</code></pre> <p>If <code>RequireMatchAcrossSources</code> is enabled, the strategy collects candidates from all providers and resolves only when there is exactly one unique candidate:</p> <pre><code>services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.RequireMatchAcrossSources = true;\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#host-parsing-rules","title":"Host parsing rules","text":"<p>By default, the host provider uses the first subdomain:</p> <ul> <li><code>tenant.app.com</code> -&gt; <code>tenant</code></li> <li><code>localhost</code> -&gt; not resolved</li> <li>IP addresses -&gt; not resolved</li> </ul> <p>Override with a custom selector when needed:</p> <pre><code>services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.HostTenantSelector = host =&gt;\n    {\n        if (host.EndsWith(\".internal\", StringComparison.OrdinalIgnoreCase))\n        {\n            return \"internal\";\n        }\n\n        return host.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n            .FirstOrDefault();\n    };\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#custom-providers","title":"Custom providers","text":"<p>You can add custom providers for environment-specific resolution:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\nusing CleanArchitecture.Extensions.Multitenancy.Providers;\n\nservices.AddSingleton&lt;ITenantProvider&gt;(\n    new DelegateTenantProvider(context =&gt;\n    {\n        if (context.Items.TryGetValue(\"tenant_override\", out var value))\n        {\n            return value?.ToString();\n        }\n\n        return null;\n    }, source: TenantResolutionSource.Custom, confidence: TenantResolutionConfidence.High));\n</code></pre> <p>Custom providers not listed in <code>ResolutionOrder</code> are still evaluated when <code>IncludeUnorderedProviders</code> is true (default).</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#timeouts-and-cancellation","title":"Timeouts and cancellation","text":"<p>Set <code>ResolutionTimeout</code> to guard against slow providers:</p> <pre><code>services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.ResolutionTimeout = TimeSpan.FromMilliseconds(50);\n});\n</code></pre> <p>The composite strategy links this timeout with the request cancellation token.</p>"},{"location":"extensions/multitenancy-core/resolution-pipeline/#diagnostics-tips","title":"Diagnostics tips","text":"<ul> <li>Log <code>TenantResolutionResult.Source</code>, <code>Confidence</code>, and <code>Candidates</code> for debugging.</li> <li>Ambiguous candidates result in no resolved tenant; tighten your sources or enable consensus.</li> </ul>"},{"location":"extensions/multitenancy-core/validation-and-stores/","title":"Multitenancy Core: Validation and stores","text":"<p>This page explains validation modes and how to plug in tenant metadata stores and caches.</p>"},{"location":"extensions/multitenancy-core/validation-and-stores/#validation-modes","title":"Validation modes","text":"<p><code>MultitenancyOptions.ValidationMode</code> controls how tenant IDs are validated:</p> <ul> <li><code>None</code> (default): no lookup; the resolver creates a minimal active <code>TenantInfo</code>.</li> <li><code>Cache</code>: validate only via <code>ITenantInfoCache</code>.</li> <li><code>Repository</code>: validate via <code>ITenantInfoStore</code> and optionally cache results.</li> </ul> <p>If a required cache/store is not registered, the system logs a warning and leaves the tenant as unvalidated. <code>TenantEnforcementBehavior</code> then throws <code>TenantNotFoundException</code> when a tenant is required.</p>"},{"location":"extensions/multitenancy-core/validation-and-stores/#implementing-a-store","title":"Implementing a store","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class InMemoryTenantStore : ITenantInfoStore\n{\n    private readonly Dictionary&lt;string, ITenantInfo&gt; _tenants =\n        new(StringComparer.OrdinalIgnoreCase)\n        {\n            [\"alpha\"] = new TenantInfo(\"alpha\") { Name = \"Alpha\", IsActive = true },\n            [\"beta\"] = new TenantInfo(\"beta\") { Name = \"Beta\", IsActive = true }\n        };\n\n    public Task&lt;ITenantInfo?&gt; FindByIdAsync(string tenantId, CancellationToken cancellationToken = default)\n        =&gt; Task.FromResult(_tenants.TryGetValue(tenantId, out var tenant) ? tenant : null);\n}\n</code></pre>"},{"location":"extensions/multitenancy-core/validation-and-stores/#implementing-a-cache","title":"Implementing a cache","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy.Abstractions;\n\npublic sealed class InMemoryTenantCache : ITenantInfoCache\n{\n    private readonly Dictionary&lt;string, ITenantInfo&gt; _cache = new(StringComparer.OrdinalIgnoreCase);\n\n    public Task&lt;ITenantInfo?&gt; GetAsync(string tenantId, CancellationToken cancellationToken = default)\n        =&gt; Task.FromResult(_cache.TryGetValue(tenantId, out var tenant) ? tenant : null);\n\n    public Task SetAsync(ITenantInfo tenant, TimeSpan? ttl, CancellationToken cancellationToken = default)\n    {\n        _cache[tenant.TenantId] = tenant;\n        return Task.CompletedTask;\n    }\n}\n</code></pre> <p>Register the store/cache in DI and enable validation:</p> <pre><code>using CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nservices.AddSingleton&lt;ITenantInfoStore, InMemoryTenantStore&gt;();\nservices.AddSingleton&lt;ITenantInfoCache, InMemoryTenantCache&gt;();\n\nservices.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.ValidationMode = TenantValidationMode.Repository;\n    options.ResolutionCacheTtl = TimeSpan.FromMinutes(10);\n});\n</code></pre>"},{"location":"extensions/multitenancy-core/validation-and-stores/#fallback-tenant","title":"Fallback tenant","text":"<p>The default provider can return a fallback tenant if configured:</p> <pre><code>services.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.FallbackTenantId = \"local\";\n});\n</code></pre> <p>Fallbacks are only used when the <code>DefaultTenantProvider</code> runs (source <code>Default</code>).</p>"},{"location":"extensions/multitenancy-core/validation-and-stores/#lifecycle-checks","title":"Lifecycle checks","text":"<p><code>TenantEnforcementBehavior</code> treats a tenant as invalid when:</p> <ul> <li><code>IsActive</code> is false</li> <li><code>IsSoftDeleted</code> is true</li> <li><code>State</code> is <code>Suspended</code>, <code>PendingProvision</code>, or <code>Deleted</code></li> <li><code>ExpiresAt</code> has passed</li> </ul> <p>Populate these fields in your <code>ITenantInfoStore</code> so enforcement works as expected.</p>"},{"location":"getting-started/adoption-playbooks/","title":"Adoption playbooks","text":""},{"location":"getting-started/adoption-playbooks/#caching-first-adoption","title":"Caching-first adoption","text":"<p>Use caching for read-heavy queries and expensive lookups.</p> <p>How to get started:</p> <ul> <li>Identify queries with high read frequency or expensive IO.</li> <li>Add the caching behavior and set a response predicate for what to cache.</li> <li>Add invalidation on command success or relevant domain events.</li> </ul> <p>Success signals:</p> <ul> <li>Cache hit ratio climbs without stale data incidents.</li> <li>Latency for cached queries drops measurably.</li> <li>Cache keys are consistent and easy to reason about.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#saas-with-tenant-isolation-planned","title":"SaaS with tenant isolation (planned)","text":"<p>Plan for Multitenancy Core so tenant context is available to caches, storage, and APIs.</p> <p>How to get started:</p> <ul> <li>Define tenant resolution rules (header, route, host, claims).</li> <li>Decide where tenant enforcement should occur (middleware, behaviors).</li> <li>Ensure cache keys include tenant identifiers.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#event-driven-integration-planned","title":"Event-driven integration (planned)","text":"<p>Keep caches consistent when integration events flow between services.</p> <p>How to get started:</p> <ul> <li>Use events to trigger cache invalidation.</li> <li>Track keys or tags so invalidation stays targeted.</li> <li>Keep cross-service cache coupling minimal and explicit.</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#install","title":"Install","text":"<pre><code>dotnet add package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"getting-started/installation/#register","title":"Register","text":"<pre><code>services.AddCleanArchitectureCaching();\nservices.AddMediatR(cfg =&gt; cfg.AddCleanArchitectureCachingPipeline());\n</code></pre> <p>If you do not want automatic query caching, skip <code>AddCleanArchitectureCachingPipeline()</code> and call <code>ICache</code> directly.</p>"},{"location":"getting-started/installation/#uninstall","title":"Uninstall","text":"<pre><code>dotnet remove package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Get caching into a template-based solution in a few minutes.</p> <ol> <li>Install the package:    <pre><code>dotnet add package CleanArchitecture.Extensions.Caching\n</code></pre></li> <li>Register caching and the MediatR pipeline behavior:    <pre><code>services.AddCleanArchitectureCaching();\nservices.AddMediatR(cfg =&gt; cfg.AddCleanArchitectureCachingPipeline());\n</code></pre></li> <li>Configure cache options (expiration, predicate) as needed.</li> <li>No other template changes required.</li> </ol> <p>Next: Caching docs.</p>"},{"location":"recipes/authentication/","title":"Recipe: Authentication","text":""},{"location":"recipes/authentication/#goal","title":"Goal","text":"<p>Wire authentication with extension-friendly hooks.</p>"},{"location":"recipes/authentication/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Auth provider chosen (e.g., JWT, IdentityServer) \u2014 placeholder until packages land.</li> </ul>"},{"location":"recipes/authentication/#steps","title":"Steps","text":"<ol> <li>Add the relevant authentication adapter package (TBD).</li> <li>Configure authentication in Program.cs (or equivalent) with provided helpers.</li> <li>Add middleware/filters for tenant-aware auth if needed.</li> </ol>"},{"location":"recipes/authentication/#verify","title":"Verify","text":"<ul> <li>Hitting a protected endpoint returns 200 with valid token; 401 otherwise.</li> </ul>"},{"location":"recipes/authentication/#pitfalls","title":"Pitfalls","text":"<ul> <li>Misaligned schemes between API and client; ensure defaults match.</li> <li>Ensure tenant resolution occurs before authz when multitenancy is enabled.</li> </ul>"},{"location":"recipes/caching/","title":"Recipe: Caching","text":""},{"location":"recipes/caching/#goal","title":"Goal","text":"<p>Add caching with clear cache key conventions and opt-in behaviors.</p>"},{"location":"recipes/caching/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Choose cache store (in-memory, distributed) \u2014 adapters TBD.</li> </ul>"},{"location":"recipes/caching/#steps","title":"Steps","text":"<ol> <li>Add the caching package: <code>dotnet add package CleanArchitecture.Extensions.Caching</code>.</li> <li>Register caching services and the query caching pipeline behavior (after request checks, before performance logging).</li> <li>Configure cacheability predicate and TTLs per query type; choose memory (default) or distributed adapter.</li> <li>Apply invalidation on command success/domain events where needed (<code>ICache.Remove</code>).</li> </ol>"},{"location":"recipes/caching/#verify","title":"Verify","text":"<ul> <li>First call hits data source; subsequent call hits cache (check logs or set a breakpoint).</li> <li>Change input parameters and confirm a different cache key/hash is used.</li> </ul>"},{"location":"recipes/caching/#pitfalls","title":"Pitfalls","text":"<ul> <li>Cache stampede: add locking or jitter where needed.</li> <li>Tenant-aware caching: ensure keys include tenant context when multitenancy is enabled.</li> <li>Avoid caching error or transient responses; use <code>ResponseCachePredicate</code> to skip them.</li> </ul>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>Configuration keys and environment variables for extensions.</p> <ul> <li>This section expands per extension as packages ship.</li> <li>Include defaults, required values, and sample appsettings snippets.</li> </ul>"},{"location":"reference/configuration/#available-references","title":"Available references","text":"<ul> <li>Multitenancy options: multitenancy-options.md</li> </ul>"},{"location":"reference/configuration/#placeholder-keys","title":"Placeholder keys","text":"<ul> <li>Extensions::Enabled <li>Extensions::Options (TBD per extension)"},{"location":"reference/multitenancy-options/","title":"Reference: Multitenancy options","text":"<p><code>MultitenancyOptions</code> configures tenant resolution, validation, and correlation.</p>"},{"location":"reference/multitenancy-options/#options","title":"Options","text":"Option Type Default Notes <code>RequireTenantByDefault</code> <code>bool</code> <code>true</code> Require a tenant unless overridden by a requirement. <code>AllowAnonymous</code> <code>bool</code> <code>false</code> Allow tenant-less requests when optional. <code>FallbackTenant</code> <code>TenantInfo?</code> <code>null</code> Full fallback tenant model. <code>FallbackTenantId</code> <code>string?</code> <code>null</code> Fallback tenant ID when no tenant is resolved. <code>ResolutionOrder</code> <code>List&lt;TenantResolutionSource&gt;</code> Route, Host, Header, QueryString, Claim, Default Provider evaluation order. <code>HeaderNames</code> <code>string[]</code> <code>[\"X-Tenant-ID\"]</code> Header names to inspect for tenant IDs. <code>ClaimType</code> <code>string</code> <code>\"tenant_id\"</code> Claim type for tenant ID. <code>RouteParameterName</code> <code>string</code> <code>\"tenantId\"</code> Route parameter name. <code>QueryParameterName</code> <code>string</code> <code>\"tenantId\"</code> Query parameter name. <code>ResolutionCacheTtl</code> <code>TimeSpan?</code> <code>00:05:00</code> TTL for tenant cache entries. <code>ResolutionTimeout</code> <code>TimeSpan?</code> <code>null</code> Timeout for resolution pipeline. <code>ValidationMode</code> <code>TenantValidationMode</code> <code>None</code> Validation strategy. <code>RequireMatchAcrossSources</code> <code>bool</code> <code>false</code> Require a single tenant match across all sources. <code>IncludeUnorderedProviders</code> <code>bool</code> <code>true</code> Evaluate providers not listed in <code>ResolutionOrder</code>. <code>AddTenantToLogScope</code> <code>bool</code> <code>true</code> Add tenant ID to log scope. <code>LogScopeKey</code> <code>string</code> <code>\"tenant_id\"</code> Log scope key name. <code>AddTenantToActivity</code> <code>bool</code> <code>true</code> Add tenant ID to activity tags/baggage. <code>HostTenantSelector</code> <code>Func&lt;string,string?&gt;?</code> <code>null</code> Custom host-to-tenant selector."},{"location":"reference/multitenancy-options/#tenantvalidationmode","title":"TenantValidationMode","text":"<ul> <li><code>None</code>: no validation; tenant is assumed active.</li> <li><code>Cache</code>: validate using <code>ITenantInfoCache</code> only.</li> <li><code>Repository</code>: validate using <code>ITenantInfoStore</code> (and cache if configured).</li> </ul>"},{"location":"reference/multitenancy-options/#tenantresolutionsource","title":"TenantResolutionSource","text":"<p><code>TenantResolutionSource</code> values include <code>Route</code>, <code>Host</code>, <code>Header</code>, <code>QueryString</code>, <code>Claim</code>, <code>Default</code>, <code>Custom</code>, and <code>Composite</code>.</p>"},{"location":"reference/multitenancy-options/#example-configuration","title":"Example configuration","text":"<pre><code>using CleanArchitecture.Extensions.Multitenancy;\nusing CleanArchitecture.Extensions.Multitenancy.Configuration;\n\nservices.Configure&lt;MultitenancyOptions&gt;(options =&gt;\n{\n    options.RequireTenantByDefault = true;\n    options.AllowAnonymous = false;\n    options.ValidationMode = TenantValidationMode.Repository;\n    options.ResolutionCacheTtl = TimeSpan.FromMinutes(5);\n    options.ResolutionOrder = new List&lt;TenantResolutionSource&gt;\n    {\n        TenantResolutionSource.Route,\n        TenantResolutionSource.Host,\n        TenantResolutionSource.Header,\n        TenantResolutionSource.QueryString,\n        TenantResolutionSource.Claim,\n        TenantResolutionSource.Default\n    };\n});\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":"<p>Changelog for CleanArchitecture.Extensions (latest-only for now).</p> <ul> <li>Add a section per release once packages ship.</li> <li>Call out breaking changes and migration steps.</li> </ul>"},{"location":"roadmap/package-blueprints/","title":"Package blueprints","text":""},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionscaching-shipped","title":"CleanArchitecture.Extensions.Caching (shipped)","text":"<p>What it provides:</p> <ul> <li>Cache abstractions with memory and distributed adapters.</li> <li>Query caching behavior for MediatR.</li> <li>Simple configuration for expiration and cache predicates.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain1-CoreArchitectureExtensions/CleanArchitecture.Extensions.Caching.md</li> <li>Docs: docs/extensions/caching.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancy-shipped","title":"CleanArchitecture.Extensions.Multitenancy (shipped)","text":"<p>What it provides:</p> <ul> <li>Tenant model and current tenant abstraction.</li> <li>Resolution providers (header, route, host, claims, default).</li> <li>Validation hooks (cache/store) and enforcement behaviors.</li> <li>Context serialization and cache scope integration.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.md</li> <li>Docs: docs/extensions/multitenancy-core.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyefcore-planned","title":"CleanArchitecture.Extensions.Multitenancy.EFCore (planned)","text":"<p>What it will provide:</p> <ul> <li>Tenant-aware DbContext helpers and filters.</li> <li>Patterns for shared and schema-per-tenant databases.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.EFCore.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyaspnetcore-planned","title":"CleanArchitecture.Extensions.Multitenancy.AspNetCore (planned)","text":"<p>What it will provide:</p> <ul> <li>Middleware and endpoint helpers for tenant resolution.</li> <li>Minimal API and controller integration points.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.AspNetCore.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyidentity-planned","title":"CleanArchitecture.Extensions.Multitenancy.Identity (planned)","text":"<p>What it will provide:</p> <ul> <li>Tenant-aware Identity helpers and policies.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.Identity.md</li> </ul>"},{"location":"samples/","title":"Samples","text":"<p>There are no runnable samples in the repo right now.</p> <p>Planned samples: - Caching query behavior with invalidation on command success. - Multitenancy core resolution (header/route) with enforcement.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and fixes (expand as features land).</p> <ul> <li>Extension fails to start: enable debug logs and check config keys.</li> <li>Tenant not resolved: verify provider order (host/header/route/claims) and add logging for resolution steps.</li> <li>Caching mismatches: confirm cache keys include tenant/user when required.</li> <li>Multitenancy deep dive: multitenancy.md</li> </ul>"},{"location":"troubleshooting/multitenancy/","title":"Troubleshooting: Multitenancy Core","text":"<p>Common multitenancy issues and fixes.</p>"},{"location":"troubleshooting/multitenancy/#tenantnotresolvedexception","title":"TenantNotResolvedException","text":"<p>Symptoms: - Requests fail with \"Tenant could not be resolved.\"</p> <p>Fixes: - Ensure your host adapter populates <code>TenantResolutionContext</code> before handlers run. - Verify <code>ResolutionOrder</code> includes the provider you expect (route/host/header/query/claim). - Check that your route parameter name, header names, or claim type match the incoming request.</p>"},{"location":"troubleshooting/multitenancy/#tenantnotfoundexception","title":"TenantNotFoundException","text":"<p>Symptoms: - Requests fail even though a tenant ID is present.</p> <p>Fixes: - Register <code>ITenantInfoStore</code> (and optionally <code>ITenantInfoCache</code>) when using <code>TenantValidationMode.Repository</code>. - Switch to <code>TenantValidationMode.None</code> temporarily to validate wiring. - Ensure the tenant exists in the store and is marked active.</p>"},{"location":"troubleshooting/multitenancy/#ambiguous-tenant-candidates","title":"Ambiguous tenant candidates","text":"<p>Symptoms: - Tenant resolves as null even though IDs are present.</p> <p>Fixes: - Ensure headers/queries only contain a single tenant ID. - Disable <code>RequireMatchAcrossSources</code> or ensure all sources agree on the same ID. - Avoid sending multiple <code>X-Tenant-ID</code> values separated by commas/semicolons.</p>"},{"location":"troubleshooting/multitenancy/#host-based-resolution-returns-null","title":"Host-based resolution returns null","text":"<p>Symptoms: - Host provider does not resolve tenant for subdomains.</p> <p>Fixes: - Ensure requests include a subdomain (for example, <code>tenant.app.com</code>). - Configure <code>HostTenantSelector</code> to support custom host patterns. - Host provider ignores IP addresses and single-segment hosts.</p>"},{"location":"troubleshooting/multitenancy/#cache-scope-mismatch-warnings","title":"Cache scope mismatch warnings","text":"<p>Symptoms: - Logs show \"Cache scope tenant mismatch.\"</p> <p>Fixes: - Call <code>AddCleanArchitectureMultitenancyCaching</code> after <code>AddCleanArchitectureCaching</code>. - Ensure tenant context is set before caching behaviors run.</p>"},{"location":"troubleshooting/multitenancy/#tenant-context-lost-in-background-jobs","title":"Tenant context lost in background jobs","text":"<p>Symptoms: - Background workers execute without tenant context.</p> <p>Fixes: - Serialize <code>TenantContext</code> with <code>ITenantContextSerializer</code> and restore it in the worker. - Wrap work in <code>ITenantAccessor.BeginScope</code> to avoid AsyncLocal leakage.</p>"}]}