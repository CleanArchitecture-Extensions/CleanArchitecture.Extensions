{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CleanArchitecture.Extensions","text":"<p>CleanArchitecture.Extensions is a small set of opt-in NuGet packages that plug into Jason Taylor's Clean Architecture template without forking it.</p>"},{"location":"#what-ships-today","title":"What ships today","text":"<ul> <li><code>CleanArchitecture.Extensions.Caching</code></li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>dotnet add package CleanArchitecture.Extensions.Caching\n</code></pre> <pre><code>services.AddCleanArchitectureCaching();\nservices.AddMediatR(cfg =&gt; cfg.AddCleanArchitectureCachingPipeline());\n</code></pre> <p>No other template changes required.</p>"},{"location":"#where-to-go-next","title":"Where to go next","text":"<ul> <li>Caching docs: extensions/caching.md</li> <li>Extensions catalog: extensions/index.md</li> <li>Roadmap: roadmap.md</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#shipped-preview","title":"Shipped (preview)","text":"<ul> <li>CleanArchitecture.Extensions.Caching \u2014 cache abstractions, adapters, and query caching behavior.</li> </ul>"},{"location":"roadmap/#next","title":"Next","text":"<ul> <li>Multitenancy Core \u2014 tenant model, resolution providers, enforcement behavior.</li> <li>Multitenancy adapters \u2014 EFCore, AspNetCore, Identity (planned).</li> <li>Caching adapters \u2014 Redis and other distributed stores (planned).</li> </ul>"},{"location":"concepts/architecture-fit/","title":"Architecture Fit","text":"<p>How extensions align with Jason Taylor's Clean Architecture template.</p> <ul> <li>Keep the template untouched: extensions plug in via packages, configuration, middleware/behaviors\u2014not by forking or editing the upstream template.</li> <li>Preserve boundaries: respect domain/application/infrastructure/UI separation and dependency direction.</li> <li>Prefer composition: use pipeline behaviors, decorators, filters, and adapters instead of modifying core layers.</li> <li>Match conventions: mirror naming, folder structure, and coding style from the reference <code>JasonTaylorCleanArchitecture</code> copy.</li> <li>Stay optional: every extension should be opt-in with clear defaults and minimal required configuration.</li> </ul>"},{"location":"concepts/composition/","title":"Composition &amp; Invariants","text":"<p>Principles for combining extensions safely.</p> <ul> <li>Isolation: each extension should have clear dependencies and avoid implicit cross-talk.</li> <li>Pipelines first: prefer mediatr behaviors, filters, and decorators to hook in cross-cutting concerns.</li> <li>Config clarity: document required settings, defaults, and compat matrices; fail fast on invalid configs.</li> <li>Observability: emit structured logs/events for extension lifecycle (init, errors, important decisions).</li> <li>Compatibility: declare supported .NET versions and CleanArchitecture template versions per extension page.</li> <li>Exit strategy: provide guidance for disabling/removing an extension cleanly.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We keep the upstream Jason Taylor template pristine and ship everything as opt-in packages. Contributions must follow that contract and stay in sync with the docs and samples.</p>"},{"location":"contributing/#principles","title":"Principles","text":"<ul> <li>Template-first: mirror Jason Taylor\u2019s conventions (folder layout, naming, MediatR pipeline ordering). Do not modify <code>JasonTaylorCleanArchitecture/</code>.</li> <li>Extension = opt-in: minimal required config, no surprises; keep dependencies light.</li> <li>Docs/samples-first: every behavior change lands with updated docs under <code>docs/</code> and, where applicable, a sample under <code>samples/</code>.</li> <li>Tests-close-to-code: add/adjust tests in <code>tests/</code> for the package you touch.</li> </ul>"},{"location":"contributing/#workflow","title":"Workflow","text":"<ol> <li>Pick the design doc: read the matching <code>HighLevelDocs/Domain*/CleanArchitecture.Extensions.*.md</code> before coding.</li> <li>Branch in this repo; keep changes inside <code>CleanArchitecture.Extensions/</code> solution (src/tests/samples/docs/build).</li> <li>Implement + test: add or update unit/integration tests for your changes.</li> <li>Update docs: extension page, recipes, reference, and roadmap if scope changes. Keep nav links valid.</li> <li>Preview docs locally (optional): <pre><code>python -m venv .venv\n. .venv/Scripts/Activate.ps1\npip install -r docs/requirements.txt\nmkdocs serve\n</code></pre></li> <li>Run relevant samples/tests where applicable and note any manual steps in your PR description.</li> </ol>"},{"location":"contributing/#style-docs","title":"Style (docs)","text":"<ul> <li>Follow the documentation strategy templates (overview \u2192 when to use \u2192 compat \u2192 install \u2192 usage \u2192 troubleshooting \u2192 samples/tests).</li> <li>Use fenced code blocks with language tags (<code>bash</code>, <code>powershell</code>, <code>csharp</code>, <code>json</code>).</li> <li>Prefer snippets from source to avoid drift; keep examples short and runnable.</li> <li>Keep compatibility info current (template version, target frameworks, dependencies).</li> </ul>"},{"location":"extensions/","title":"Extensions Catalog","text":"<p>A small catalog of opt-in extensions designed to plug into Jason Taylor's Clean Architecture template without forking it.</p>"},{"location":"extensions/#shipped","title":"Shipped","text":"<ul> <li>CleanArchitecture.Extensions.Caching \u2014 cache abstractions plus query caching behavior: Caching</li> </ul>"},{"location":"extensions/#planned","title":"Planned","text":"<ul> <li>Multitenancy Core \u2014 tenant resolution and enforcement primitives: Multitenancy Core</li> </ul>"},{"location":"extensions/caching/","title":"Extension: Caching","text":""},{"location":"extensions/caching/#overview","title":"Overview","text":"<p>Cache abstractions, key conventions, and a MediatR query caching behavior for Clean Architecture applications. Ships memory and distributed adapters, deterministic key generation, and options for stampede protection and TTL tuning without leaking infrastructure into handlers.</p>"},{"location":"extensions/caching/#when-to-use","title":"When to use","text":"<ul> <li>You want query read-through caching without embedding cache calls in handlers.</li> <li>You need deterministic, namespace/tenant-aware cache keys and provider-agnostic entry options.</li> <li>You plan to start with in-memory caching for dev/test and swap to distributed stores (Redis via <code>IDistributedCache</code>) later.</li> </ul>"},{"location":"extensions/caching/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target frameworks: <code>net10.0</code>.</li> <li>Dependencies: MediatR <code>13.1.0</code>, <code>Microsoft.Extensions.Caching.Abstractions</code>, <code>Microsoft.Extensions.Caching.Memory</code> (defaults); distributed adapter uses <code>IDistributedCache</code> (MemoryDistributedCache by default).</li> <li>Pipeline fit: register <code>QueryCachingBehavior&lt;,&gt;</code> after authorization and request checks, and before performance logging to avoid skewing timing warnings.</li> </ul>"},{"location":"extensions/caching/#install","title":"Install","text":"<pre><code>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"extensions/caching/#usage","title":"Usage","text":""},{"location":"extensions/caching/#register-caching-and-pipeline-behavior","title":"Register caching and pipeline behavior","text":"<pre><code>using CleanArchitecture.Extensions.Caching;\nusing CleanArchitecture.Extensions.Caching.Options;\nusing MediatR;\n\nservices.AddCleanArchitectureCaching(options =&gt;\n{\n    options.DefaultNamespace = \"MyApp\";\n    options.MaxEntrySizeBytes = 256 * 1024; // optional\n}, queryOptions =&gt;\n{\n    queryOptions.DefaultTtl = TimeSpan.FromMinutes(5);\n    // Default predicate caches types whose names end with \"Query\"; override to use a marker instead:\n    // queryOptions.CachePredicate = req =&gt; req is IQueryMarker;\n});\n\nservices.AddMediatR(cfg =&gt;\n{\n    cfg.RegisterServicesFromAssemblyContaining&lt;Program&gt;();\n    cfg.AddCleanArchitectureCachingPipeline(); // place after request checks\n});\n</code></pre>"},{"location":"extensions/caching/#configure-cache-keys-and-ttls","title":"Configure cache keys and TTLs","text":"<ul> <li>Keys follow <code>{namespace}:{tenant?}:{resource}:{hash}</code> via <code>ICacheKeyFactory</code> and <code>ICacheScope</code>. Override <code>ResourceNameSelector</code>/<code>HashFactory</code> in <code>QueryCachingBehaviorOptions</code> for custom resource naming or hashing (e.g., when parameters should be normalized).</li> <li>Default TTL comes from <code>QueryCachingBehaviorOptions.DefaultTtl</code>; override per request type with <code>TtlByRequestType[typeof(MyQuery)] = TimeSpan.FromSeconds(30);</code>.</li> <li><code>CachePredicate</code> controls which requests are cacheable. By default it caches request types whose names end with \"Query\"; override to use markers or explicit type checks. <code>ResponseCachePredicate</code> can skip caching for responses you do not want stored.</li> </ul>"},{"location":"extensions/caching/#choose-an-adapter","title":"Choose an adapter","text":"<ul> <li>Memory (default): registered as <code>ICache</code> by <code>AddCleanArchitectureCaching</code>, uses <code>MemoryCacheAdapter</code> with stampede locking and jitter.</li> <li>Distributed: resolve <code>DistributedCacheAdapter</code> or replace <code>ICache</code> registration:</li> </ul> <pre><code>services.AddCleanArchitectureCaching();\nservices.AddStackExchangeRedisCache(opts =&gt; opts.Configuration = \"...\"); // or other IDistributedCache\nservices.AddSingleton&lt;ICache, DistributedCacheAdapter&gt;(); // override default\n</code></pre>"},{"location":"extensions/caching/#entry-options-and-stampede-settings","title":"Entry options and stampede settings","text":"<ul> <li><code>CachingOptions.DefaultEntryOptions</code> sets absolute/sliding expiration, priority, and size hints.</li> <li><code>CachingOptions.StampedePolicy</code> controls locking timeout and jitter for both adapters.</li> <li><code>CacheEntryOptions</code> can be passed per call or mapped by request type inside the behavior.</li> </ul>"},{"location":"extensions/caching/#response-aware-caching","title":"Response-aware caching","text":"<p>Use <code>QueryCachingBehaviorOptions.ResponseCachePredicate</code> to skip caching responses you want to exclude (for example, error payloads or partial results).</p>"},{"location":"extensions/caching/#key-components","title":"Key components","text":"<ul> <li><code>ICache</code>, <code>CacheEntryOptions</code>, <code>CacheStampedePolicy</code>, <code>CacheKey</code>, <code>ICacheKeyFactory</code>, <code>ICacheScope</code>, <code>ICacheSerializer</code>.</li> <li><code>MemoryCacheAdapter</code>, <code>DistributedCacheAdapter</code> (for <code>IDistributedCache</code>).</li> <li><code>QueryCachingBehavior&lt;TRequest,TResponse&gt;</code> with configurable TTLs, hash selection, predicate, and response filtering.</li> </ul>"},{"location":"extensions/caching/#pipeline-ordering","title":"Pipeline ordering","text":"<ul> <li>Recommended: Authorization \u2192 Request checks \u2192 QueryCachingBehavior \u2192 Performance/Logging \u2192 Handlers (align with the template order you already use).</li> <li>Place caching after request checks to avoid caching invalid requests and before performance logging to exclude cache hits from handler timing warnings.</li> </ul>"},{"location":"extensions/caching/#invalidation-guidance","title":"Invalidation guidance","text":"<ul> <li>Cache-aside pattern: explicit <code>ICache.Remove</code> or <code>ICache.RemoveAsync</code> on command success or domain event handlers.</li> <li>Include versioning and tenant segments in keys to avoid collisions; adjust namespace when making breaking DTO changes.</li> </ul>"},{"location":"extensions/caching/#backlog-next-iteration","title":"Backlog / Next Iteration","text":"<ul> <li>Add PII/classification guardrails so sensitive payloads can be blocked or redirected to encrypted storage.</li> <li>Provide an optional encrypting serializer wrapper for distributed caches with guidance for key management.</li> <li>Expose instrumentation hooks (hits, misses, latency) without forcing a specific metrics provider.</li> <li>Document and/or implement schema-versioned key strategies to support DTO shape changes safely.</li> </ul>"},{"location":"extensions/caching/#testing","title":"Testing","text":"<ul> <li>Use the default memory adapter for Application tests; distributed adapter can use <code>MemoryDistributedCache</code> for deterministic runs.</li> </ul>"},{"location":"extensions/multitenancy-core/","title":"Extension: Multitenancy Core","text":""},{"location":"extensions/multitenancy-core/#overview","title":"Overview","text":"<p>Tenant context and resolution primitives for Clean Architecture solutions.</p>"},{"location":"extensions/multitenancy-core/#when-to-use","title":"When to use","text":"<ul> <li>You need per-tenant isolation (data access, caching, authorization).</li> <li>You want pluggable tenant resolution strategies (host/header/route/claims).</li> </ul>"},{"location":"extensions/multitenancy-core/#prereqs-compatibility","title":"Prereqs &amp; Compatibility","text":"<ul> <li>Target .NET: TBD</li> <li>CleanArchitecture template: TBD</li> <li>Dependencies: TBD</li> </ul>"},{"location":"extensions/multitenancy-core/#install","title":"Install","text":"<p>`\bash</p>"},{"location":"extensions/multitenancy-core/#replace-with-actual-package-name-when-published","title":"replace with actual package name when published","text":"<p>dotnet add src/YourProject/YourProject.csproj package CleanArchitecture.Extensions.Multitenancy `</p>"},{"location":"extensions/multitenancy-core/#usage","title":"Usage","text":"<ul> <li>Register tenant resolution middleware/providers.</li> <li>Flow TenantId through application services and persistence.</li> <li>Add behaviors/filters to enforce tenant scope.</li> </ul>"},{"location":"extensions/multitenancy-core/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure a tenant resolution strategy is configured; fallbacks should be explicit.</li> <li>Log resolved tenant identifiers and resolution source for diagnostics.</li> </ul>"},{"location":"extensions/multitenancy-core/#samples-tests","title":"Samples &amp; Tests","text":"<ul> <li>Link to runnable sample (add when available).</li> <li>Link to related tests once published.</li> </ul>"},{"location":"getting-started/adoption-playbooks/","title":"Adoption playbooks","text":""},{"location":"getting-started/adoption-playbooks/#caching-first-adoption","title":"Caching-first adoption","text":"<p>Use caching for read-heavy queries and expensive lookups.</p> <p>How to get started:</p> <ul> <li>Identify queries with high read frequency or expensive IO.</li> <li>Add the caching behavior and set a response predicate for what to cache.</li> <li>Add invalidation on command success or relevant domain events.</li> </ul> <p>Success signals:</p> <ul> <li>Cache hit ratio climbs without stale data incidents.</li> <li>Latency for cached queries drops measurably.</li> <li>Cache keys are consistent and easy to reason about.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#saas-with-tenant-isolation-planned","title":"SaaS with tenant isolation (planned)","text":"<p>Plan for Multitenancy Core so tenant context is available to caches, storage, and APIs.</p> <p>How to get started:</p> <ul> <li>Define tenant resolution rules (header, route, host, claims).</li> <li>Decide where tenant enforcement should occur (middleware, behaviors).</li> <li>Ensure cache keys include tenant identifiers.</li> </ul>"},{"location":"getting-started/adoption-playbooks/#event-driven-integration-planned","title":"Event-driven integration (planned)","text":"<p>Keep caches consistent when integration events flow between services.</p> <p>How to get started:</p> <ul> <li>Use events to trigger cache invalidation.</li> <li>Track keys or tags so invalidation stays targeted.</li> <li>Keep cross-service cache coupling minimal and explicit.</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#install","title":"Install","text":"<pre><code>dotnet add package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"getting-started/installation/#register","title":"Register","text":"<pre><code>services.AddCleanArchitectureCaching();\nservices.AddMediatR(cfg =&gt; cfg.AddCleanArchitectureCachingPipeline());\n</code></pre> <p>If you do not want automatic query caching, skip <code>AddCleanArchitectureCachingPipeline()</code> and call <code>ICache</code> directly.</p>"},{"location":"getting-started/installation/#uninstall","title":"Uninstall","text":"<pre><code>dotnet remove package CleanArchitecture.Extensions.Caching\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Get caching into a template-based solution in a few minutes.</p> <ol> <li>Install the package:    <pre><code>dotnet add package CleanArchitecture.Extensions.Caching\n</code></pre></li> <li>Register caching and the MediatR pipeline behavior:    <pre><code>services.AddCleanArchitectureCaching();\nservices.AddMediatR(cfg =&gt; cfg.AddCleanArchitectureCachingPipeline());\n</code></pre></li> <li>Configure cache options (expiration, predicate) as needed.</li> <li>No other template changes required.</li> </ol> <p>Next: Caching docs.</p>"},{"location":"recipes/authentication/","title":"Recipe: Authentication","text":""},{"location":"recipes/authentication/#goal","title":"Goal","text":"<p>Wire authentication with extension-friendly hooks.</p>"},{"location":"recipes/authentication/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Auth provider chosen (e.g., JWT, IdentityServer) \u2014 placeholder until packages land.</li> </ul>"},{"location":"recipes/authentication/#steps","title":"Steps","text":"<ol> <li>Add the relevant authentication adapter package (TBD).</li> <li>Configure authentication in Program.cs (or equivalent) with provided helpers.</li> <li>Add middleware/filters for tenant-aware auth if needed.</li> </ol>"},{"location":"recipes/authentication/#verify","title":"Verify","text":"<ul> <li>Hitting a protected endpoint returns 200 with valid token; 401 otherwise.</li> </ul>"},{"location":"recipes/authentication/#pitfalls","title":"Pitfalls","text":"<ul> <li>Misaligned schemes between API and client; ensure defaults match.</li> <li>Ensure tenant resolution occurs before authz when multitenancy is enabled.</li> </ul>"},{"location":"recipes/caching/","title":"Recipe: Caching","text":""},{"location":"recipes/caching/#goal","title":"Goal","text":"<p>Add caching with clear cache key conventions and opt-in behaviors.</p>"},{"location":"recipes/caching/#prereqs","title":"Prereqs","text":"<ul> <li>Base Clean Architecture template running.</li> <li>Choose cache store (in-memory, distributed) \u2014 adapters TBD.</li> </ul>"},{"location":"recipes/caching/#steps","title":"Steps","text":"<ol> <li>Add the caching package: <code>dotnet add package CleanArchitecture.Extensions.Caching</code>.</li> <li>Register caching services and the query caching pipeline behavior (after request checks, before performance logging).</li> <li>Configure cacheability predicate and TTLs per query type; choose memory (default) or distributed adapter.</li> <li>Apply invalidation on command success/domain events where needed (<code>ICache.Remove</code>).</li> </ol>"},{"location":"recipes/caching/#verify","title":"Verify","text":"<ul> <li>First call hits data source; subsequent call hits cache (check logs or set a breakpoint).</li> <li>Change input parameters and confirm a different cache key/hash is used.</li> </ul>"},{"location":"recipes/caching/#pitfalls","title":"Pitfalls","text":"<ul> <li>Cache stampede: add locking or jitter where needed.</li> <li>Tenant-aware caching: ensure keys include tenant context when multitenancy is enabled.</li> <li>Avoid caching error or transient responses; use <code>ResponseCachePredicate</code> to skip them.</li> </ul>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>Configuration keys and environment variables for extensions.</p> <ul> <li>This section will expand per extension as packages ship.</li> <li>Include defaults, required values, and sample \u0007ppsettings snippets.</li> </ul>"},{"location":"reference/configuration/#placeholder-keys","title":"Placeholder keys","text":"<ul> <li>Extensions::Enabled <li>Extensions::Options (TBD per extension)"},{"location":"release-notes/","title":"Release Notes","text":"<p>Changelog for CleanArchitecture.Extensions (latest-only for now).</p> <ul> <li>Add a section per release once packages ship.</li> <li>Call out breaking changes and migration steps.</li> </ul>"},{"location":"roadmap/package-blueprints/","title":"Package blueprints","text":""},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionscaching-shipped","title":"CleanArchitecture.Extensions.Caching (shipped)","text":"<p>What it provides:</p> <ul> <li>Cache abstractions with memory and distributed adapters.</li> <li>Query caching behavior for MediatR.</li> <li>Simple configuration for expiration and cache predicates.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain1-CoreArchitectureExtensions/CleanArchitecture.Extensions.Caching.md</li> <li>Docs: docs/extensions/caching.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancy-planned","title":"CleanArchitecture.Extensions.Multitenancy (planned)","text":"<p>What it will provide:</p> <ul> <li>Tenant model and current tenant abstraction.</li> <li>Resolution providers (header, route, host, claims).</li> <li>Enforcement behaviors for tenant-aware pipelines.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.md</li> <li>Docs: docs/extensions/multitenancy-core.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyefcore-planned","title":"CleanArchitecture.Extensions.Multitenancy.EFCore (planned)","text":"<p>What it will provide:</p> <ul> <li>Tenant-aware DbContext helpers and filters.</li> <li>Patterns for shared and schema-per-tenant databases.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.EFCore.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyaspnetcore-planned","title":"CleanArchitecture.Extensions.Multitenancy.AspNetCore (planned)","text":"<p>What it will provide:</p> <ul> <li>Middleware and endpoint helpers for tenant resolution.</li> <li>Minimal API and controller integration points.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.AspNetCore.md</li> </ul>"},{"location":"roadmap/package-blueprints/#cleanarchitectureextensionsmultitenancyidentity-planned","title":"CleanArchitecture.Extensions.Multitenancy.Identity (planned)","text":"<p>What it will provide:</p> <ul> <li>Tenant-aware Identity helpers and policies.</li> </ul> <p>Design notes:</p> <ul> <li>HighLevelDocs/Domain2-Multitenancy/CleanArchitecture.Extensions.Multitenancy.Identity.md</li> </ul>"},{"location":"samples/","title":"Samples","text":"<p>There are no runnable samples in the repo right now.</p> <p>Planned samples: - Caching query behavior with invalidation on command success. - Multitenancy core resolution (header/route) with enforcement.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and fixes (expand as features land).</p> <ul> <li>Extension fails to start: enable debug logs and check config keys.</li> <li>Tenant not resolved: verify provider order (host/header/route/claims) and add logging for resolution steps.</li> <li>Caching mismatches: confirm cache keys include tenant/user when required.</li> </ul>"}]}